// ==========================================
// ğŸš€ [Main.gs] ì‹¤í–‰ ë° ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ (Final Integrated Build)
// ==========================================

// ğŸ”µ [UI] êµ¬ê¸€ ì‹œíŠ¸ ë©”ë‰´ ìƒì„±
function onOpen() {
  SpreadsheetApp.getUi()
      .createMenu('Financial Avengers')
            .addItem('ğŸ” ì„ íƒ í–‰ ë¶„ì„', 'runSelectedRowAnalysis')
      .addItem('ğŸ§¾ Final_Report ìƒì„±(ì„ íƒ í–‰)', 'buildFinalReportForSelectedRow')
      .addItem('ğŸ”’ í”Œëœ ìŠ¤ëƒ…ìƒ· ë½(ì„ íƒ í–‰)', 'lockPlanSnapshotForSelectedRow')
      .addItem('ğŸ§­ Regime ì²´í¬&í”Œëœ ì—…ë°ì´íŠ¸(ì„ íƒ í–‰)', 'runRegimeUpdateTriggerForSelectedRow')
      .addItem('ğŸ›¡ï¸ Scanner ë°ì´í„° ê²€ì¦', 'runScannerValidation')
      .addItem('ğŸ›°ï¸ Signal Radar ì‹¤í–‰', 'runSignalRadar')
      .addItem('ğŸ§  ê°€ì„¤ íšŒì˜ ìƒì„±(Builder/Challenger)', 'runHypothesisMeeting')
      .addSeparator()
      .addItem('ğŸ“Œ ê°€ì„¤ ë…¸ì¶œ êµ¬ì¡° ë³´ê¸° (A/B/C)', 'openHypothesisExposureView')
.addItem('â° STEP6: ë°˜ì¦ ì ê²€ íŠ¸ë¦¬ê±° ì„¤ì¹˜(ì¼ê°„)', 'installStep6RefuteDailyTrigger')
      .addItem('ğŸ§¾ STEP6: Refute_Events ì‹œíŠ¸ ì—´ê¸°', 'openStep6RefuteEventsSheet')
      .addItem('ğŸ§­ STEP6: ì—°ê´€ ì´ë²¤íŠ¸ í›„ë³´ ìƒì„±(ì„ íƒ ê°€ì„¤)', 'generateRefuteEventCandidatesForSelectedHypothesis')
      .addItem('ğŸ¤– STEP6: AI ìš”ì•½/ì„ì‹œë¶„ë¥˜ ì±„ìš°ê¸°(ì„ íƒ ê°€ì„¤)', 'fillAISummaryDirectionForSelectedHypothesis')
      .addItem('ğŸ“Š STEP6: ì ìˆ˜/ì œì•ˆ ê°±ì‹ (ì„ íƒ ê°€ì„¤)', 'updateStep6ScoreSuggestionForSelectedHypothesis')
      .addItem('ğŸ” íšŒì˜ë¡ íŒì—… (ì„ íƒ ì¢…ëª©)', 'openAvengersReport')
      .addItem('ğŸ“Š í¬íŠ¸í´ë¦¬ì˜¤ ì „ì²´ ë¶„ì„ ë³´ê³ ì„œ ìƒì„± (Full Portfolio Fit)', 'generatePortfolioReport')
      .addItem('ğŸ§­ Regime ì²´í¬&í”Œëœ ì—…ë°ì´íŠ¸(ì„ íƒ í”Œëœ)', 'runRegimeUpdateTriggerForSelectedRow')
      .addToUi();
}

// ğŸ›°ï¸ [NEW] Signal Radar ì‹¤í–‰ â†’ Gemini í˜¸ì¶œ â†’ SignalRadarLog ì €ì¥
function runSignalRadar() {
  const config = getConfig();

  const domain = Browser.inputBox(
    "ğŸ›°ï¸ Signal Radar",
    "Domain (ì˜ˆ: Macro / Regulation / Supply Chain / Market Structure / Behavior / Other)\nììœ  ì…ë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤.",
    Browser.Buttons.OK_CANCEL
  );
  if (domain === "cancel") return;

  const signal = Browser.inputBox(
    "ğŸ›°ï¸ Signal Radar",
    "Signal (ê´€ì¸¡/ëŠë‚Œ 1~2ë¬¸ì¥, ë¹„ì–´ë„ ì‹¤í–‰ ê°€ëŠ¥)",
    Browser.Buttons.OK_CANCEL
  );
  if (signal === "cancel") return;

  
  // OptionalContext / OptionalPortfolioContext (í˜„ì¬ ë‹¨ê³„ì—ì„œëŠ” ë¹„ì›Œë‘ )
  const OptionalContext = "";
  const OptionalPortfolioContext = "";

  const SYSTEM_PROMPT = `You are "Signal Radar" â€” a Problem-Raising Agent.

INPUTS (may be empty):
- OptionalContext: up to 5 lines of constraints/context.
- OptionalPortfolioContext: up to 5 items of interests (tickers/sectors). IMPORTANT: Do NOT output or mention any ticker. If OptionalPortfolioContext contains tickers, ignore tickers and only use non-ticker themes (sector/factor/phenomenon).

MISSION:
- Produce candidate TriggerNotes for a later Hypothesis Meeting (Builder/Challenger).
- You must NOT provide conclusions, recommendations, or confidence.
- Your job is to detect a plausible "signal" (anomaly) and turn it into falsifiable/observable questions.

HARD RULES (NON-NEGOTIABLE):
1) NO STOCK RECOMMENDATIONS. No tickers. Tickers are forbidden even as examples. TriggerNotes must be sector/factor/phenomenon-focused.
2) No deterministic language such as "í™•ì‹¤", "ë¬´ì¡°ê±´", "ë°˜ë“œì‹œ", "will definitely". Use conditional language only.
3) If you do not know, say "ëª¨ë¥¸ë‹¤" and convert it into verification questions.
4) Output MUST be in the exact fixed format below. No extra text, no explanations, no additional sections.
5) Signal must be exactly ONE sentence describing an "anomaly" (e.g., lead-time surge, cost-structure distortion, regulation wording surge, staffing bottleneck, capacity constraint, demand collapse, fraud-risk spike).
6) AutoQuestions must be 3 to 7 items, each designed to be answered by observation/data (prefer "what data would confirm/deny").
7) SuggestedTriggerNotes must be 1 to 3 items, each 1â€“2 sentences, written as a candidate note to paste into a Hypothesis Meeting. Do NOT include investment actions.

OUTPUT FORMAT (EXACT):
===SIGNAL_RADAR===
Domain:
Signal:
AutoQuestions:
- Q1:
- Q2:
- Q3:
(Optional Q4~Q7)

SuggestedTriggerNotes:
- T1: (1~2ë¬¸ì¥)
- T2:
- T3: (ì„ íƒ)

StatusSuggestion: (DRAFT/IGNORED ì¤‘ 1)
NextScanSuggestion: (ì˜ˆ: 7d / 14d / 30d)
===END===

DOMAIN GUIDANCE:
- Domain must be one short label such as: "Physics/Infrastructure", "Supply Chain", "Regulation", "Macro/Liquidity", "Labor/Skills", "Security/Legal", "Competition/Market Structure", "Cost Structure", "Demand/Behavior", "Ops/Capacity".
- Choose ONE best-fit domain.

DECISION RULES FOR StatusSuggestion:
- Choose "DRAFT" if there is at least one concrete observable question and at least one TriggerNote candidate.
- Choose "IGNORED" if the signal is too vague or cannot be turned into observable questions without speculation.

DECISION RULES FOR NextScanSuggestion:
- Use "7d" if signal implies near-term volatility or fast-changing constraints.
- Use "14d" if signal seems medium-tempo.
- Use "30d" if signal is structural/slow-moving.

LANGUAGE:
- Output in Korean (primary). Use English terms only when they are standard labels (e.g., "lead time", "capex", "power density") and keep them minimal.
`;

  const prompt = [
    SYSTEM_PROMPT,
    "",
    "[INPUT]",
    `Domain: ${domain || ""}`,
    `Signal: ${signal || ""}`,
    OptionalContext ? `OptionalContext:\n${OptionalContext}` : "",
    OptionalPortfolioContext ? `OptionalPortfolioContext:\n${OptionalPortfolioContext}` : ""
  ].filter(x => x !== "").join("\n");

  const reply = callGemini(prompt, config.MODEL_NAME);

  const logSheet = ensureSignalRadarLogSheet();
  const createdAt = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm:ss");

  // ê¸°ë³¸ê°’ (íŒŒì‹± ì‹¤íŒ¨ ëŒ€ë¹„)
  let parsedDomain = String(domain || "");
  let parsedSignal = String(signal || "");
  let autoQuestions = "";
  let suggestedTriggerNotes = "";
  let status = "DRAFT";

  try {
    const text = String(reply || "");
    const startIdx = text.indexOf("===SIGNAL_RADAR===");
    const endIdx = text.indexOf("===END===");
    if (startIdx === -1 || endIdx === -1 || endIdx <= startIdx) {
      throw new Error("SignalRadarParseError");
    }

    const block = text.substring(startIdx + "===SIGNAL_RADAR===".length, endIdx);

    const mDomain = block.match(/\n\s*Domain:\s*(.*)/);
    const mSignal = block.match(/\n\s*Signal:\s*(.*)/);

    if (mDomain && mDomain[1] !== undefined) parsedDomain = String(mDomain[1]).trim() || parsedDomain;
    if (mSignal && mSignal[1] !== undefined) parsedSignal = String(mSignal[1]).trim() || parsedSignal;

    // AutoQuestions
    const aqLabel = "AutoQuestions:";
    const stLabel = "SuggestedTriggerNotes:";
    const aqStart = block.indexOf(aqLabel);
    const stStart = block.indexOf(stLabel);

    if (aqStart !== -1 && stStart !== -1 && stStart > aqStart) {
      const aqBlock = block.substring(aqStart + aqLabel.length, stStart).trim();
      const aqLines = aqBlock.split(/\n/).map(s => String(s || "").trim()).filter(s => s.indexOf("-") === 0);
      const qs = aqLines
        .map(s => s.replace(/^[-\s]*/, "").replace(/^Q\d+\s*:\s*/, "").trim())
        .filter(s => s);
      autoQuestions = qs.join("\n");
    }

    // SuggestedTriggerNotes
    const statusLabel = "StatusSuggestion:";
    const ssStart = block.indexOf(stLabel);
    const statusStart = block.indexOf(statusLabel);

    if (ssStart !== -1 && statusStart !== -1 && statusStart > ssStart) {
      const sBlock = block.substring(ssStart + stLabel.length, statusStart).trim();
      const sLines = sBlock.split(/\n/).map(s => String(s || "").trim()).filter(s => s.indexOf("-") === 0);
      const ts = sLines
        .map(s => s.replace(/^[-\s]*/, "").replace(/^T\d+\s*:\s*/, "").trim())
        .filter(s => s);
      suggestedTriggerNotes = ts.join("\n");
    }

    const mStatus = block.match(/\n\s*StatusSuggestion:\s*(DRAFT|WATCH|SMALL_BET|IGNORE|PICKED|IGNORED)/);
    if (mStatus && mStatus[1]) status = String(mStatus[1]).trim();

    // íŒŒì‹±ì€ ëì§€ë§Œ ë‚´ìš©ì´ ë¹„ì—ˆìœ¼ë©´ ì›ë¬¸ ì €ì¥(ìš”êµ¬ì‚¬í•­)
    if (!autoQuestions) {
      autoQuestions = text;
      status = "DRAFT";
    }
  } catch (e) {
    Logger.log('STEP6 DIAGv3 ERROR: ' + (e && e.stack ? e.stack : e));
    autoQuestions = String(reply || "");
    suggestedTriggerNotes = "";
    status = "DRAFT";
  }

  // âš ï¸ Google SheetsëŠ” ì…€ ê°’ì´ '='ë¡œ ì‹œì‘í•˜ë©´ ìˆ˜ì‹ìœ¼ë¡œ í•´ì„í•˜ì—¬ #ERROR(ìˆ˜ì‹ íŒŒì‹± ì˜¤ë¥˜)ê°€ ë°œìƒí•  ìˆ˜ ìˆìŒ
  // Signal Radar ì¶œë ¥(ì˜ˆ: '===SIGNAL_RADAR===')ì„ í…ìŠ¤íŠ¸ë¡œ ê°•ì œí•˜ê¸° ìœ„í•´ ì„ í–‰ apostropheë¥¼ ì¶”ê°€
  if (typeof autoQuestions === "string" && autoQuestions.charAt(0) === "=") autoQuestions = "'" + autoQuestions;
  if (typeof suggestedTriggerNotes === "string" && suggestedTriggerNotes.charAt(0) === "=") suggestedTriggerNotes = "'" + suggestedTriggerNotes;
  if (typeof parsedSignal === "string" && parsedSignal.charAt(0) === "=") parsedSignal = "'" + parsedSignal;
  if (typeof parsedDomain === "string" && parsedDomain.charAt(0) === "=") parsedDomain = "'" + parsedDomain;

  logSheet.appendRow([createdAt, parsedDomain, parsedSignal, autoQuestions, suggestedTriggerNotes, status, ""]);
  SpreadsheetApp.getActiveSpreadsheet().toast("âœ… SignalRadarLogì— ì €ì¥ ì™„ë£Œ", "Signal Radar", 3);
}

// ğŸ§  [NEW] ê°€ì„¤ íšŒì˜ ìƒì„±(Builder/Challenger) â†’ Gemini í˜¸ì¶œ â†’ HypothesisBacklog ì €ì¥
function runHypothesisMeeting() {
  const config = getConfig();

  // 1) ì…ë ¥ ë°©ì‹ ì„ íƒ
  const mode = Browser.inputBox(
    "ğŸ§  ê°€ì„¤ íšŒì˜ ìƒì„±(Builder/Challenger)",
    "ì„ íƒí•˜ì„¸ìš”:\nA) TriggerNote ì§ì ‘ ì…ë ¥\nB) SignalRadarLog(ì„ íƒ í–‰ ìš°ì„ , ì—†ìœ¼ë©´ DRAFT ìµœì‹  1ê°œ)ì—ì„œ SuggestedTriggerNotes ì¤‘ ì„ íƒ\n\nA ë˜ëŠ” Bë¥¼ ì…ë ¥í•˜ì„¸ìš”.",
    Browser.Buttons.OK_CANCEL
  );
  if (mode === "cancel") return;

  let triggerNote = "";
  let domain = "";
  let signal = "";

  const upperMode = String(mode || "").trim().toUpperCase();

  if (upperMode === "A") {
    const t = Browser.inputBox(
      "ğŸ§  ê°€ì„¤ íšŒì˜ ìƒì„±",
      "TriggerNote (1~2ë¬¸ì¥)ì„ ì…ë ¥í•˜ì„¸ìš”.",
      Browser.Buttons.OK_CANCEL
    );
    if (t === "cancel") return;
    triggerNote = String(t || "").trim();
  } else if (upperMode === "B") {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const logSheet = ss.getSheetByName("SignalRadarLog");
    if (!logSheet) {
      SpreadsheetApp.getUi().alert("âš ï¸ SignalRadarLog ì‹œíŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. A) ì§ì ‘ ì…ë ¥ìœ¼ë¡œ ì§„í–‰í•˜ì„¸ìš”.");
      return;
    }

    const lastRow = logSheet.getLastRow();
    const lastCol = logSheet.getLastColumn();
    if (lastRow < 2 || lastCol < 7) {
      SpreadsheetApp.getUi().alert("âš ï¸ SignalRadarLogì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. A) ì§ì ‘ ì…ë ¥ìœ¼ë¡œ ì§„í–‰í•˜ì„¸ìš”.");
      return;
    }

    const values = logSheet.getRange(1, 1, lastRow, lastCol).getValues();
    const headers = values[0].map(h => String(h || "").trim());
    const idxCreatedAt = headers.indexOf("CreatedAt");
    const idxDomain = headers.indexOf("Domain");
    const idxSignal = headers.indexOf("Signal");
    const idxSuggested = headers.indexOf("SuggestedTriggerNotes");
    const idxStatus = headers.indexOf("Status");

    if (idxSuggested === -1 || idxStatus === -1) {
      SpreadsheetApp.getUi().alert("âš ï¸ SignalRadarLog í—¤ë”ê°€ ì˜ˆìƒê³¼ ë‹¤ë¦…ë‹ˆë‹¤. A) ì§ì ‘ ì…ë ¥ìœ¼ë¡œ ì§„í–‰í•˜ì„¸ìš”.");
      return;
    }

    // SignalRadarLogì—ì„œ ì„ íƒí•œ í–‰ì´ ìˆìœ¼ë©´ ê·¸ í–‰ì„ ìš°ì„  ì‚¬ìš©
    let pickedRow = null;
    const activeSheet = ss.getActiveSheet();
    const activeRange = ss.getActiveRange();
    const selectedRowNum = (activeSheet && activeSheet.getName() === "SignalRadarLog" && activeRange) ? activeRange.getRow() : null;

    if (selectedRowNum && selectedRowNum >= 2 && selectedRowNum <= lastRow) {
      pickedRow = values[selectedRowNum - 1];
    }

    // ì„ íƒ í–‰ì´ ì—†ìœ¼ë©´ ìµœì‹  DRAFT 1ê°œ ì°¾ê¸°
    if (!pickedRow) {
      for (let r = lastRow - 1; r >= 1; r--) {
        const statusVal = String(values[r][idxStatus] || "").trim().toUpperCase();
        const sugVal = String(values[r][idxSuggested] || "").trim();
        if (statusVal === "DRAFT" && sugVal) {
          pickedRow = values[r];
          break;
        }
      }
    }
    // [PATCH] removed stray closing brace that caused SyntaxError (Unexpected token else)

    if (!pickedRow) {
      SpreadsheetApp.getUi().alert("âš ï¸ Status=DRAFTì¸ SignalRadarLog í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤. A) ì§ì ‘ ì…ë ¥ìœ¼ë¡œ ì§„í–‰í•˜ì„¸ìš”.");
      return;
    }

    domain = (idxDomain !== -1) ? String(pickedRow[idxDomain] || "").trim() : "";
    signal = (idxSignal !== -1) ? String(pickedRow[idxSignal] || "").trim() : "";

    const suggestedRaw = String(pickedRow[idxSuggested] || "").trim();
    const candidates = suggestedRaw.split(/\n+/).map(s => String(s || "").trim()).filter(s => s);

    if (candidates.length === 0) {
      SpreadsheetApp.getUi().alert("âš ï¸ SuggestedTriggerNotesê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. A) ì§ì ‘ ì…ë ¥ìœ¼ë¡œ ì§„í–‰í•˜ì„¸ìš”.");
      return;
    }

    // í›„ë³´ í‘œì‹œ
    let msg = "ìµœì‹  DRAFT SuggestedTriggerNotes í›„ë³´ì…ë‹ˆë‹¤. ë²ˆí˜¸ë¥¼ ì„ íƒí•˜ì„¸ìš”:\n\n";
    for (let i = 0; i < candidates.length; i++) {
      msg += (i + 1) + ") " + candidates[i] + "\n\n";
    }
    const pick = Browser.inputBox("ğŸ§  ê°€ì„¤ íšŒì˜ ìƒì„±", msg + "ë²ˆí˜¸(1~" + candidates.length + ")ë¥¼ ì…ë ¥í•˜ì„¸ìš”.", Browser.Buttons.OK_CANCEL);
    if (pick === "cancel") return;

    const n = parseInt(String(pick || "").trim(), 10);
    if (isNaN(n) || n < 1 || n > candidates.length) {
      SpreadsheetApp.getUi().alert("âš ï¸ ìœ íš¨í•˜ì§€ ì•Šì€ ë²ˆí˜¸ì…ë‹ˆë‹¤.");
      return;
    }

    triggerNote = candidates[n - 1];
  } else {
    SpreadsheetApp.getUi().alert("âš ï¸ A ë˜ëŠ” Bë§Œ ì…ë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤.");
    return;
  }

  if (!triggerNote) {
    SpreadsheetApp.getUi().alert("âš ï¸ TriggerNoteê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.");
    return;
  }

  // 2) Hypothesis Meeting í”„ë¡¬í”„íŠ¸ ìƒì„±

  // âœ… STEP1/STEP2: SYSTEM PROMPTëŠ” callGemini ì§ì „ì— ê°•ì œ ì£¼ì…(finalPrompt)
  const userPrompt = [
    "",
    "[INPUT]",
    domain ? ("Domain: " + domain) : "",
    signal ? ("Signal: " + signal) : "",
    "TriggerNote: " + triggerNote
  ].filter(x => x !== "").join("\n");

  const finalPrompt = SYSTEM_PROMPT_HYPOTHESIS_MEETING + "\n\n" + userPrompt;

  // 3) Gemini í˜¸ì¶œ (ìˆ˜ì • ê¸ˆì§€)
  const reply = callGemini(finalPrompt, config.MODEL_NAME);

  // 4) ì‘ë‹µ íŒŒì‹± (íŒŒì‹± ì‹¤íŒ¨ ì‹œì—ë§Œ Invalid ê¸°ë¡)
  let hypothesisText = "";
  let builderText = "";
  let challengerText = "";
  let fastFalsifiersText = "";
  let exposureTypesText = "";
  let status = "DRAFT";

  try {
    const text = String(reply || "");
    const startIdx = text.indexOf("===HYPOTHESIS_MEETING===");
    const endIdx = text.indexOf("===END===");
    if (startIdx === -1 || endIdx === -1 || endIdx <= startIdx) {
      throw new Error("HypothesisParseError");
    }

    const block = String(text.substring(startIdx + "===HYPOTHESIS_MEETING===".length, endIdx) || "").trim();

    // âœ… STEP2 ê³ ì • í‚¤ ê¸°ë°˜ íŒŒì‹± (í‚¤/êµ¬ë¶„ì ë³€ê²½ ê¸ˆì§€)
    const iHyp = block.indexOf("Hypothesis:");
    const iBR = block.indexOf("Builder_Rationale:");
    const iCA = block.indexOf("Challenger_Attack:");
    const iFF = block.indexOf("Fast_Falsifiers:");
    const iET = block.indexOf("Exposure_Types:");
    const iSS = block.indexOf("StatusSuggestion:");

    if (iHyp === -1 || iBR === -1 || iCA === -1 || iFF === -1 || iET === -1 || iSS === -1) {
      throw new Error("HypothesisKeyMissing");
    }

    hypothesisText = String(block.substring(iHyp + "Hypothesis:".length, iBR) || "").trim();
    builderText = String(block.substring(iBR + "Builder_Rationale:".length, iCA) || "").trim();
    challengerText = String(block.substring(iCA + "Challenger_Attack:".length, iFF) || "").trim();
    fastFalsifiersText = String(block.substring(iFF + "Fast_Falsifiers:".length, iET) || "").trim();
    exposureTypesText = String(block.substring(iET + "Exposure_Types:".length, iSS) || "").trim();
    const statusRaw = String(block.substring(iSS + "StatusSuggestion:".length) || "").trim();

    // StatusSuggestion ì •í•©í™” (IGNORED -> IGNORE)
    const st = String(statusRaw || "").trim().toUpperCase();
    if (st === "IGNORED") status = "IGNORE";
    else if (st === "PICKED") status = "WATCH";
    else if (st === "DRAFT" || st === "WATCH" || st === "SMALL_BET" || st === "IGNORE") status = st;
    else status = "DRAFT";

    if (!hypothesisText && !builderText && !challengerText && !fastFalsifiersText && !exposureTypesText) {
      throw new Error("HypothesisParseEmpty");
    }
  } catch (e) {
    // âœ… STEP2 ìš”êµ¬: íŒŒì‹± ì‹¤íŒ¨ ì‹œì—ë§Œ Invalid Response Structure ê¸°ë¡
    hypothesisText = "";
    builderText = "Gemini Invalid Response Structure";
    challengerText = "";
    fastFalsifiersText = "";
    exposureTypesText = "";
    status = "DRAFT";
  }

  // 5) HypothesisBacklog ì €ì¥
  const backlog = ensureHypothesisBacklogSheet();
  // [PATCH] HypothesisBacklog Status dropdown must include EXIT_PENDING (STEP6-6)
  try {
    const hbLastRowForDV = Math.max(2, backlog.getLastRow());
    const hbHeadersForDV = backlog.getRange(1, 1, 1, backlog.getLastColumn()).getValues()[0].map(h => String(h || "").trim());
    const hbStatusColIdx = hbHeadersForDV.indexOf("Status");
    if (hbStatusColIdx >= 0) {
      const hbRule = SpreadsheetApp.newDataValidation()
        .requireValueInList(["DRAFT", "WATCH", "SMALL_BET", "IGNORE", "EXIT_PENDING"], true)
        .setAllowInvalid(false)
        .build();
      backlog.getRange(2, hbStatusColIdx + 1, hbLastRowForDV - 1, 1).setDataValidation(hbRule);
    }
  } catch (e) {
    // ignore: do not break Hypothesis meeting if DV fails
  }
  const createdAt = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm:ss");

  const headerRow = backlog.getRange(1, 1, 1, backlog.getLastColumn()).getValues()[0]
    .map(h => String(h || "").trim());

  const row = new Array(headerRow.length).fill("");

  // í—¤ë” ë§¤í•‘ (ì¡´ì¬í•˜ëŠ” ì»¬ëŸ¼ë§Œ ì±„ì›€)
  const setByHeader = function(names, value) {
    for (let i = 0; i < headerRow.length; i++) {
      const h = String(headerRow[i] || "").trim().toLowerCase();
      for (let j = 0; j < names.length; j++) {
        if (h === String(names[j]).toLowerCase()) {
          row[i] = value;
          return;
        }
      }
    }
  };

  setByHeader(["CreatedAt", "createdat", "Date", "date", "Timestamp", "timestamp"], createdAt);
  setByHeader(["Domain", "domain"], domain);
  setByHeader(["Signal", "signal"], signal);
  setByHeader(["TriggerNote", "triggernote", "Trigger", "trigger"], triggerNote);
  // âœ… STEP2/STEP3: ê³ ì • í¬ë§· ì»¬ëŸ¼ ë§¤í•‘
  setByHeader(["Hypothesis", "hypothesis"], hypothesisText);
  setByHeader(["Builder_Rationale", "builder_rationale", "BuilderRationale"], builderText);
  setByHeader(["Challenger_Attack", "challenger_attack", "ChallengerAttack"], challengerText);
  setByHeader(["Fast_Falsifiers", "fast_falsifiers", "FastFalsifiers"], fastFalsifiersText);
  setByHeader(["Exposure_Types", "exposure_types", "ExposureTypes"], exposureTypesText);
  setByHeader(["StatusSuggestion", "statussuggestion", "Status_Suggestion", "status_suggestion"], status);
  setByHeader(["Status", "status"], status);
  setByHeader(["Note", "note"], "");

  // ìµœì†Œ ë³´ì¥: í—¤ë”ê°€ ë§¤ì¹­ë˜ì§€ ì•Šì•„ë„ ì²« ì»¬ëŸ¼ì— createdAt, ë‘ë²ˆì§¸ì— triggerNoteë¼ë„ ë„£ìŒ
  if (headerRow.length > 0 && row[0] === "") row[0] = createdAt;
  if (headerRow.length > 1 && row[1] === "") row[1] = triggerNote;
  if (headerRow.length > 2 && row[2] === "" && domain) row[2] = domain;
  if (headerRow.length > 3 && row[3] === "" && signal) row[3] = signal;
  if (headerRow.length > 4 && row[4] === "" && builderText) row[4] = builderText;
  if (headerRow.length > 5 && row[5] === "" && status) row[5] = status;

  backlog.appendRow(row);

  SpreadsheetApp.getActiveSpreadsheet().toast("âœ… HypothesisBacklogì— ì €ì¥ ì™„ë£Œ", "Hypothesis Meeting", 3);
}



// ğŸ”µ [UI] ì„ íƒëœ ì¢…ëª©ì˜ íšŒì˜ë¡ íŒì—… UI ìƒì„±
function openAvengersReport() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getActiveSheet();
  // Detect AssetType/Underlying columns (for ETF / Leveraged ETF template branching)
  const _hdr = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(v => String(v || '').trim());
  let assetTypeCol = -1;
  let underlyingCol = -1;
  for (let c = 0; c < _hdr.length; c++) {
    if (_hdr[c] === 'AssetType') assetTypeCol = c + 1;
    if (_hdr[c] === 'Underlying') underlyingCol = c + 1;
  }
  const row = sheet.getActiveCell().getRow();
  const startRow = row;
  const endRow = row;

  if (row < 2) {
    Browser.msgBox("ì¢…ëª©ì´ ìˆëŠ” í–‰(2í–‰ ì´ìƒ)ì„ ì„ íƒí•´ì£¼ì„¸ìš”.");
    return;
  }
  
  const ticker = sheet.getRange(row, 1).getValue(); // Aì—´: ì¢…ëª©
  const advice = sheet.getRange(row, 8).getValue(); // Hì—´: ì „ë¬¸ê°€ì¡°ì–¸(ìƒì„¸)

  if (!advice || String(advice).length < 50) {
    Browser.msgBox(`[${ticker}] ì•„ì§ ë¶„ì„ ë¦¬í¬íŠ¸ê°€ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n'ğŸš€ ë¶„ì„ ì‹¤í–‰'ì„ ë¨¼ì € ì§„í–‰í•´ì£¼ì„¸ìš”.`);
    return;
  }
  
  const sections = parseAvengersReportSections(advice);

  const template = HtmlService.createTemplateFromFile('AvengersReport');
  template.ticker = ticker;
  template.sections = sections; 

  const html = template.evaluate()
      .setWidth(1400)
    .setHeight(900);
  SpreadsheetApp.getUi().showModalDialog(html, `${ticker} íˆ¬ì ì „ëµ íšŒì˜ë¡`);
}

// ğŸ”µ [NEW] í¬íŠ¸í´ë¦¬ì˜¤ ì „ì²´ ë¶„ì„ ë³´ê³ ì„œ ìƒì„± í•¨ìˆ˜
function generatePortfolioReport() {
  const config = getConfig();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet1 = ss.getSheetByName("ì‹œíŠ¸1");
  const pSheet = ensurePortfolioSheet();
  const scannerSheet = ss.getSheetByName(config.SCANNER_SHEET_NAME);

  // 1. ë°ì´í„° ì§‘ê³„ (Logic.gs í•¨ìˆ˜ í˜¸ì¶œ)
  const summary = getFullPortfolioData(sheet1, scannerSheet); 
  const safetyRatio = normalizePercentRatio(pSheet.getRange("C7").getValue(), config.SAFETY_CORE_MIN);
  const cashWeight = normalizePercentRatio(pSheet.getRange("C4").getValue(), 0);
  const totalAssets = summary.totalVal;

  // Market Regime ê³„ì‚°
  const regime = classifyMarketRegime(safetyRatio, summary.lossRatio, summary.avgMdd);

  // ë°ì´í„° ë¬¸ìì—´ ë³€í™˜
  const topHoldingsStr = summary.topHoldings.slice(0, 5)
    .map(h => `${h.ticker}(${Number(h.weight || 0).toFixed(1)}%)`)
    .join(", ");
  const sectorInfo = summary.sectors.slice(0, 3)
    .map(s => `${s.name}(${Number(s.weight || 0).toFixed(1)}%)`)
    .join(", ");

  // 2. í”„ë¡¬í”„íŠ¸ ìƒì„±
  const prompt = getFullPortfolioReportPrompt(
    safetyRatio,
    summary.lossRatio,
    summary.avgMdd,
    regime,
    cashWeight,
    topHoldingsStr,
    sectorInfo,
    totalAssets
  );

  // 3. Gemini í˜¸ì¶œ
  if (typeof callGemini !== 'function') {
    throw new Error('ReferenceError: callGemini is not defined (Logic.gsê°€ í”„ë¡œì íŠ¸ì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸)');
  }

  // [REFERENCE_CONTEXT] (ì˜µì…˜) ìµœì‹  WATCH/SMALL_BET ê°€ì„¤ 1ê°œë¥¼ ì°¸ê³ ë¡œë§Œ ë§ë¶™ì„
  let promptForGemini = prompt;
  try {
    const hbSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("HypothesisBacklog");
    if (hbSheet) {
      const hbValues = hbSheet.getDataRange().getValues();
      if (hbValues && hbValues.length >= 2) {
        const hbHeaders = hbValues[0].map(h => String(h || "").trim());
        const idxStatus = hbHeaders.indexOf("Status");
        const idxHypothesis = hbHeaders.indexOf("Hypothesis");
        const idxFalsifiers = hbHeaders.indexOf("FastFalsifiers");
        const idxExposure = hbHeaders.indexOf("ExposureTypes");

        if (idxStatus >= 0 && idxHypothesis >= 0 && idxFalsifiers >= 0 && idxExposure >= 0) {
          // ì•„ë˜ì—ì„œë¶€í„° ì˜¬ë¼ê°€ë©° ìµœì‹  WATCH/SMALL_BET 1ê°œ íƒìƒ‰
          for (let r = hbValues.length - 1; r >= 1; r--) {
            const row = hbValues[r];
            const st = String(row[idxStatus] || "").trim();
            if (st === "WATCH" || st === "SMALL_BET") {
              const hyp = String(row[idxHypothesis] || "").trim();
              const exp = String(row[idxExposure] || "").trim();
              const fals = String(row[idxFalsifiers] || "").trim();

              if (hyp) {
                const falsLines = fals
                  ? fals.split(/\r?\n/).map(s => String(s || "").trim()).filter(s => s)
                  : [];
                const f1 = falsLines[0] || "";
                const f2 = falsLines[1] || "";
                const f3 = falsLines[2] || "";

                // 5ì¤„ ê³ ì • ë¸”ë¡
                const refBlock = [
                  "",
                  "[REFERENCE_CONTEXT]",
                  `- Hypothesis: ${hyp}`,
                  `- Exposure: ${exp || "(none)"}`,
                  `- Falsifier: ${f1 || "(none)"}`,
                  `- Falsifier: ${f2 || "(none)"}`,
                  `- Falsifier: ${f3 || "(none)"}`
                ].join("\n");
promptForGemini = String(promptForGemini || "") + refBlock;
              }
              break;
            }
          }
        }
      }
    }
  } catch (e) {
    // ì‹¤íŒ¨ ì‹œ ì•„ë¬´ ê²ƒë„ ë§ë¶™ì´ì§€ ì•ŠìŒ (ê¸°ì¡´ëŒ€ë¡œ)
    promptForGemini = prompt;
  }

  const advice = callGemini(promptForGemini, config.MODEL_NAME);

// 4. ê²°ê³¼ ì €ì¥ (Portfolio_Meeting ì‹œíŠ¸)
  let pmSheet = ss.getSheetByName("Portfolio_Meeting");
  if (!pmSheet) {
    pmSheet = ss.insertSheet("Portfolio_Meeting");
    pmSheet.getRange("A1").setValue("Last Updated");
    pmSheet.getRange("B1").setValue("Report Body");
  }

  const timestamp = new Date().toLocaleString();
  pmSheet.getRange("A2").setValue(timestamp);
  pmSheet.getRange("B2").setValue(advice); 

  // 5. ê²°ê³¼ UI ì¶œë ¥
  showFullPortfolioDialog(advice, summary, safetyRatio, regime);
}

// ğŸ”µ [UI] Full Portfolio Fit ëŒ€ì‹œë³´ë“œ UI ì¶œë ¥
function showFullPortfolioDialog(advice, summary, safetyRatio, regime) {
  const sections = parseFullPortfolioReport(advice);
  const template = HtmlService.createTemplateFromFile('FullPortfolioReport');
  
  template.sections = sections;
  template.summary = summary;
  template.safetyRatio = safetyRatio;
  template.regime = regime;
  template.date = new Date().toLocaleDateString();

  const html = template.evaluate()
      .setWidth(1200)
      .setHeight(900);
  
  SpreadsheetApp.getUi().showModalDialog(html, 'ğŸ“Š í¬íŠ¸í´ë¦¬ì˜¤ ì „ì²´ ì „ëµ ë³´ê³ ì„œ');
}

// Helper: Bias Score
function calculateBiasScore(ticker, techData, finData, brokerageAssetsUSD, cashWeight) {
  const config = getConfig();
  let score = 0;
  const pointsPerFactor = 20;

  const rsi = parseFloat(techData.rsi);
  if (!isNaN(rsi)) {
    if (rsi < 30) score += pointsPerFactor;
    else if (rsi < 40) score += pointsPerFactor / 2;
    else if (rsi > 70) score -= pointsPerFactor;
    else if (rsi > 60) score -= pointsPerFactor / 2;
  }

  const sma200 = parseFloat(techData.sma200);
  const currentPrice = parseFloat(finData.currentPrice);
  if (!isNaN(sma200) && !isNaN(currentPrice) && sma200 > 0) {
    const diff = (currentPrice - sma200) / sma200;
    if (diff > 0.05) score += pointsPerFactor;
    else if (diff < -0.05) score -= pointsPerFactor;
    else if (diff > 0) score += pointsPerFactor / 2;
    else if (diff < 0) score -= pointsPerFactor / 2;
  }

  const macd = parseFloat(techData.macd);
  if (!isNaN(macd)) {
    if (macd > 0) score += pointsPerFactor;
    else score -= pointsPerFactor;
  }

  const earningsYieldText = finData.earningsYield || "N/A";
  if (earningsYieldText !== "N/A") {
    const ey = parseFloat(earningsYieldText.replace('%', '')) / 100;
    const rf = config.RISK_FREE_RATE;
    if (ey > rf + 0.01) score += 10;
    else if (ey < rf - 0.01) score -= 10;
  }

  const pe = parseFloat(finData.per);
  if (pe > 50) score -= 10;
  else if (pe < 15) score += 10;

  if (brokerageAssetsUSD * config.CASH_WEIGHT_MIN > 0) {
    score += pointsPerFactor / 2;
  } else if (cashWeight < config.CASH_WEIGHT_MIN && cashWeight > 0) {
    score -= pointsPerFactor / 4;
  } else if (cashWeight === 0) {
    score -= pointsPerFactor;
  } else {
    score += pointsPerFactor;
  }

  const totalScore = Math.min(Math.max(score, -100), 100);
  let grade, buyRatio, sellRatio;

  if (totalScore >= 40) { grade = "A"; buyRatio = 70; sellRatio = 30; } 
  else if (totalScore >= 15) { grade = "B"; buyRatio = 60; sellRatio = 40; } 
  else if (totalScore >= -14) { grade = "C"; buyRatio = 50; sellRatio = 50; } 
  else if (totalScore >= -39) { grade = "D"; buyRatio = 40; sellRatio = 60; } 
  else { grade = "E"; buyRatio = 30; sellRatio = 70; }

  return { grade, buyRatio, sellRatio, totalScore };
}

// Helper: Safety Core Text Sanitizer
function sanitizeSafetyCoreText(text, safetyRatio, minLimit, tier) {
  const safetyPct = (safetyRatio * 100).toFixed(1) + "%";

  if (text.includes("1.0%") || text.includes("1%")) {
    if (safetyRatio >= minLimit) {
      text = text.replace(/Safety Core.*1.0%.*Critical/gi, `Safety CoreëŠ” ${safetyPct}ë¡œ ì•ˆì •ì ì´ë©°`);
      text = text.replace(/Safety Core.*1%.*Critical/gi, `Safety CoreëŠ” ${safetyPct}ë¡œ ì•ˆì •ì ì´ë©°`);
      text = text.replace(/1.0%/g, safetyPct);
    }
  }

  if (tier === "Normal") {
    text = text.replace(/Risk Tier.*Critical/gi, "Risk TierëŠ” Normal ìˆ˜ì¤€");
    text = text.replace(/Critical Risk Tier/gi, "Normal Risk Tier");
  }

  return text;
}

// ğŸ”µ Helper Functions for Normalization
function normalizeNumber(val, defaultVal) {
  if (val === null || val === undefined || val === "") return defaultVal;
  if (typeof val === 'number') return isNaN(val) ? defaultVal : val;

  let s = String(val).replace(/,/g, '').trim();
  let n = parseFloat(s);
  return isNaN(n) ? defaultVal : n;
}

function normalizePercentRatio(val, defaultVal) {
  let s = String(val).replace(/%/g, '').replace(/,/g, '').trim();
  let n = parseFloat(s);

  if (isNaN(n)) return defaultVal;
  if (n > 1) return n / 100;
  return n;
}

// ğŸ”µ Daily Portfolio Summary ìƒì„± í•¨ìˆ˜
function buildDailyPortfolioSummary() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getActiveSheet();
  const config = getConfig();

  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return;

  let rows = [];
  let totalStockValueUSD = 0;

  for (let r = 2; r <= lastRow; r++) {
    const ticker = sheet.getRange(r, 1).getValue();
    if (!ticker) continue;

    const qty = parseFloat(sheet.getRange(r, 2).getValue() || 0);
    const curPrice = parseFloat(sheet.getRange(r, 4).getValue() || 0);
    const adviceText = sheet.getRange(r, 8).getValue();

    if (!curPrice || isNaN(curPrice) || curPrice <= 0) continue;

    const tgtWeightRaw = sheet.getRange(r, 6).getValue() || 0;
    let tgtWeightPct = normalizePercentRatio(tgtWeightRaw, 0) * 100;

    if (!tgtWeightPct || tgtWeightPct <= 0) {
      const autoTgt = parseTargetWeightFromAdvice(adviceText || "");
      if (autoTgt > 0) {
        tgtWeightPct = autoTgt;
        sheet.getRange(r, 6).setValue(tgtWeightPct);
      }
    }

    const stockValue = qty * curPrice;
    totalStockValueUSD += stockValue;

    rows.push({ row: r, ticker, qty, curPrice, stockValue, tgtWeight: tgtWeightPct, adviceText });
  }

  if (rows.length === 0) return;

  const pSheet = ensurePortfolioSheet();
  let safetyRatio = normalizePercentRatio(pSheet.getRange("C7").getValue(), config.SAFETY_CORE_MIN);
  let riskTier = (safetyRatio < config.SAFETY_CORE_MIN) ? "Critical" : "Normal";

  let sumSheet = ss.getSheetByName("Daily_Portfolio_Summary");
  if (!sumSheet) {
    sumSheet = ss.insertSheet("Daily_Portfolio_Summary");
    sumSheet.getRange(1, 1, 1, 9).setValues([[
      "ì¢…ëª©", "í˜„ì¬ë¹„ì¤‘(%)", "ëª©í‘œë¹„ì¤‘(%)", "íŒë‹¨", "ë“±ê¸‰", "ë³€ë™ì„±(%)", "MDD(%)", "ë¦¬ìŠ¤í¬í‹°ì–´", "í›„ë³´ìœ í˜•"
    ]]).setFontWeight("bold");
    sumSheet.setColumnWidth(2, 120);
    sumSheet.setColumnWidth(3, 120);
  } else {
    const lr = sumSheet.getLastRow();
    if (lr > 1) {
      sumSheet.getRange(2, 1, lr - 1, 9).clearContent();
    }
  }

  let output = [];

  for (let i = 0; i < rows.length; i++) {
    const d = rows[i];
    const curWeight = totalStockValueUSD > 0 ? (d.stockValue / totalStockValueUSD) * 100 : 0;
    const curWeightPct = parseFloat(curWeight.toFixed(1));

    const parsed = parseDecisionAndBias(d.adviceText);
    const aiDecision = parsed.decision;
    const aiBias = parsed.bias;

    const riskMetrics = calculateRealRiskMetrics(d.ticker);
    const vol = String(riskMetrics.vol || "N/A").replace(/%/g, '').trim();
    const mdd = String(riskMetrics.mdd || "N/A").replace(/%/g, '').trim();

    const tgt = d.tgtWeight;

    const buyDecisions = ["ê°•ë ¥ë§¤ìˆ˜", "ë¶„í• ë§¤ìˆ˜", "ë¹„ì¤‘í™•ëŒ€", "ì§„ì…"];
    const sellDecisions = ["ì „ëŸ‰ë§¤ë„", "ë¹„ì¤‘ì¶•ì†Œ"];
    const watchDecisions = ["ê´€ë§", "ë³´ìœ ", "ì¤‘ë¦½"];
    const biasBuy = ["A", "B"];
    const biasSell = ["D", "E"];

    const isBuyCandidate =
      buyDecisions.includes(aiDecision) &&
      biasBuy.includes(aiBias) &&
      curWeight < tgt &&
      riskTier !== "Critical";

    const isSellCandidate =
      !isBuyCandidate && (
        sellDecisions.includes(aiDecision) ||
        (biasSell.includes(aiBias) && curWeight > tgt) ||
        (riskTier === "Critical" && aiBias !== "A")
      );

    let candidateType = "Watchlist";
    if (isBuyCandidate) candidateType = "Buy";
    else if (isSellCandidate) candidateType = "Sell";
    else if (watchDecisions.includes(aiDecision)) candidateType = "Watchlist";

    output.push([
      d.ticker,
      curWeightPct,
      tgt,
      aiDecision,
      aiBias,
      vol,
      mdd,
      riskTier,
      candidateType
    ]);
  }

  if (output.length > 0) {
    sumSheet.getRange(2, 1, output.length, 9).setValues(output);
    sumSheet.getRange(2, 2, output.length, 2).setNumberFormat("0.0");
  }
}

// ğŸ”µ ìŠ¤ìºë„ˆ ê²€ì¦ ì‹¤í–‰ìš© í•¨ìˆ˜
// ==============================
// Regime (Plan lock/unlock trigger)
// ==============================

function computeRegimeFromPythonData_(ticker) {
  // Regime = STABLE / VOLATILE / BROKEN
  // - STABLE: ìœ„í—˜/ë³€ë™ì´ ë‚®ê³ (í•˜ë°©Â·í¬ë˜ì‹œ ë¹ˆë„Â·íšŒë³µ), ì¶”ì„¸/í¬ë¼ìš°ë“œê°€ ê³¼ì—´ì´ ì•„ë‹Œ êµ¬ê°„
  // - VOLATILE: ê¸°ë³¸ê°’(ì• ë§¤/í˜¼ì¡°/ì¤‘ê°„ ìœ„í—˜)
  // - BROKEN: ë°ì´í„° í’ˆì§ˆ ë¬¸ì œ ë˜ëŠ” êµ¬ì¡°ì  ìŠ¤íŠ¸ë ˆìŠ¤(ê¸‰ê²©í•œ í•˜ë°©/í¬ë˜ì‹œ/íšŒë³µ ì•…í™”)ë¡œ í”Œëœ ê°±ì‹  íŠ¸ë¦¬ê±° í›„ë³´

  try {
    var flowObj = getPythonRowByTicker_("Flow_Score", ticker);
    var failObj = getPythonRowByTicker_("Failure_Cost", ticker);
    var exitObj = getPythonRowByTicker_("Exit_Risk_Speed", ticker);

    // 1) Data quality fail => BROKEN (ìµœìš°ì„ )
    var dq = null;
    if (flowObj && flowObj["DataQualityFlag"] !== undefined && flowObj["DataQualityFlag"] !== null && flowObj["DataQualityFlag"] !== "") dq = String(flowObj["DataQualityFlag"]).toUpperCase();
    if (!dq && failObj && failObj["DataQualityFlag"] !== undefined && failObj["DataQualityFlag"] !== null && failObj["DataQualityFlag"] !== "") dq = String(failObj["DataQualityFlag"]).toUpperCase();
    if (!dq && exitObj && exitObj["DataQualityFlag"] !== undefined && exitObj["DataQualityFlag"] !== null && exitObj["DataQualityFlag"] !== "") dq = String(exitObj["DataQualityFlag"]).toUpperCase();

    // DataQualityFlagê°€ ì¡´ì¬í•˜ê³ , ëª…ë°±íˆ BAD/LOW/NONE ê³„ì—´ì´ë©´ BROKEN
    if (dq && (dq.indexOf("BAD") >= 0 || dq.indexOf("LOW") >= 0 || dq.indexOf("NONE") >= 0 || dq.indexOf("ERR") >= 0)) {
      return "BROKEN";
    }

    // Flow_Score: CrowdScore ê¸°ë°˜
    // - CrowdScore(0-1) ì œê³µì´ë©´ *100 í•´ì„œ 0~100 ìŠ¤ì¼€ì¼ë¡œ ë³€í™˜
    // - CrowdScore(0-100) ì œê³µì´ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©(0~100)
    // - (fallback) Flow_Score ì»¬ëŸ¼ì´ ìˆìœ¼ë©´ ì‚¬ìš©
    var crowd01 = (flowObj && flowObj["CrowdScore(0-1)"] !== undefined) ? parseFloat(flowObj["CrowdScore(0-1)"]) : NaN;
    var crowd100 = (flowObj && flowObj["CrowdScore(0-100)"] !== undefined) ? parseFloat(flowObj["CrowdScore(0-100)"]) : NaN;
    if (isNaN(crowd100) && flowObj && flowObj["CrowdScore"] !== undefined) crowd100 = parseFloat(flowObj["CrowdScore"]);
    if (isNaN(crowd100) && flowObj && flowObj["Flow_Score"] !== undefined) crowd100 = parseFloat(flowObj["Flow_Score"]);
    var trendStrength = (flowObj && flowObj["TrendStrength"] !== undefined) ? parseFloat(flowObj["TrendStrength"]) : NaN;

    var flowScore = NaN;
    if (!isNaN(crowd01)) {
      flowScore = crowd01 * 100.0;
    } else if (!isNaN(crowd100)) {
      flowScore = crowd100;
    }

    // Failure_Cost: FailureCostScor / FailureCostScore
    var failureCost = NaN;
    if (failObj) {
      if (failObj["FailureCostScor"] !== undefined) failureCost = parseFloat(failObj["FailureCostScor"]);
      else if (failObj["FailureCostScore"] !== undefined) failureCost = parseFloat(failObj["FailureCostScore"]);
    }

    // Exit_Risk_Speed: ExitSpeedScore(0-100)
    var exitSpeed = (exitObj && exitObj["ExitSpeedScore(0-100)"] !== undefined) ? parseFloat(exitObj["ExitSpeedScore(0-100)"]) : NaN;

    // Downside / crash metrics (Failure_Cost ì‹œíŠ¸ì— ì¡´ì¬í•˜ëŠ” ê²½ìš°)
    var mdd = (failObj && failObj["MDD"] !== undefined) ? parseFloat(failObj["MDD"]) : NaN;
    var crash7 = (failObj && failObj["CrashFreq(-7%)"] !== undefined) ? parseFloat(failObj["CrashFreq(-7%)"]) : NaN;
    var crash10 = (failObj && failObj["CrashFreq(-10%)"] !== undefined) ? parseFloat(failObj["CrashFreq(-10%)"]) : NaN;
    var recoveryDays = (failObj && failObj["RecoveryDaysP"] !== undefined) ? parseFloat(failObj["RecoveryDaysP"]) : NaN;

    // =========================
    // Regime rules (ìµœì†Œ 3ê°€ì§€)
    // =========================

    // Rule A) BROKEN: ì‹¬ê°í•œ í•˜ë°©/í¬ë˜ì‹œ/íšŒë³µ ë¬¸ì œ ë˜ëŠ” ì ìˆ˜ ê¸‰ê²© ì•…í™”
    // - MDDê°€ í° í­(<= -0.45) ì´ê±°ë‚˜, í¬ë˜ì‹œ ë¹ˆë„ê°€ ë†’ê±°ë‚˜, íšŒë³µì¼ìˆ˜ê°€ ê³¼ë„í•˜ê±°ë‚˜, ì‹¤íŒ¨ë¹„ìš©/íƒˆì¶œì†ë„ê°€ ë§¤ìš° ë†’ìœ¼ë©´ BROKEN
    if (
      (!isNaN(mdd) && mdd <= -0.45) ||
      (!isNaN(crash7) && crash7 >= 60) ||
      (!isNaN(crash10) && crash10 >= 40) ||
      (!isNaN(recoveryDays) && recoveryDays >= 200) ||
      (!isNaN(failureCost) && failureCost >= 90) ||
      (!isNaN(exitSpeed) && exitSpeed >= 90)
    ) {
      return "BROKEN";
    }

    // Rule B) STABLE: ìœ„í—˜ ë‚®ìŒ + ê³¼ì—´ ì•„ë‹˜(ì¶”ì„¸ ê°•ë„ ë‚®ê±°ë‚˜ ì¤‘ë¦½) + íƒˆì¶œì†ë„ ë‚®ìŒ
    // - FailureCost <= 55, ExitSpeed <= 55, MDD > -0.30, CrashFreq ë‚®ìŒ, íšŒë³µì¼ìˆ˜ ë¬´ë‚œ
    if (
      (!isNaN(failureCost) && failureCost <= 55) &&
      (!isNaN(exitSpeed) && exitSpeed <= 55) &&
      (isNaN(mdd) || mdd > -0.30) &&
      (isNaN(crash7) || crash7 <= 25) &&
      (isNaN(crash10) || crash10 <= 12) &&
      (isNaN(recoveryDays) || recoveryDays <= 120) &&
      (isNaN(trendStrength) || trendStrength < 60)
    ) {
      return "STABLE";
    }

    // Rule C) VOLATILE: ê¸°ë³¸ê°’(ê·¸ ì™¸)
    return "VOLATILE";
  } catch (e) {
    Logger.log("computeRegimeFromPythonData_ error: " + e);
    // ê³„ì‚° ì‹¤íŒ¨ëŠ” ì•ˆì „í•˜ê²Œ BROKENìœ¼ë¡œ ê°„ì£¼(í”Œëœ ì—…ë°ì´íŠ¸ê°€ í•„ìš”í•œ ìƒíƒœ)
    return "BROKEN";
  }
}

function getPythonRowByTicker_(sheetName, tickerUpper) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sh = ss.getSheetByName(sheetName);
  if (!sh) {
    // Fallback: tolerate accidental trailing spaces / case differences in sheet name
    const targetNorm = String(sheetName || "").toLowerCase().replace(/\s+/g, "");
    const allSheets = ss.getSheets();
    for (var i = 0; i < allSheets.length; i++) {
      const nm = allSheets[i].getName();
      const nmNorm = String(nm || "").toLowerCase().replace(/\s+/g, "");
      if (nmNorm === targetNorm) { sh = allSheets[i]; break; }
    }
  }
  if (!sh) return null;

  const values = sh.getDataRange().getValues();
  if (!values || values.length < 2) return null;

  const headers = values[0].map(h => (h || "").toString().trim());
  const tickerIdx = headers.findIndex(h => h.toUpperCase() === "TICKER");
  if (tickerIdx < 0) return null;

  for (let r = 1; r < values.length; r++) {
    const row = values[r];
    const t = (row[tickerIdx] || "").toString().trim().toUpperCase();
    if (t === tickerUpper) {
      const obj = {};
      for (let c = 0; c < headers.length; c++) obj[headers[c]] = row[c];
      // Normalize common metric column names (Python output sheet headers vary)
      if (sheetName === "Flow_Score" && (obj["Flow_Score"] === undefined || obj["Flow_Score"] === "")) {
        if (obj["CrowdScore(0-100)"] !== undefined) obj["Flow_Score"] = obj["CrowdScore(0-100)"];
        else if (obj["CrowdScore"] !== undefined) obj["Flow_Score"] = obj["CrowdScore"];
      }
      if (sheetName === "Failure_Cost" && (obj["Failure_Cost"] === undefined || obj["Failure_Cost"] === "")) {
        if (obj["FailureCostScore"] !== undefined) obj["Failure_Cost"] = obj["FailureCostScore"];
      }
      return obj;
    }
  }
  return null;
}

function toNumberOrNull_(v) {
  if (v === null || v === undefined || v === "") return null;
  const n = Number(v);
  if (isNaN(n)) return null;
  return n;
}

function runRegimeUpdateTriggerForSelectedRow() {
  var marketRegimeStr = "";
  // Plan_Snapshotì—ì„œ ì„ íƒëœ í–‰ì˜ Lock ìƒíƒœì™€ í˜„ì¬ ë°ì´í„°ë¥¼ ë¹„êµí•´ ì—…ë°ì´íŠ¸ íŠ¸ë¦¬ê±°ë¥¼ ì²´í¬í•œë‹¤.
  // íŠ¸ë¦¬ê±° ê·œì¹™(ìµœì†Œ 3ê°€ì§€):
  // 1) REGIME_CHANGE: Regime_At_Lock != current Regime
  // 2) FLOW_SCORE_SPIKE: |FlowScore_At_Lock - current Flow_Score| >= 15
  // 3) FAILURE_COST_SPIKE: |FailureCost_At_Lock - current Failure_Cost| >= 15
  // 4) EXIT_SPEED_SHIFT: |ExitSpeed_At_Lock - current Exit_Risk_Speed| >= 15
  // íŠ¸ë¦¬ê±° ë°œìƒ ì‹œ LockReason ì»¬ëŸ¼ì— ì‚¬ìœ ë¥¼ ê¸°ë¡(ì¡´ì¬í•˜ëŠ” ê²½ìš°).

  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var sheet = ss.getActiveSheet();
  var planSheet = ss.getSheetByName("Plan_Snapshot");
  if (!planSheet) {
    SpreadsheetApp.getUi().alert("Plan_Snapshot ì‹œíŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    return;
  }

  var row = null;

  if (sheet.getName() === "Plan_Snapshot") {
    row = sheet.getActiveRange().getRow();
  } else {
    // Final_Report(ë˜ëŠ” ë‹¤ë¥¸ ì‹œíŠ¸)ì—ì„œ ì‹¤í–‰í•œ ê²½ìš°: ì„ íƒ í–‰ì˜ Tickerë¡œ Plan_Snapshot ìµœì‹  í–‰ì„ ì°¾ëŠ”ë‹¤
    var activeRange = sheet.getActiveRange();
    if (!activeRange) {
      SpreadsheetApp.getUi().alert("ì„ íƒëœ í–‰ì´ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    var activeRow = activeRange.getRow();
    var activeLastCol = sheet.getLastColumn();
    var activeHeaders = sheet.getRange(1, 1, 1, activeLastCol).getValues()[0];
    var activeRowVals = sheet.getRange(activeRow, 1, 1, activeLastCol).getValues()[0];

    var tickerColIdx = -1;
    for (var c = 0; c < activeHeaders.length; c++) {
      if (String(activeHeaders[c]).trim() === "Ticker" || String(activeHeaders[c]).trim() === "ì¢…ëª©") {
        tickerColIdx = c;
        break;
      }
    }

    if (tickerColIdx < 0) {
      SpreadsheetApp.getUi().alert("í˜„ì¬ ì‹œíŠ¸ì—ì„œ Ticker(ì¢…ëª©) ì»¬ëŸ¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    var ticker = String(activeRowVals[tickerColIdx] || "").trim();
    if (!ticker) {
      SpreadsheetApp.getUi().alert("ì„ íƒ í–‰ì—ì„œ Ticker ê°’ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
      return;
    }

    // Plan_Snapshotì—ì„œ í•´ë‹¹ Tickerì˜ ìµœì‹  í–‰ íƒìƒ‰
    var psLastRow = planSheet.getLastRow();
    if (psLastRow < 2) {
      SpreadsheetApp.getUi().alert("Plan_Snapshotì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ğŸ”’ í”Œëœ ìŠ¤ëƒ…ìƒ· ë½ì„ ì‹¤í–‰í•˜ì„¸ìš”.");
      return;
    }

    var psLastCol = planSheet.getLastColumn();
    var psHeaders = planSheet.getRange(1, 1, 1, psLastCol).getValues()[0];

    var psTickerCol = -1;
    for (var pc = 0; pc < psHeaders.length; pc++) {
      if (String(psHeaders[pc]).trim() === "Ticker") {
        psTickerCol = pc + 1; // 1-based
        break;
      }
    }
    if (psTickerCol < 0) {
      SpreadsheetApp.getUi().alert("Plan_Snapshotì—ì„œ Ticker ì»¬ëŸ¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    var psTickers = planSheet.getRange(2, psTickerCol, psLastRow - 1, 1).getValues();
    var foundRow = null;
    for (var i = psTickers.length - 1; i >= 0; i--) {
      if (String(psTickers[i][0]).trim() === ticker) {
        foundRow = i + 2; // data offset
        break;
      }
    }

    if (!foundRow) {
      SpreadsheetApp.getUi().alert("Plan_Snapshotì—ì„œ ì„ íƒí•œ Ticker(" + ticker + ")ì˜ ìŠ¤ëƒ…ìƒ·ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë¨¼ì € ğŸ”’ í”Œëœ ìŠ¤ëƒ…ìƒ· ë½ì„ ì‹¤í–‰í•˜ì„¸ìš”.");
      return;
    }

    sheet = planSheet;
    row = foundRow;
  }

  if (row <= 1) {
    SpreadsheetApp.getUi().alert("í—¤ë” í–‰ì€ ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    return;
  }

  var lastCol = sheet.getLastColumn();
  var headers = sheet.getRange(1, 1, 1, lastCol).getValues()[0];

  function findIdx(candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var key = candidates[i];
      var idx = headers.indexOf(key);
      if (idx !== -1) return idx;
    }
    return -1;
  }

  var idxTicker = findIdx(["Ticker"]);
  var idxRegimeLock = findIdx(["Regime_At_Lock", "Regime At Lock", "Regime"]);
  var idxFlowLock = findIdx(["FlowScore_At_Lock", "Flow_Score_At_Lock", "FlowScore At Lock"]);
  var idxFailLock = findIdx(["FailureCost_At_Lock", "Failure_Cost_At_Lock", "FailureCost At Lock"]);
  var idxExitLock = findIdx(["ExitSpeed_At_Lock", "ExitSpeedScore_At_Lock", "ExitSpeed At Lock", "ExitSpeed_At_Lock "]);
  var idxLockReason = findIdx(["LockReason", "LOCKREASON", "LOCK_REASON"]);
  var idxLockFlag = findIdx(["LockFlag", "LOCKED", "IsLocked", "Locked"]);

  if (idxTicker === -1) {
    SpreadsheetApp.getUi().alert("Plan_Snapshotì— Ticker ì»¬ëŸ¼ì´ ì—†ìŠµë‹ˆë‹¤.");
    return;
  }

  var rowValues = sheet.getRange(row, 1, 1, lastCol).getValues()[0];
  var ticker = String(rowValues[idxTicker] || "").trim();
  // PriceNow (optional) - Plan_Snapshot may not have it; avoid referencing undefined header arrays
  var curPrice = '';
  var idxPriceNow = headers.indexOf('PriceNow');
  if (idxPriceNow < 0) idxPriceNow = headers.indexOf('Price Now');
  if (idxPriceNow >= 0) curPrice = rowValues[idxPriceNow];
  if (!ticker) {
    SpreadsheetApp.getUi().alert("Tickerê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.");
    return;
  }

  // í˜„ì¬ ë°ì´í„°ë¡œë¶€í„° Regime/ì ìˆ˜ ê³„ì‚°
  var currentRegime = computeRegimeFromPythonData_(ticker);

  // í˜„ì¬ Flow_Score (0~100 ìŠ¤ì¼€ì¼)
  // - CrowdScore(0-1) ì œê³µì´ë©´ *100
  // - CrowdScore(0-100) ì œê³µì´ë©´ ê·¸ëŒ€ë¡œ
  // - (fallback) Flow_Score ì»¬ëŸ¼
  var flowObj = getPythonRowByTicker_("Flow_Score", ticker);
  var crowd01 = (flowObj && flowObj["CrowdScore(0-1)"] !== undefined) ? parseFloat(flowObj["CrowdScore(0-1)"]) : NaN;
  var crowd100 = (flowObj && flowObj["CrowdScore(0-100)"] !== undefined) ? parseFloat(flowObj["CrowdScore(0-100)"]) : NaN;
  if (isNaN(crowd100) && flowObj && flowObj["CrowdScore"] !== undefined) crowd100 = parseFloat(flowObj["CrowdScore"]);
  if (isNaN(crowd100) && flowObj && flowObj["Flow_Score"] !== undefined) crowd100 = parseFloat(flowObj["Flow_Score"]);

  var currentFlow = NaN;
  if (!isNaN(crowd01)) {
    currentFlow = crowd01 * 100.0;
  } else if (!isNaN(crowd100)) {
    currentFlow = crowd100;
  }

  // í˜„ì¬ Failure_Cost
  var failObj = getPythonRowByTicker_("Failure_Cost", ticker);
  var currentFail = NaN;
  if (failObj) {
    // í—¤ë” ì˜¤íƒˆì/ê³µë°± ë“± ëŒ€ë¹„: keyë¥¼ normalize í•´ì„œ ë§¤ì¹­
    var failKeys = Object.keys(failObj);
    for (var fk = 0; fk < failKeys.length; fk++) {
      var rawKey = failKeys[fk];
      var normKey = String(rawKey).replace(/\s+/g, "").replace(/_/g, "").toLowerCase();
      if (normKey.indexOf('failurecostscore') !== -1 || normKey === 'failurecost') {
        currentFail = parseFloat(failObj[rawKey]);
        break;
      }
    }
  }

  // í˜„ì¬ Exit_Risk_Speed
  var exitObj = getPythonRowByTicker_("Exit_Risk_Speed", ticker);
  var currentExit = (exitObj && exitObj["ExitSpeedScore(0-100)"] !== undefined) ? parseFloat(exitObj["ExitSpeedScore(0-100)"]) : NaN;

  var reasons = [];
  var THRESHOLD = 15;

  // 1) Regime change
  if (idxRegimeLock !== -1) {
    var lockedRegime = String(rowValues[idxRegimeLock] || "").trim();
    if (lockedRegime && lockedRegime !== currentRegime) {
      reasons.push("REGIME_CHANGE(" + lockedRegime + "â†’" + currentRegime + ")");
    }
  }

  // 2) Flow spike
  if (idxFlowLock !== -1 && !isNaN(currentFlow)) {
    var lockedFlow = parseFloat(rowValues[idxFlowLock]);
    if (!isNaN(lockedFlow) && Math.abs(currentFlow - lockedFlow) >= THRESHOLD) {
      reasons.push("FLOW_SCORE_SPIKE(" + lockedFlow + "â†’" + currentFlow.toFixed(1) + ")");
    }
  }

  // 3) Failure cost spike
  if (idxFailLock !== -1 && !isNaN(currentFail)) {
    var lockedFail = parseFloat(rowValues[idxFailLock]);
    if (!isNaN(lockedFail) && Math.abs(currentFail - lockedFail) >= THRESHOLD) {
      reasons.push("FAILURE_COST_SPIKE(" + lockedFail + "â†’" + currentFail.toFixed(1) + ")");
    }
  }

  // 4) Exit speed shift
  if (idxExitLock !== -1 && !isNaN(currentExit)) {
    var lockedExit = parseFloat(rowValues[idxExitLock]);
    if (!isNaN(lockedExit) && Math.abs(currentExit - lockedExit) >= THRESHOLD) {
      reasons.push("EXIT_SPEED_SHIFT(" + lockedExit + "â†’" + currentExit.toFixed(1) + ")");
    }
  }

  if (reasons.length === 0) {
    SpreadsheetApp.getUi().alert("íŠ¸ë¦¬ê±° ì—†ìŒ: í˜„ì¬ Regime=" + currentRegime);
    return;
  }

  // LockReason ê¸°ë¡(ì¡´ì¬í•˜ëŠ” ê²½ìš°)
  if (idxLockReason !== -1) {
    var prev = String(rowValues[idxLockReason] || "").trim();
    var next = reasons.join(" | ");
    sheet.getRange(row, idxLockReason + 1).setValue(prev ? (prev + " | " + next) : next);
  }

  // LockFlagê°€ ìˆë‹¤ë©´ TRUEë¡œ ìœ ì§€(ì—†ìœ¼ë©´ ë¬´ì‹œ)
  if (idxLockFlag !== -1) {
    var v = rowValues[idxLockFlag];
    if (v === "" || v === null || v === undefined) {
      sheet.getRange(row, idxLockFlag + 1).setValue(true);
    }
  }

  // ===== Action Table (Minimal) =====
// ëª©ì : íŠ¸ë¦¬ê±°(Î”) + í˜„ì¬ Regimeì— ë”°ë¼ "ë¬´ì—‡ì„ ì‹¤í–‰í• ì§€"ë¥¼ ê³ ì •í•œë‹¤.
// - KEEP_LOCK: í”Œëœ ìœ ì§€(ë½ ìœ ì§€) + ë¡œê·¸ë§Œ ë‚¨ê¹€
// - RECALC_E14: E14(Entry/Stop Bands) ì¬ê³„ì‚°ì„ ìœ„í•´ Final_Report ì¬ì‹¤í–‰
// - MARK_BROKEN: í”Œëœ ë¬´íš¨(ì¬ë½ ìš”êµ¬) ì²˜ë¦¬
// - NO_ACTION: ì•„ë¬´ ê²ƒë„ í•˜ì§€ ì•ŠìŒ
var ACTION_NO = "NO_ACTION";
var ACTION_KEEP = "KEEP_LOCK";
var ACTION_RECALC = "RECALC_E14";
var ACTION_BROKEN = "MARK_BROKEN";

var action = ACTION_NO;

// 1) Regimeì´ ì´ë¯¸ BROKENì´ë©´ ì¦‰ì‹œ í”Œëœ ë¬´íš¨ ì²˜ë¦¬(ì¬ë½ ìš”êµ¬)
if (String(currentRegime || "").toUpperCase() === "BROKEN") {
  action = ACTION_BROKEN;
} else {
  // 2) íŠ¸ë¦¬ê±° ê°•ë„ íŒë‹¨: 2ê°œ ì´ìƒ ë™ì‹œ ë°œìƒ(ë³µí•©) â†’ BROKEN ìŠ¹ê²©
  var triggerCount = Array.isArray(reasons) ? reasons.length : 0;
  if (triggerCount >= 2) {
    action = ACTION_BROKEN;
  } else if (triggerCount === 1) {
    // 3) ë‹¨ì¼ íŠ¸ë¦¬ê±°ì¼ ë•Œ Regimeë³„ ìµœì†Œ ëŒ€ì‘
    // - VOLATILE: Flow/FailureëŠ” E14 ì¬ê³„ì‚°(ë°´ë“œ ì¬ì í•©)ì´ ìœ ë¦¬
    // - STABLE: ExitSpeed ì •ë„ëŠ” í”Œëœ ìœ ì§€(ë½ ìœ ì§€)
    var r0 = String(reasons[0] || "");
    var cur = String(currentRegime || "").toUpperCase();
    if (cur === "VOLATILE") {
      if (r0.indexOf("FLOW_SCORE_SPIKE") >= 0 || r0.indexOf("FAILURE_COST_SPIKE") >= 0) {
        action = ACTION_RECALC;
      } else {
        action = ACTION_KEEP;
      }
    } else {
      // STABLE/ê¸°íƒ€: ê¸°ë³¸ì€ í”Œëœ ìœ ì§€
      action = ACTION_KEEP;
    }
  } else {
    action = ACTION_NO;
  }
}

// Plan_Snapshot ì—…ë°ì´íŠ¸
// (ê°€ëŠ¥í•œ ê²½ìš°): ë™ì¼ Sheet/Row í‚¤ë¡œ í•´ë‹¹ í–‰ì˜ LockReasonì— Action + Trigger ê¸°ë¡
var planUpdated = false;
try {
  var planSh = ss.getSheetByName(SHEET_PLAN_SNAPSHOT);
  if (planSh) {
    var planHdr = planSh.getRange(1, 1, 1, planSh.getLastColumn()).getValues()[0].map(function(x){ return String(x).trim(); });
    var pIdxSheet = planHdr.indexOf("Sheet");
    var pIdxRow = planHdr.indexOf("Row");
    var pIdxLockReason = planHdr.indexOf("LockReason");
    if (pIdxSheet !== -1 && pIdxRow !== -1 && pIdxLockReason !== -1) {
      var pLast = planSh.getLastRow();
      if (pLast >= 2) {
        var pData = planSh.getRange(2, 1, pLast - 1, planSh.getLastColumn()).getValues();
        for (var pi = 0; pi < pData.length; pi++) {
          var ps = String(pData[pi][pIdxSheet] || "").trim();
          var pr = Number(pData[pi][pIdxRow] || 0);
          if (ps === sheet.getName() && pr === rowNum) {
            var oldLR = String(pData[pi][pIdxLockReason] || "").trim();
            var stamp = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm:ss");
            var lrLine = "ACTION_" + action + " | TRIGGERS=" + reasons.join("|") + " | at " + stamp;
            var newLR = oldLR ? (oldLR + "\n" + lrLine) : lrLine;
            planSh.getRange(pi + 2, pIdxLockReason + 1).setValue(newLR);
            planUpdated = true;
            break;
          }
        }
      }
    }
  }
} catch (e) {
  // Plan_Snapshot ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ëŠ” ì¹˜ëª…ì ì´ì§€ ì•Šìœ¼ë¯€ë¡œ ë¬´ì‹œ(ì•Œë¦¼ì€ ì•„ë˜ì— í¬í•¨)
}

var ui = SpreadsheetApp.getUi();
  var actionExec = "";
  try {
    if (action === ACTION_RECALC) {
      // E14 ì¬ê³„ì‚°ì€ ì—¬ê¸°ì„œ Final_Reportë¥¼ ì¬ìƒì„±í•˜ì§€ ì•ŠëŠ”ë‹¤.
      // Regime ì²´í¬&í”Œëœ ì—…ë°ì´íŠ¸ëŠ” "ì‹¤í–‰ ì§€ì‹œ + íŒë‹¨ ë¡œê·¸"ë§Œ ë‚¨ê¸°ë©°,
      // ì‹¤ì œ ì¬ìƒì„±(ë³´ê³ ì„œ/ê³„ì‚°)ì€ Execution Engine ë˜ëŠ” ìˆ˜ë™ ì•¡ì…˜ì—ì„œ ìˆ˜í–‰í•œë‹¤.
      actionExec = "QUEUED: RECALC_E14 (Final_Report ì¬ìƒì„±ì€ ë³„ë„ ì‹¤í–‰)";
    } else if (action === ACTION_BROKEN) {
      // í”Œëœ ë¬´íš¨ ì²˜ë¦¬(ì¬ë½ ìš”êµ¬) â€” Plan_Snapshotì˜ PlanStatus/LockFlag ê°±ì‹ ì´ í•µì‹¬
      actionExec = "EXECUTED: MARK_BROKEN (PlanStatus=STALE, LockFlag=false)";
    } else if (action === ACTION_KEEP) {
      actionExec = "EXECUTED: KEEP_LOCK";
    } else {
      actionExec = "EXECUTED: NO_ACTION";
    }
  } catch (ex) {
    actionExec = "FAILED: " + ex;
  }


  // [PATCH] Execution_Queue ê¸°ë¡ (Final_Report vs Plan_Snapshot ë¹„êµ ê²°ê³¼ë¥¼ ì‹¤í–‰ ì´ë²¤íŠ¸ë¡œ append-only ê¸°ë¡)
  try {
    var ss0 = SpreadsheetApp.getActiveSpreadsheet();

    var qName0 = "Execution_Queue";
    var qHeaders0 = [
      "Timestamp",
      "SourceSheet",
      "SourceRow",
      "Ticker",
      "Action",
      "Triggers",
      "Regime_Now",
      "Regime_At_Lock",
      "FlowScore_Now",
      "FlowScore_At_Lock",
      "FailureCost_Now",
      "FailureCost_At_Lock",
      "ExitSpeed_Now",
      "ExitSpeed_At_Lock",
      "E14_Source",
      "PlanStatus",
      "LockReason"
    ];

    var qSheet0 = ss0.getSheetByName(qName0);
    if (!qSheet0) {
      qSheet0 = ss0.insertSheet(qName0);
      qSheet0.getRange(1, 1, 1, qHeaders0.length).setValues([qHeaders0]);
    } else {
      // í—¤ë”ê°€ ì—†ê±°ë‚˜ ë‹¤ë¥¸ ê²½ìš°ì—ë„ í¬ë˜ì‹œ ë°©ì§€: ì²« í–‰ì´ ë¹„ì–´ ìˆìœ¼ë©´ ìµœì†Œ í—¤ë” ë³´ì¥
      var qFirstRow0 = qSheet0.getRange(1, 1, 1, Math.max(1, qSheet0.getLastColumn())).getValues()[0];
      var qFirstCell0 = (qFirstRow0 && qFirstRow0.length ? String(qFirstRow0[0] || "").trim() : "");
      if (qFirstCell0 === "") {
        qSheet0.getRange(1, 1, 1, qHeaders0.length).setValues([qHeaders0]);
      }
    }

    var frSheet0 = ss0.getSheetByName("Final_Report");
    var psSheet0 = ss0.getSheetByName("Plan_Snapshot");

    // SourceRow: í˜„ì¬ ì„ íƒ í–‰ì„ ìš°ì„  ì‚¬ìš©í•˜ë˜, ì—†ìœ¼ë©´ ActiveRange ê¸°ë°˜ìœ¼ë¡œ ë°©ì–´
    var activeSheet0 = ss0.getActiveSheet();
    var activeRange0 = (activeSheet0 ? activeSheet0.getActiveRange() : null);
    var srcRow0 = (typeof row !== "undefined" && row ? row : (activeRange0 ? activeRange0.getRow() : 2));
    if (!srcRow0 || srcRow0 < 2) srcRow0 = 2;

    // í—¤ë” ë§¤í•‘(ì†Œë¬¸ì í‚¤)
    var frMap0 = {};
    var psMap0 = {};
    if (frSheet0) {
      var frHeaders0 = frSheet0.getRange(1, 1, 1, Math.max(1, frSheet0.getLastColumn())).getValues()[0];
      for (var i0 = 0; i0 < frHeaders0.length; i0++) {
        var k0 = String(frHeaders0[i0] || "").trim().toLowerCase();
        if (k0 && frMap0[k0] === undefined) frMap0[k0] = i0 + 1;
      }
    }
    if (psSheet0) {
      var psHeaders0 = psSheet0.getRange(1, 1, 1, Math.max(1, psSheet0.getLastColumn())).getValues()[0];
      for (var j0 = 0; j0 < psHeaders0.length; j0++) {
        var k1 = String(psHeaders0[j0] || "").trim().toLowerCase();
        if (k1 && psMap0[k1] === undefined) psMap0[k1] = j0 + 1;
      }
    }

    // ê°’ ì½ê¸° í—¬í¼(í•¨ìˆ˜ ìƒì„± ê¸ˆì§€ â†’ ì¸ë¼ì¸ ë°˜ë³µ)
    var ticker0 = "";
    var regimeNow0 = "";
    var flowNow0 = "";
    var failureNow0 = "";
    var exitNow0 = "";

    if (frSheet0) {
      // Ticker
      var tCol0 = (frMap0["ticker"] || frMap0["symbol"] || frMap0["í‹°ì»¤"] || null);
      if (tCol0) ticker0 = frSheet0.getRange(srcRow0, tCol0).getValue();

      // Regime_Now
      var rCol0 = (frMap0["regime_now"] || frMap0["marketregime"] || frMap0["regime"] || frMap0["market_regime"] || null);
      if (rCol0) regimeNow0 = frSheet0.getRange(srcRow0, rCol0).getValue();

      // FlowScore_Now
      var fCol0 = (frMap0["flowscore_now"] || frMap0["flow_score"] || frMap0["flowscore"] || frMap0["flow"] || null);
      if (fCol0) flowNow0 = frSheet0.getRange(srcRow0, fCol0).getValue();

      // FailureCost_Now
      var fcCol0 = (frMap0["failurecost_now"] || frMap0["failure_cost"] || frMap0["failurecost"] || frMap0["failure"] || null);
      if (fcCol0) failureNow0 = frSheet0.getRange(srcRow0, fcCol0).getValue();

      // ExitSpeed_Now
      var eCol0 = (frMap0["exitspeed_now"] || frMap0["exit_risk_speed"] || frMap0["exitspeed"] || frMap0["exit_speed"] || null);
      if (eCol0) exitNow0 = frSheet0.getRange(srcRow0, eCol0).getValue();
    }

    var regimeLock0 = "";
    var flowLock0 = "";
    var failureLock0 = "";
    var exitLock0 = "";
    var planStatus0 = "";
    var lockReason0 = "";

    if (psSheet0) {
      var rlCol0 = (psMap0["regime_at_lock"] || psMap0["regime_atlock"] || psMap0["regime_at_lock "] || null);
      if (rlCol0) regimeLock0 = psSheet0.getRange(srcRow0, rlCol0).getValue();

      var flCol0 = (psMap0["flowscore_at_lock"] || psMap0["flowscore_at_lock "] || psMap0["flowscore_atlock"] || psMap0["flowscore_at_lock"] || psMap0["flowscore_atlock"] || null);
      if (flCol0) flowLock0 = psSheet0.getRange(srcRow0, flCol0).getValue();

      var fclCol0 = (psMap0["failurecost_at_lock"] || psMap0["failurecost_atlock"] || psMap0["failurecost_at_lock "] || psMap0["failurecost_at_lock"] || psMap0["failure_cost_at_lock"] || null);
      if (fclCol0) failureLock0 = psSheet0.getRange(srcRow0, fclCol0).getValue();

      var elCol0 = (psMap0["exitspeed_at_lock"] || psMap0["exitspeed_atlock"] || psMap0["exit_speed_at_lock"] || psMap0["exit_risk_speed_at_lock"] || null);
      if (elCol0) exitLock0 = psSheet0.getRange(srcRow0, elCol0).getValue();

      var psCol0 = (psMap0["planstatus"] || psMap0["plan_status"] || null);
      if (psCol0) planStatus0 = psSheet0.getRange(srcRow0, psCol0).getValue();

      var lrCol0 = (psMap0["lockreason"] || psMap0["lock_reason"] || null);
      if (lrCol0) lockReason0 = psSheet0.getRange(srcRow0, lrCol0).getValue();
    }

    // ë¬¸ìì—´í™” + ë°©ì–´
    var sTicker0 = (ticker0 === null || ticker0 === undefined) ? "" : String(ticker0).trim();
    var sRegNow0 = (regimeNow0 === null || regimeNow0 === undefined) ? "" : String(regimeNow0).trim();
    var sRegLock0 = (regimeLock0 === null || regimeLock0 === undefined) ? "" : String(regimeLock0).trim();

    var nFlowNow0 = (flowNow0 === null || flowNow0 === undefined || String(flowNow0).trim() === "") ? "" : Number(flowNow0);
    var nFlowLock0 = (flowLock0 === null || flowLock0 === undefined || String(flowLock0).trim() === "") ? "" : Number(flowLock0);

    var nFailNow0 = (failureNow0 === null || failureNow0 === undefined || String(failureNow0).trim() === "") ? "" : Number(failureNow0);
    var nFailLock0 = (failureLock0 === null || failureLock0 === undefined || String(failureLock0).trim() === "") ? "" : Number(failureLock0);

    var nExitNow0 = (exitNow0 === null || exitNow0 === undefined || String(exitNow0).trim() === "") ? "" : Number(exitNow0);
    var nExitLock0 = (exitLock0 === null || exitLock0 === undefined || String(exitLock0).trim() === "") ? "" : Number(exitLock0);

    var triggers0 = [];

    // Regime shift
    if (sRegNow0 !== "" && sRegLock0 !== "" && sRegNow0 !== sRegLock0) {
      triggers0.push("REGIME_SHIFT(" + sRegLock0 + "â†’" + sRegNow0 + ")");
    }

    // Flow score change
    if (nFlowNow0 !== "" && nFlowLock0 !== "" && !isNaN(nFlowNow0) && !isNaN(nFlowLock0) && nFlowNow0 !== nFlowLock0) {
      triggers0.push("FLOW_SCORE_SHIFT(" + nFlowLock0 + "â†’" + nFlowNow0 + ")");
    }

    // Failure cost change
    if (nFailNow0 !== "" && nFailLock0 !== "" && !isNaN(nFailNow0) && !isNaN(nFailLock0) && nFailNow0 !== nFailLock0) {
      triggers0.push("FAILURE_COST_SHIFT(" + nFailLock0 + "â†’" + nFailNow0 + ")");
    }

    // Exit speed change
    if (nExitNow0 !== "" && nExitLock0 !== "" && !isNaN(nExitNow0) && !isNaN(nExitLock0) && nExitNow0 !== nExitLock0) {
      triggers0.push("EXIT_SPEED_SHIFT(" + nExitLock0 + "â†’" + nExitNow0 + ")");
    }

    var triggersStr0 = triggers0.join(" | ");

    // Action: ê¸°ì¡´ action ë³€ìˆ˜ê°€ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©, ì—†ìœ¼ë©´ Now vs Lock ë³€í™”ì— ë”°ë¼ ìµœì†Œ ë¼ë²¨ ë¶€ì—¬
    var action0 = (typeof action !== "undefined" && action !== null && String(action).trim() !== "" ? String(action).trim() : (triggers0.length > 0 ? "REQUIRE_REVIEW" : "NO_ACTION"));

    // PlanStatus/LockReason: ì‹œíŠ¸ ê°’ ìš°ì„ , ì—†ìœ¼ë©´ ê¸°ë³¸ê°’
    var planStatusStr0 = (planStatus0 === null || planStatus0 === undefined) ? "" : String(planStatus0).trim();
    if (planStatusStr0 === "") planStatusStr0 = "PENDING";

    var lockReasonStr0 = (lockReason0 === null || lockReason0 === undefined) ? "" : String(lockReason0).trim();
    if (lockReasonStr0 === "") {
      lockReasonStr0 = action0 + (triggersStr0 ? (" | " + triggersStr0) : "");
    }

    var ts0 = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm:ss");

    // append-only ê¸°ë¡
    qSheet0.appendRow([
      ts0,
      "Final_Report",
      srcRow0,
      sTicker0,
      action0,
      triggersStr0,
      sRegNow0,
      sRegLock0,
      (nFlowNow0 === "" || isNaN(nFlowNow0) ? "" : nFlowNow0),
      (nFlowLock0 === "" || isNaN(nFlowLock0) ? "" : nFlowLock0),
      (nFailNow0 === "" || isNaN(nFailNow0) ? "" : nFailNow0),
      (nFailLock0 === "" || isNaN(nFailLock0) ? "" : nFailLock0),
      (nExitNow0 === "" || isNaN(nExitNow0) ? "" : nExitNow0),
      (nExitLock0 === "" || isNaN(nExitLock0) ? "" : nExitLock0),
      "Final_Report calculated",
      planStatusStr0,
      lockReasonStr0
    ]);
  } catch (e) {
    // í ê¸°ë¡ ì‹¤íŒ¨ëŠ” ë©”ì¸ íë¦„ì„ ë§‰ì§€ ì•ŠìŒ
  }

  ui.alert(
    "ì—…ë°ì´íŠ¸ íŠ¸ë¦¬ê±° ê°ì§€: " + reasons.join(", ") + "\n" +
    "Action: " + action + "\n" +
    actionExec +
    (planUpdated ? "\nPlan_Snapshot: LockReason ê¸°ë¡ ì™„ë£Œ" : "\nPlan_Snapshot: (ë¯¸ê¸°ë¡/ëŒ€ìƒí–‰ ì—†ìŒ)")
  );
  if (typeof scanner !== "undefined" && scanner) {
    scanner.Leveraged_Diagnostics = (scanner.Leveraged_Diagnostics !== undefined ? scanner.Leveraged_Diagnostics : (scanner.leveraged_diagnostics !== undefined ? scanner.leveraged_diagnostics : "N/A"));
    scanner.Exit_Risk_Speed = (scanner.Exit_Risk_Speed !== undefined ? scanner.Exit_Risk_Speed : (scanner.exit_risk_speed !== undefined ? scanner.exit_risk_speed : "N/A"));
  }

  const hypos = []; // (minimal) legacy helper not present in this file; keep empty for Execution_Queue

  // --- [C] E14 levels: Final_Report ë‹¨ê³„ì—ì„œ ë…ë¦½ ê³„ì‚° (ğŸ” ì„ íƒ í–‰ ë¶„ì„ ì´ì „ ì‹¤í–‰ ì „ì œ) ---
  let ENTRY_PRICE_TXT = "N/A", ADD_BUY1_TXT = "N/A", ADD_BUY2_TXT = "N/A", TP1_TXT = "N/A", TP2_TXT = "N/A", STOP_LOSS_TXT = "N/A";
  if (typeof e14 !== 'undefined' && e14 && typeof e14 === 'object') {
    ENTRY_PRICE_TXT = e14.ENTRY || "N/A";
    ADD_BUY1_TXT = e14.ADD2 || "N/A";
    ADD_BUY2_TXT = e14.ADD3 || "N/A";
    TP1_TXT = e14.TP1 || "N/A";
    TP2_TXT = e14.TP2 || "N/A";
    STOP_LOSS_TXT = e14.STOP || "N/A";
  } else {
    // runAvengersAnalysisì˜ ê³„ì‚° ë¸”ë¡ì„ Final_Reportì— ë§ê²Œ ì¬ì‚¬ìš©
    try {
      const data = Object.assign({}, (scannerBase || {}));
      // currentPriceê°€ ì—†ìœ¼ë©´ ì‹œíŠ¸ì˜ í˜„ì¬ê°€(D)ë¥¼ ì‚¬ìš©
      if (data.currentPrice === undefined && data.price === undefined && data.Price === undefined) {
        data.currentPrice = safeNumber(curPrice);
      }
      const _priceNum_calc = safeNumber(data.currentPrice ?? data.price ?? data.Price);
      const _sma20_calc = safeNumber(data.sma20 ?? data.SMA20);
      const _sma50_calc = safeNumber(data.sma50 ?? data.SMA50);
      const _sma200_calc = safeNumber(data.sma200 ?? data.SMA200);
      const _volatility_calc = safeNumber(data.volatility ?? data.Volatility);

      const _mr_raw = String(marketRegimeStr || "").toUpperCase();
      const _mr_isUp = _mr_raw.indexOf("UPTREND") >= 0;
      const _mr_isDown = _mr_raw.indexOf("DOWNTREND") >= 0;
      const _mr_isVol = _mr_raw.indexOf("VOLATILE") >= 0;

      let _stopPct_base = 0.08; // ê¸°ë³¸ 8%
      if (_volatility_calc > 0) {
        if (_volatility_calc >= 80) _stopPct_base = 0.14;
        else if (_volatility_calc >= 50) _stopPct_base = 0.12;
        else if (_volatility_calc >= 30) _stopPct_base = 0.10;
        else _stopPct_base = 0.08;
      }

      let _entryAdj = 1.00;
      let _stopAdj = 1.00;
      let _tpAdj = 1.00;

      if (_mr_isUp) {
        _entryAdj = 0.99;
        _stopAdj = 0.85;
        _tpAdj = 1.05;
      } else if (_mr_isDown) {
        _entryAdj = 0.95;
        _stopAdj = 1.20;
        _tpAdj = 0.90;
      } else if (_mr_isVol) {
        _entryAdj = 0.97;
        _stopAdj = 1.10;
        _tpAdj = 0.95;
      }

      const _stopPct_final = Math.min(0.25, Math.max(0.03, _stopPct_base * _stopAdj));

      const _anchor_up = (_sma20_calc > 0) ? _sma20_calc : _priceNum_calc;
      const _anchor_down = (_sma50_calc > 0) ? _sma50_calc : ((_sma200_calc > 0) ? _sma200_calc : _priceNum_calc);
      const _anchor_vol = (_sma20_calc > 0 && _sma50_calc > 0) ? Math.min(_sma20_calc, _sma50_calc) : (_sma20_calc > 0 ? _sma20_calc : (_sma50_calc > 0 ? _sma50_calc : _priceNum_calc));

      let _anchor = _priceNum_calc;
      if (_mr_isUp) _anchor = _anchor_up;
      else if (_mr_isDown) _anchor = _anchor_down;
      else if (_mr_isVol) _anchor = _anchor_vol;

      const _entryPrice_calc = (_anchor > 0) ? (_anchor * _entryAdj) : 0;

      const _add1_pct = _mr_isDown ? 0.04 : 0.03;
      const _add2_pct = _mr_isDown ? 0.08 : 0.06;

      const _addBuy1_calc = (_entryPrice_calc > 0) ? (_entryPrice_calc * (1 - _add1_pct)) : 0;
      const _addBuy2_calc = (_entryPrice_calc > 0) ? (_entryPrice_calc * (1 - _add2_pct)) : 0;

      let _tp1_pct = 0.08, _tp2_pct = 0.15;
      if (_mr_isUp) { _tp1_pct = 0.10; _tp2_pct = 0.18; }
      else if (_mr_isDown) { _tp1_pct = 0.06; _tp2_pct = 0.12; }

      _tp1_pct = _tp1_pct * _tpAdj;
      _tp2_pct = _tp2_pct * _tpAdj;

      const _tp1_calc = (_entryPrice_calc > 0) ? (_entryPrice_calc * (1 + _tp1_pct)) : 0;
      const _tp2_calc = (_entryPrice_calc > 0) ? (_entryPrice_calc * (1 + _tp2_pct)) : 0;

      const _stopLoss_calc = (_entryPrice_calc > 0) ? (_entryPrice_calc * (1 - _stopPct_final)) : 0;

      ENTRY_PRICE_TXT = (_entryPrice_calc > 0) ? `$${_entryPrice_calc.toFixed(2)}` : "N/A";
      ADD_BUY1_TXT = (_addBuy1_calc > 0) ? `$${_addBuy1_calc.toFixed(2)}` : "N/A";
      ADD_BUY2_TXT = (_addBuy2_calc > 0) ? `$${_addBuy2_calc.toFixed(2)}` : "N/A";
      TP1_TXT = (_tp1_calc > 0) ? `$${_tp1_calc.toFixed(2)}` : "N/A";
      TP2_TXT = (_tp2_calc > 0) ? `$${_tp2_calc.toFixed(2)}` : "N/A";
      STOP_LOSS_TXT = (_stopLoss_calc > 0) ? `$${_stopLoss_calc.toFixed(2)}` : "N/A";
    } catch (e) {}
  }

  // --- [D] Final_Report text ---
  const lines = [];
  lines.push("# FINAL_REPORT: " + ticker);
  lines.push("## 1) Hypothesis Selection (AppliesTo)");
  if (hypos.length === 0) {
    lines.push("- ì ìš© ê°€ëŠ¥í•œ Hypothesis ì—†ìŒ (Status=WATCH/SMALL_BET/ACTIVE + AppliesTo ë§¤ì¹­ ì‹¤íŒ¨)");
  } else {
    for (let i = 0; i < hypos.length; i++) {
      const h = hypos[i];
      lines.push(`- HypothesisID: ${h.hypothesisId || "N/A"} | Status: ${h.status || "N/A"} | AppliesTo: ${h.appliesTo || "N/A"}`);
      if (h.hypothesis) lines.push(`  - Hypothesis: ${h.hypothesis}`);
      if (h.exposureTypes) lines.push(`  - Exposure_Types: ${h.exposureTypes}`);
      if (h.fastFalsifiers) lines.push(`  - Fast_Falsifiers: ${h.fastFalsifiers}`);
    }
  }

  var scanner = ((typeof getScannerData === 'function') ? getScannerData(ticker) : null) || {};
  lines.push("## 2) Python/Scanner Data");
  lines.push("- Flow_Score: " + (scanner.Flow_Score !== undefined ? scanner.Flow_Score : "N/A"));
  lines.push("- Failure_Cost: " + (scanner.Failure_Cost !== undefined ? scanner.Failure_Cost : "N/A"));
  lines.push("- Leveraged_Diagnostics: " + (scanner.Leveraged_Diagnostics !== undefined ? scanner.Leveraged_Diagnostics : "N/A"));
  lines.push("- Exit_Risk_Speed: " + (scanner.Exit_Risk_Speed !== undefined ? scanner.Exit_Risk_Speed : "N/A"));

  lines.push("## 3) Plan (E14: Entry/Stop Bands)");
  var holdQty = 0;
  // isNewEntry: ê¸°ì¡´ ë³´ìœ  ìˆ˜ëŸ‰ì´ 0ì´ë©´ ì‹ ê·œì§„ì…ìœ¼ë¡œ ê°„ì£¼ (Execution_Queue íŒ¨ì¹˜ ì•ˆì •ì„± ëª©ì )
  var isNewEntry = (Number(holdQty) || 0) === 0;
lines.push("- HoldQty(B): " + holdQty);
  const myPriceDisplay = isNewEntry ? "NEW_ENTRY" : ((myPrice !== "" && myPrice !== null && myPrice !== undefined) ? myPrice : "N/A");
  let currentPriceDisplay = ((curPrice !== "" && curPrice !== null && curPrice !== undefined) ? curPrice : "");
  if (currentPriceDisplay === "") {
    const p1 = (scannerBase && (scannerBase.Price !== undefined ? scannerBase.Price : (scannerBase.price !== undefined ? scannerBase.price : (scannerBase.CurrentPrice !== undefined ? scannerBase.CurrentPrice : (scannerBase.currentPrice !== undefined ? scannerBase.currentPrice : "")))));
    currentPriceDisplay = (p1 !== "" && p1 !== null && p1 !== undefined) ? p1 : "N/A";
  }
  lines.push("- MyPrice(C): " + myPriceDisplay + (isNewEntry ? " (ì‹ ê·œì§„ì…)" : ""));
  lines.push("- CurrentPrice(D): " + (currentPriceDisplay !== "" ? currentPriceDisplay : "N/A"));
  lines.push("- Entry_1: " + ENTRY_PRICE_TXT);
  lines.push("- Add_2: " + ADD_BUY1_TXT);
  lines.push("- Add_3: " + ADD_BUY2_TXT);
  lines.push("- TP_1: " + TP1_TXT);
  lines.push("- TP_2: " + TP2_TXT);
  lines.push("- Stop_Hard: " + STOP_LOSS_TXT);
  lines.push("- E14 Source: Final_Report calculated");

  lines.push("## 4) Notes");
  if (isNewEntry) {
    lines.push("- PositionMode: NEW_ENTRY (ë³´ìœ ìˆ˜ëŸ‰=0) â†’ í‰ë‹¨ê°€/í˜„ì¬ê°€ ì—†ì´ë„ ì‹ ê·œì§„ì… ë¶„ì„ìœ¼ë¡œ ì²˜ë¦¬í•œë‹¤.");
  }
  lines.push("- Final_ReportëŠ” 'ë³´ê³ ì„œë¥¼ ì‘ì„±í•œ ì´ìœ (ê·¼ê±° ì´ì§‘í•©)'ì´ë©°, Hì—´ ë³´ê³ ì„œ(AvengersReport)ëŠ” ì´ ë‚´ìš©ì„ ê¸°ë°˜ìœ¼ë¡œ ì‘ì„±ëœë‹¤.");

  const reportText = lines.join("\n");

  const resolvedAssetType = (typeof assetType !== "undefined" && assetType !== null && String(assetType).trim() !== "" ? String(assetType).trim() : "");
  const resolvedUnderlying = (typeof underlying !== "undefined" && underlying !== null && String(underlying).trim() !== "" ? String(underlying).trim() : "");

  const scannerMerged = Object.assign({}, (scanner || {}), {
    Flow_Score: (scanner && scanner.Flow_Score !== undefined && scanner.Flow_Score !== null ? scanner.Flow_Score : ""),
    Failure_Cost: (scanner && scanner.Failure_Cost !== undefined && scanner.Failure_Cost !== null ? scanner.Failure_Cost : ""),
    Leveraged_Diagnostics: (scanner && scanner.Leveraged_Diagnostics !== undefined && scanner.Leveraged_Diagnostics !== null ? scanner.Leveraged_Diagnostics : ""),
    Exit_Risk_Speed: (scanner && scanner.Exit_Risk_Speed !== undefined && scanner.Exit_Risk_Speed !== null ? scanner.Exit_Risk_Speed : "")
  });

  const finalRow = "N/A";
  const id = Utilities.getUuid ? Utilities.getUuid() : (new Date().getTime() + "_" + ticker);

  return { id: id, text: reportText, finalRow: finalRow };
}





// ğŸ”’ [B] í”Œëœ ìŠ¤ëƒ…ìƒ· ë½(ì„ íƒ í–‰): ë¶„ì„ ê²°ê³¼(E14 ë“±)ë¥¼ ê³ ì • ê¸°ë¡ (Plan_Snapshot)
function lockPlanSnapshotForSelectedRow() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getActiveSheet();
  const row = sheet.getActiveCell().getRow();

  if (row < 2) {
    Browser.msgBox("ì„ íƒí•œ í–‰ì´ ì—†ìŠµë‹ˆë‹¤. (2í–‰ ì´ìƒì—ì„œ ì‹¤í–‰)");
    return;
  }

  // ì‹¤í–‰ ìœ„ì¹˜ì— ë”°ë¼ Ticker/ReportText ìœ„ì¹˜ê°€ ë‹¤ë¦„
  const isFinalReport = (sheet.getName() === "Final_Report");

  const ticker = isFinalReport ? sheet.getRange(row, 4).getValue() : sheet.getRange(row, 1).getValue();
  if (!ticker) {
    Browser.msgBox("ì„ íƒëœ í–‰ì— ì¢…ëª©(Ticker)ì´ ì—†ìŠµë‹ˆë‹¤.");
    return;
  }

  // E14 ì†ŒìŠ¤ í…ìŠ¤íŠ¸:
  // - ì¼ë°˜ ì‹œíŠ¸(ì‹œíŠ¸1): Hì—´(ë¶„ì„ ê²°ê³¼)
  // - Final_Report: Lì—´(ReportText)
  const advice = isFinalReport ? sheet.getRange(row, 12).getValue() : sheet.getRange(row, 8).getValue();
  const adviceStr = (advice === null || advice === undefined) ? "" : String(advice);
  if (!adviceStr || adviceStr.trim() === "") {
    Browser.msgBox(isFinalReport ? "Final_Reportì˜ ReportText(Lì—´)ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤. ë¨¼ì € Final_Reportë¥¼ ìƒì„±/ê°±ì‹ í•˜ì„¸ìš”." : "ë¶„ì„ ê²°ê³¼(Hì—´)ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤. ë¨¼ì € 'ì„ íƒ í–‰ ë¶„ì„'ì„ ì‹¤í–‰í•˜ì„¸ìš”.");
    return;
  }

  // DECISION ì¶”ì¶œ (ìˆìœ¼ë©´)
  let decision = "";
  const mDecision = adviceStr.match(/\bDECISION\s*=\s*([^\n]+)/i);
  if (mDecision && mDecision[1]) decision = String(mDecision[1]).trim();

  // E14 ë¸”ë¡ ì¶”ì¶œ (ìˆìœ¼ë©´)
  let e14Block = "";
  const mE14 = adviceStr.match(/-\s*E14[^\n]*\n([\s\S]*?)(?=\n-\s*E\d+\b|\n##\s*|\n\[|$)/i);
  if (mE14 && mE14[0]) {
    // mE14[0]ì—ëŠ” "- E14..." ë¼ì¸ í¬í•¨
    e14Block = String(mE14[0]).trim();
  }

  if (!e14Block) {
    // Final_Report í¬ë§·: "## 3) Plan (E14: Entry/Stop Bands)" ì„¹ì…˜ì„ E14 ë¸”ë¡ìœ¼ë¡œ ì¸ì •
    const mPlan = adviceStr.match(/##\s*3\)\s*Plan\s*\(E14:[\s\S]*?(?=\n##\s*4\)|$)/i);
    if (mPlan && mPlan[0]) {
      e14Block = String(mPlan[0]).trim();
    }
  }

  if (!e14Block) {
    Browser.msgBox("ë¶„ì„ ê²°ê³¼ì—ì„œ E14(ê°€ê²© ë ˆë²¨) ë¸”ë¡ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë¨¼ì € Final_Report ìƒì„±/ê°±ì‹  í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.");
    return;
  }

  // Optional: HypothesisID/ExposureID ê°™ì€ ë©”íƒ€ê°€ ìˆìœ¼ë©´ í•¨ê»˜ ê¸°ë¡
  const hdr = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(v => String(v || "").trim());
  const findCol = (name) => {
    const idx = hdr.indexOf(name);
    return (idx >= 0) ? (idx + 1) : -1;
  };
  const hypothesisIdCol = findCol("HypothesisID");
  const exposureIdCol = findCol("ExposureID");
  const assetTypeCol = findCol("AssetType");
  const underlyingCol = findCol("Underlying");

  const hypothesisId = (hypothesisIdCol > 0) ? sheet.getRange(row, hypothesisIdCol).getValue() : "";
  const exposureId = (exposureIdCol > 0) ? sheet.getRange(row, exposureIdCol).getValue() : "";
  const assetType = (assetTypeCol > 0) ? sheet.getRange(row, assetTypeCol).getValue() : "";
  const underlying = (underlyingCol > 0) ? sheet.getRange(row, underlyingCol).getValue() : "";

  // ê°€ê²© ì •ë³´: Sheet1ì—ì„œëŠ” C/Dë¥¼ ì‚¬ìš©, Final_Reportì—ì„œëŠ” ReportTextì—ì„œ CurrentPrice(D) ë“±ì„ íŒŒì‹±
  let priceNow = "";
  let myPrice = "";
  if (!isFinalReport) {
    priceNow = sheet.getRange(row, 4).getValue(); // Dì—´(í˜„ì¬ê°€)
    myPrice = sheet.getRange(row, 3).getValue();  // Cì—´(ë‚´ í‰ê· ê°€/ì§„ì…ê°€)
  } else {
    const mPx = adviceStr.match(/CurrentPrice\(D\):\s*\$?([0-9]+(?:\.[0-9]+)?)/i);
    if (mPx && mPx[1]) priceNow = Number(mPx[1]);
    const mMy = adviceStr.match(/MyPrice\(C\):\s*\$?([0-9]+(?:\.[0-9]+)?)/i);
    if (mMy && mMy[1]) myPrice = Number(mMy[1]);
  }

  const snap = ensurePlanSnapshotSheet(); // SheetHelper.gs
  const createdAt = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm:ss");

  // í—¤ë” ë³´ì¥ (í˜¹ì‹œ ìˆ˜ë™ ì‚­ì œ ëŒ€ë¹„)
  const mustHdr = ["CreatedAt","Sheet","Row","Ticker","HypothesisID","ExposureID","AssetType","Underlying","PriceNow","MyPrice","Decision","E14_Block","Regime","RawAdvice","Regime_At_Lock","E14_Source","FlowScore_At_Lock","FailureCost_At_Lock","ExitSpeed_At_Lock","LockReason"];
  const curHdr = snap.getRange(1, 1, 1, Math.max(snap.getLastColumn(), mustHdr.length)).getValues()[0].map(v => String(v || "").trim());
  if (curHdr.join("|") !== mustHdr.join("|")) {
    // ê¸°ì¡´ ë°ì´í„° ì´ë™ ê¸ˆì§€: 1í–‰ë§Œ ì¬ë³´ì • (ì—´ ë¶€ì¡± ì‹œ ë’¤ì—ë§Œ ì±„ì›€)
    for (let i = 0; i < mustHdr.length; i++) {
      if (!curHdr[i]) snap.getRange(1, i + 1).setValue(mustHdr[i]).setFontWeight("bold");
    }
    snap.setFrozenRows(1);
  }

  const regime = isFinalReport ? String(sheet.getRange(row, 7).getValue() || "").trim() : "";

  // At-lock snapshot values (used by Regime Update Trigger)
  const flowAtLock = isFinalReport ? sheet.getRange(row, 8).getValue() : "";
  const failureAtLock = isFinalReport ? sheet.getRange(row, 9).getValue() : "";
  const exitAtLock = isFinalReport ? sheet.getRange(row, 11).getValue() : "";
  const regimeAtLock = regime || (isFinalReport ? "" : "");
  let e14Source = "";
  const mSrc = adviceStr.match(/E14 Source:\s*([^\r\n]+)/i);
  if (mSrc && mSrc[1]) e14Source = String(mSrc[1]).trim();
  const lockReason = "MANUAL_LOCK";

  snap.appendRow([
    createdAt,
    sheet.getName(),
    row,
    ticker,
    hypothesisId,
    exposureId,
    assetType,
    underlying,
    priceNow,
    myPrice,
    decision,
    e14Block,
    regime,
    adviceStr,
    regimeAtLock,
    e14Source,
    flowAtLock,
    failureAtLock,
    exitAtLock,
    lockReason
  ]);

  Browser.msgBox("âœ… í”Œëœ ìŠ¤ëƒ…ìƒ· ì €ì¥ ì™„ë£Œ (Plan_Snapshot)");
}

// --- Main Execution ---
function runAvengersAnalysis(startRow, endRow) {
  const config = getConfig();
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  const todayObj = new Date();
  const today = todayObj.toLocaleDateString('ko-KR', {year: 'numeric', month: 'long', day: 'numeric'});
  const currentYear = todayObj.getFullYear();
  const currentMonth = todayObj.toLocaleString('default', { month: 'long' });

  const MIN_RESPONSE_LENGTH = config.MIN_RESPONSE_LENGTH;
  if (!config.API_KEY || config.API_KEY.length < 30) {
    Browser.msgBox("âš ï¸ ì˜¤ë¥˜: API í‚¤ë¥¼ í™•ì¸í•˜ì„¸ìš”.");
    return;
  }

  ss.toast(`ğŸš€ Financial Avengers ê°€ë™ ì¤‘... (${today})`, "System Active");

  const sheet = ss.getActiveSheet();
  const pSheet = ensurePortfolioSheet();
  // âœ… [B] Final_Report ì‹œíŠ¸ëŠ” ì„ íƒ í–‰/ì „ì²´ ë¶„ì„ ëª¨ë‘ì˜ ë‹¨ì¼ ì§„ì‹¤ì›ì²œ
  ensureFinalReportSheet();

  // Detect AssetType/Underlying columns (for STOCK / ETF / LEVERAGED_ETF branching)
  const _hdr = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(v => String(v || '').trim());
  let assetTypeCol = -1;
  let underlyingCol = -1;
  for (let c = 0; c < _hdr.length; c++) {
    if (_hdr[c] === 'AssetType') assetTypeCol = c + 1;
    if (_hdr[c] === 'Underlying') underlyingCol = c + 1;
  }

  
  const SAFETY_CORE_MIN = config.SAFETY_CORE_MIN;
  const CASH_WEIGHT_MIN = config.CASH_WEIGHT_MIN;
  const TARGET_ANNUAL_RETURN = config.TARGET_ANNUAL_RETURN;

  const rawSafetyRatio = pSheet.getRange("C7").getValue();
  const rawExchangeRate = pSheet.getRange("C6").getValue();
  const rawCashInput = pSheet.getRange("C4").getValue(); 
  const rawSafetyKRW = pSheet.getRange("C5").getValue();

  let safetyRatio = normalizePercentRatio(rawSafetyRatio, SAFETY_CORE_MIN);
  if (safetyRatio < 0) safetyRatio = 0;
  if (safetyRatio > 1) safetyRatio = 1;

  const cashKRW = normalizeNumber(rawCashInput, 0) * 10000;
  let exchangeRate = normalizeNumber(rawExchangeRate, 1400);
  if (exchangeRate <= 0) exchangeRate = 1400;
  const safetyKRW = normalizeNumber(rawSafetyKRW, 0) * 10000;

  const lastRow = sheet.getLastRow();
  const maxRow = Math.min(lastRow, config.MAX_ANALYSIS_ROWS + 1);

  if (maxRow < 2) { Browser.msgBox("ë¶„ì„í•  ì¢…ëª©ì´ ì—†ìŠµë‹ˆë‹¤."); return; }

  // âœ… ì„ íƒ ë²”ìœ„ ë¶„ì„ ì§€ì› (ì „ì²´ ë¶„ì„ ë©”ì»¤ë‹ˆì¦˜ ìœ ì§€)
  const fromRow = startRow || 2;
  const toRow = endRow || maxRow;
  const safeFrom = Math.max(2, fromRow);
  const safeTo = Math.min(maxRow, toRow);
  if (safeTo < safeFrom) { Browser.msgBox("ë¶„ì„í•  ì¢…ëª©ì´ ì—†ìŠµë‹ˆë‹¤."); return; }

  const baseRow = safeFrom;
  const inputData = sheet.getRange(baseRow, 1, safeTo - safeFrom + 1, 3).getValues();
  let totalStockValueUSD = 0;
  let portfolioData = [];
  
  for (let i = 0; i < inputData.length; i++) {
    let ticker = inputData[i][0];
    let qty = inputData[i][1];          
    let myPrice = inputData[i][2];      
    
    let currentPrice = 0;
    let scanner = getScannerData(ticker); // Logic.gs

    // íŒ¨ì¹˜: Scanner Price ì•ˆì „ íŒŒì‹±
    const scannerPrice = scanner && scanner['Price'] ? parseFloat(scanner['Price']) : NaN;
    if (!isNaN(scannerPrice) && scannerPrice > 0) {
      currentPrice = scannerPrice;
    } 
    
    if ((!currentPrice || currentPrice === 0 || isNaN(currentPrice)) && ticker) {
      const tempCell = sheet.getRange(baseRow + i, 4); 
      tempCell.setFormula(`=GOOGLEFINANCE("${ticker}", "price")`);
      SpreadsheetApp.flush(); 
      let gfPrice = tempCell.getValue();
      
      if (typeof gfPrice === 'number' && gfPrice > 0) {
        currentPrice = gfPrice;
      }
      tempCell.clearContent(); 
    }

    if (ticker && typeof currentPrice === 'number' && currentPrice > 0) {
      sheet.getRange(baseRow + i, 4).setValue(currentPrice); 
      
      let quantity = (qty === "" || isNaN(qty)) ? 0 : qty;
      let stockValue = quantity * currentPrice;
      totalStockValueUSD += stockValue;
      portfolioData.push({ rowIndex: i, ticker, myPrice, quantity, currentPrice, stockValue });
    } else {
      portfolioData.push({ rowIndex: i, ticker: null, quantity: 0, stockValue: 0, currentPrice: 0 });
    }
  }

  pSheet.getRange("C3").setValue(totalStockValueUSD);
  SpreadsheetApp.flush();

  const cashUSD = cashKRW / exchangeRate;
  const safetyUSD = safetyKRW / exchangeRate;
  const brokerageAssetsUSD = totalStockValueUSD + cashUSD;
  const totalAssetsUSD = brokerageAssetsUSD + safetyUSD;
  const cashWeight = (brokerageAssetsUSD > 0) ? (cashUSD / brokerageAssetsUSD) : 0;
  
  // Market Regime Calculation
  let lossCount = 0;
  let totalMddSum = 0;
  let mddCount = 0;
  let activeStockCount = 0;

  for (let i = 0; i < portfolioData.length; i++) {
    let d = portfolioData[i];
    if (!d.ticker) continue;
    activeStockCount++;

    let currentRet = 0;
    if (d.quantity > 0 && d.myPrice > 0) {
      currentRet = (d.currentPrice - d.myPrice) / d.myPrice;
    }
    if (currentRet < 0) lossCount++;

    let sData = getScannerData(d.ticker);
    if (sData && sData['MDD']) {
      let mddVal = Math.abs(parseFloat(String(sData['MDD']).replace(/[%]/g, '')) || 0);
      totalMddSum += mddVal;
      mddCount++;
    }
  }

  const lossRatio = activeStockCount > 0 ? (lossCount / activeStockCount) : 0;
  const avgMdd = mddCount > 0 ? (totalMddSum / mddCount) : 0;

  const marketRegime = classifyMarketRegime(safetyRatio, lossRatio, avgMdd);
  
  // ğŸ”’ FIX: define portfolio context strings for prompt templates
  const cashRatioStr = (cashWeight * 100).toFixed(1) + '%';
  const safetyCoreRatioStr = (safetyRatio * 100).toFixed(1) + '%';
  const marketRegimeStr = String(marketRegime || '');

  
  const marketRegimeInfo = `
    [ğŸ“‰ MARKET REGIME DATA]:
    - Current Regime: **${marketRegime}**
    - Portfolio Loss Ratio: ${(lossRatio * 100).toFixed(1)}%
    - Avg Portfolio MDD: -${avgMdd.toFixed(1)}%
    - Safety Core: ${(safetyRatio * 100).toFixed(1)}%
  `;

  let portfolioSummary = `[TOTAL WEALTH OVERVIEW]\n`;
  portfolioSummary += `- Total Net Worth: $${totalAssetsUSD.toLocaleString()}\n`;
  portfolioSummary += `- ğŸ›¡ï¸ Safety Core (DC+IRP): $${safetyUSD.toLocaleString()} (**${(safetyRatio * 100).toFixed(1)}%**)\n`;
  portfolioSummary += `- ğŸš€ Growth Engine (Brokerage) Total: $${brokerageAssetsUSD.toLocaleString()} (Cash Weight: ${(cashWeight * 100).toFixed(1)}%)\n`;
  portfolioSummary += `------------------------\n`;
  
  portfolioData.forEach(d => {
    if (d.ticker && d.quantity > 0) { 
        let w = brokerageAssetsUSD > 0 ? (d.stockValue / brokerageAssetsUSD) : 0; 
        portfolioSummary += `- ${d.ticker}: Alloc ${(w*100).toFixed(1)}%\n`;
    }
  });

  let marketContext = "ì‹œì¥ ìƒí™© ë¶„ì„ ì‹¤íŒ¨";
  let qtStatus = "ë¶ˆëª…í™•";
  try {
    ss.toast(`ğŸ§  ê²½ì œ ì§€í‘œ ë¶„ì„ ì¤‘...`, "Avengers AI");
    SpreadsheetApp.flush();
    const contextPrompt = `
      [Today's Date]: ${today}
      [Role]: Chief Economist.
      [TASK]: SEARCH for MACRO DATA (${currentYear}):
      1. Fed Rate & Powell Speech (${currentMonth})
      2. CPI/PCE Inflation
      3. Unemployment Rate
      4. Fear & Greed / VIX
      5. QT Status
      [OUTPUT]: Summarize Macro Situation & QT Status.
    `;
    marketContext = callGemini(contextPrompt, config.MODEL_NAME);
    const lines = marketContext.split('\n');
    const qtMatch = lines.find(line => line.includes("QT ìƒíƒœ"));
    if (qtMatch) qtStatus = qtMatch.replace(/.*\[QT ìƒíƒœ:\s*/, '').replace(/\]\s*$/, '').trim();
  } catch (e) { Logger.log("Macro Error: " + e.toString()); }

  for (let i = 0; i < portfolioData.length; i++) {
    let data = portfolioData[i];
    if (!data.ticker || data.currentPrice <= 0) continue;

    let ticker = data.ticker;
    let myPrice = data.myPrice;
    let row = baseRow + i; 
    // Ensure AssetType / Underlying BEFORE expert advice
    // (ë°©ì–´ì½”ë“œ) ê¸°ì¡´ í”„ë¡œì íŠ¸ì— ensureAssetMetaForRow_ê°€ ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì¡´ì¬í•  ë•Œë§Œ í˜¸ì¶œ
    if (typeof ensureAssetMetaForRow_ === 'function') {
      ensureAssetMetaForRow_(sheet, row);
    }
    let signalCell = sheet.getRange(row, 7); 
    let statusCell = sheet.getRange(row, 8); 
    let currentVal = statusCell.getValue();
    
    if (currentVal !== "" && !currentVal.toString().includes("ì˜¤ë¥˜") && !currentVal.toString().includes("ë¶„ì„ ì¤‘")) continue;

    statusCell.setValue(`â³ ${ticker} ë¶„ì„ ì¤‘...`);
    SpreadsheetApp.flush();

    try {
      if (data.quantity > 0 && data.myPrice > 0) {
        let returnRate = (data.currentPrice - data.myPrice) / data.myPrice;
        sheet.getRange(row, 5).setValue(returnRate).setNumberFormat("0.00%"); 
      } else {
        sheet.getRange(row, 5).setValue("ì‹ ê·œì§„ì…");
      }
      
      const finData = getFinvizData(ticker);
      finData.currentPrice = data.currentPrice;
      
      let peValue = parseFloat(finData.per);
      finData.earningsYield = (!isNaN(peValue) && peValue > 0) ? (1 / peValue * 100).toFixed(2) + "%" : "N/A";
      
      let techData = getConfig().TECH_DEFAULT;
      try { techData = calculateTechnicalIndicators(ticker); } catch (e) { Logger.log("Tech Error: " + e); }
      
      let realMetrics = calculateRealRiskMetrics(ticker);
      const newsObj = getUSNews(ticker);
      const scannerRecommendation = getAlternativeSuggestions(ticker, finData.sector);

      let allowedActions = [];
      let riskTier = "Low";
      if (safetyRatio < SAFETY_CORE_MIN) {
          riskTier = "Critical";
          allowedActions = ["ê´€ë§", "ë¹„ì¤‘ì¶•ì†Œ", "ì „ëŸ‰ë§¤ë„"]; 
      } else {
          riskTier = "Normal";
          allowedActions = ["ê°•ë ¥ë§¤ìˆ˜", "ë¶„í• ë§¤ìˆ˜", "ê´€ë§", "ë¹„ì¤‘ì¶•ì†Œ", "ì „ëŸ‰ë§¤ë„"];
      }
      if (cashWeight < CASH_WEIGHT_MIN) allowedActions = allowedActions.filter(a => a !== "ê°•ë ¥ë§¤ìˆ˜");

      // íŒ¨ì¹˜: AllowedActions ë¹„ì–´ ìˆì„ ë•Œ ê¸°ë³¸ê°’
      if (allowedActions.length === 0) {
          allowedActions = ["ê´€ë§"];
      }

      let coreEngineBrief = `
        [âš–ï¸ CORE RISK ENGINE OUTPUT]
        - Current Risk Tier: **${riskTier}**
        - Safety Core Status: ${(safetyRatio*100).toFixed(1)}% (Target > ${SAFETY_CORE_MIN*100}%)
        - Allowed Actions: **[${allowedActions.join(", ")}]**
      `;

      let calcSignals = [];
      if (parseFloat(techData.rsi) < 30) calcSignals.push("RSI Oversold");
      else if (parseFloat(techData.rsi) > 70) calcSignals.push("RSI Overbought");
      let quantGrounding = calcSignals.join(", ");
      
      const biasResult = calculateBiasScore(ticker, techData, finData, brokerageAssetsUSD, cashWeight);

      let scannerPromptSection = (finData.source === "PYTHON_SCANNER") 
          ? `[PYTHON SCANNER DATA]: Fair Value ${finData.fairValueScore}, Upside ${finData.upsidePotential}%, Quality ${finData.qualityScore}`
          : `[PYTHON SCANNER DATA]: UNAVAILABLE (Using Fallback)`;

      const industryInfo = (finData.sector && finData.sector !== "N/A") ? `${finData.sector} / ${finData.industry}` : "Unknown";
      const safetyCoreString = (safetyRatio * 100).toFixed(1) + "%";

      let totalQuantity = data.quantity;
      let currentWeight = 0;
      if (brokerageAssetsUSD > 0 && data.stockValue > 0) {
         currentWeight = (data.stockValue / brokerageAssetsUSD) * 100; 
      }

      const curAssetType = (assetTypeCol > 0) ? String(sheet.getRange(row, assetTypeCol).getValue() || '').trim() : '';
      const curUnderlying = (underlyingCol > 0) ? String(sheet.getRange(row, underlyingCol).getValue() || '').trim() : '';
      const isLeveragedETF = (curAssetType === 'LEVERAGED_ETF' || curAssetType === 'LEVERAGED ETF');
      let scannerData = getScannerData(ticker);
      let rsiVal = scannerData ? scannerData['RSI'] : "N/A";

      let prompt = '';
      if (isLeveragedETF) {

        const underlyingScannerData = curUnderlying ? getScannerData(curUnderlying) : null;

        // NOTE: For LEVERAGED_ETF, restrict data to technical/risk metrics only (no fundamentals)
        const leveragedTechPack = {
          Price: (scannerData && scannerData['Price']) || finData.currentPrice || data.currentPrice || 'N/A',
          RSI: (scannerData && scannerData['RSI']) || (techData && techData.rsi) || 'N/A',
          Volatility: (scannerData && scannerData['Volatility']) || 'N/A',
          MDD: (scannerData && scannerData['MDD']) || 'N/A',
          Sharpe: (scannerData && scannerData['Sharpe']) || 'N/A',
          SMA20: (scannerData && scannerData['SMA20']) || 'N/A',
          SMA50: (scannerData && scannerData['SMA50']) || 'N/A',
          SMA200: (scannerData && scannerData['SMA200']) || 'N/A',
          MomentumScore: (scannerData && scannerData['Momentum Score']) || 'N/A'
        };

        const underlyingTechPack = {
          Price: (underlyingScannerData && underlyingScannerData['Price']) || 'N/A',
          RSI: (underlyingScannerData && underlyingScannerData['RSI']) || 'N/A',
          Volatility: (underlyingScannerData && underlyingScannerData['Volatility']) || 'N/A',
          MDD: (underlyingScannerData && underlyingScannerData['MDD']) || 'N/A',
          Sharpe: (underlyingScannerData && underlyingScannerData['Sharpe']) || 'N/A',
          SMA20: (underlyingScannerData && underlyingScannerData['SMA20']) || 'N/A',
          SMA50: (underlyingScannerData && underlyingScannerData['SMA50']) || 'N/A',
          SMA200: (underlyingScannerData && underlyingScannerData['SMA200']) || 'N/A',
          MomentumScore: (underlyingScannerData && underlyingScannerData['Momentum Score']) || 'N/A'
        };

                prompt = `
        ${getSystemPrompt(newsObj.legalRisk, allowedActions, brokerageAssetsUSD, data.currentPrice, totalQuantity, currentWeight, TARGET_ANNUAL_RETURN)}

ë‹¹ì‹ ì€ 'Financial Avengers' ì‹œìŠ¤í…œì˜ **ë ˆë²„ë¦¬ì§€ ETF ì „ìš© íˆ¬ì íŒë‹¨ ì—”ì§„**ì´ë‹¤.

ëŒ€ìƒ ì¢…ëª©ì€ **ë ˆë²„ë¦¬ì§€ ETF**ì´ë©°, ì•„ë˜ ê·œì¹™ì„ ë°˜ë“œì‹œ ë”°ë¥¸ë‹¤:
1) ë ˆë²„ë¦¬ì§€ ETF ìì²´(ì˜ˆ: ${ticker})ë¥¼ 'ê¸°ì—…'ì²˜ëŸ¼ í•´ì„í•˜ì§€ ë§ ê²ƒ. (PER/PBR/ROE/ë§¤ì¶œ/ê²½ìŸë ¥ ë“± ê¸°ì—… ì¬ë¬´ ì„œìˆ  ê¸ˆì§€)
2) **ê¸°ì´ˆìì‚°(Underlying: ${curUnderlying || 'N/A'})**ì˜ ë°ì´í„°ë¥¼ ë°˜ë“œì‹œ ì°¸ì¡°í•˜ë˜, **ê¸°ì´ˆìì‚° ë˜í•œ ì¬ë¬´ì§€í‘œ(PER/PBR/ROE ë“±) ì–¸ê¸‰ ê¸ˆì§€**. ê¸°ìˆ /ë¦¬ìŠ¤í¬ ì§€í‘œ(ë³€ë™ì„±, MDD, RSI, SMA, ì¶”ì„¸) ì¤‘ì‹¬ìœ¼ë¡œë§Œ íŒë‹¨.
3) ë ˆë²„ë¦¬ì§€ ETFì˜ êµ¬ì¡°ì  íŠ¹ì„±(ë³€ë™ì„± í™•ëŒ€, ë³€ë™ì„± ë“œë˜ê·¸/Decay, ê¸‰ë½ ì‹œ íšŒë³µ ë‚œì´ë„)ì„ ë³„ë„ ë¦¬ìŠ¤í¬ë¡œ í‰ê°€.
4) ì œê³µëœ ë°ì´í„°ë§Œ ì‚¬ìš©(ìˆ«ì/ì‚¬ì‹¤ ì°½ì‘ ê¸ˆì§€). ëª¨ë¥´ëŠ” ê°’ì€ 'N/A'. ë¯¸ë˜ ì˜ˆì¸¡ ë‹¨ì • ê¸ˆì§€.

[HALLUCINATION ZERO-TOLERANCE RULES]:
- ì œê³µëœ ë°ì´í„°ë§Œ ì‚¬ìš©. ì¦ê±° ë°– ìˆ«ì/ì‚¬ì‹¤ ì°½ì‘ ê¸ˆì§€.
- ìˆ«ì/ìˆ˜ì¹˜ëŠ” ë°˜ë“œì‹œ ì•„ë˜ Exhibits ê°’ì„ ê·¸ëŒ€ë¡œ ì¸ìš©í•˜ê³  (E#)ë¥¼ ë¶™ì¼ ê²ƒ. ì¬ê³„ì‚°/ì¬ì„œìˆ  ê¸ˆì§€.
- Exhibitsì— ì—†ëŠ” í•­ëª©ì€ UNKNOWN ë˜ëŠ” N/Aë¡œë§Œ í‘œê¸°.
- E# ì¸ìš©ì´ ì—†ëŠ” ì£¼ì¥ì€ CEOê°€ REJECTED_CLAIMSë¡œ ê¸°ê°í•œë‹¤.

[1] í¬íŠ¸í´ë¦¬ì˜¤ ë§¥ë½
- Cash Ratio: ${cashRatioStr}
- Safety Core Ratio: ${safetyCoreRatioStr}
- Market Regime: ${marketRegimeStr}

[2] ë ˆë²„ë¦¬ì§€ ETF(ëŒ€ìƒ) ê¸°ìˆ /ë¦¬ìŠ¤í¬ ë°ì´í„° (Scanner_Data ê¸°ë°˜, ì¬ë¬´ ì‚¬ìš© ê¸ˆì§€)
- Ticker: ${ticker}
- AssetType: ${curAssetType || 'LEVERAGED_ETF'}
- Underlying: ${curUnderlying || 'N/A'}
- Metrics: ${JSON.stringify(leveragedTechPack)}

[3] ê¸°ì´ˆìì‚°(Underlying) ê¸°ìˆ /ë¦¬ìŠ¤í¬ ë°ì´í„° (Scanner_Data ê¸°ë°˜, ì¬ë¬´ ì‚¬ìš© ê¸ˆì§€)
- Underlying: ${curUnderlying || 'N/A'}
- Metrics: ${JSON.stringify(underlyingTechPack)}

[EXHIBITS - USE ONLY THESE NUMBERS/FACTS]:
- E1 Cash Ratio: ${cashRatioStr}
- E2 Safety Core Ratio: ${safetyCoreRatioStr}
- E3 Market Regime: ${marketRegimeStr}
- E4 Leveraged Ticker: ${ticker}
- E5 Underlying: ${curUnderlying || 'N/A'}
- E6 Leveraged Metrics(JSON): ${JSON.stringify(leveragedTechPack)}
- E7 Underlying Metrics(JSON): ${JSON.stringify(underlyingTechPack)}
- E8 Allowed Actions: [${allowedActions.join(", ")}]


[MISSION]:
1. ì¶œë ¥ì€ ë°˜ë“œì‹œ MARKDOWN í˜•ì‹ì´ì–´ì•¼ í•˜ë©°, ì•„ë˜ ì„¹ì…˜ì„ **ëª¨ë‘** í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤. (ì„¹ì…˜ ì œëª©ì€ **í•œ ê¸€ìë„ ë³€ê²½ ê¸ˆì§€**)
2. ë ˆë²„ë¦¬ì§€ ETFëŠ” **ê¸°ì—… í€ë”ë©˜í„¸ ìš”ì•½ ì„¹ì…˜ì„ ë§Œë“¤ì§€ ë§ê³ **, ëŒ€ì‹  ë ˆë²„ë¦¬ì§€ êµ¬ì¡°/ê¸°ì´ˆìì‚° ì¶”ì„¸/ë¦¬ìŠ¤í¬ ì¤‘ì‹¬ìœ¼ë¡œ ì‘ì„±í•˜ì‹­ì‹œì˜¤.

## ğŸ CEO ìµœì¢… ê²°ì •
- ë°˜ë“œì‹œ ì²« ì¤„ì—: DECISION= / BIAS_GRADE= / BIAS_SCORE= ë¥¼ í¬í•¨
- CEO(Jamie Dimon)ëŠ” **ì¬íŒì¥**ì´ë‹¤. ì•„ë˜ í˜•ì‹ì„ ì—„ìˆ˜í•œë‹¤(ì¶”ê°€ ë¬¸ì¥ ê¸ˆì§€):
  1) VERDICT: (DECISIONê³¼ ë™ì¼í•œ í•œ ë‹¨ì–´)
  2) KEY_EVIDENCE: E# 3~7ê°œ
  3) REJECTED_CLAIMS: (E# ì—†ëŠ” ì£¼ì¥/ìˆ«ì ì°½ì¡°/ê·¼ê±° ë¶ˆì¶©ë¶„ ì£¼ì¥ ê¸°ê°)
  4) WHAT WOULD CHANGE MY MIND: (ì œê³µ ë°ì´í„°ë¡œë§Œ ì¡°ê±´ 2~4ê°œ)
  5) ACTION PLAN: (2~5ì¤„, ì œê³µ ë°ì´í„° ìˆ˜ì¹˜ ê¸°ë°˜)
 (Action Plan)
- ì§„ì… ê¸ˆì§€/ì¡°ê±´ë¶€ ì§„ì…/ì¶•ì†Œ/ì†ì ˆ/ê´€ì°° íŠ¸ë¦¬ê±°ë¥¼ ìˆ˜ì¹˜ ê¸°ë°˜ìœ¼ë¡œ ì œì‹œ (RSI/SMA/Vol/MDD ë“± ì œê³µ ë°ì´í„°ë§Œ ì‚¬ìš©)

## âš”ï¸ ê²½ìŸì‚¬ ë° ëŒ€ì²´ íˆ¬ì
- ë ˆë²„ë¦¬ì§€ ETFê°€ ì•„ë‹Œ ëŒ€ì²´(ê¸°ì´ˆìì‚° ì§íˆ¬/ì¸ë²„ìŠ¤/í˜„ê¸ˆ/ì•ˆì „ìì‚° ë“±) ê´€ì  í¬í•¨

## ğŸ“Š ìƒì„¸ ë°ì´í„° ê²€ì¦
- Sharpe/MDD/Vol/RSI/SMA ë“± ì œê³µ ë°ì´í„° ê¸°ë°˜ì˜ ê¸°ìˆ ì /ë¦¬ìŠ¤í¬ í•´ì„(ìˆ«ì ì°½ì¡° ê¸ˆì§€)

## ğŸ”¥ í•µì‹¬ ë…¼ìŸ ìš”ì•½
- ì™œ ê·¸ë ‡ê²Œ ê²°ì •ë˜ëŠ”ì§€ í•µì‹¬ ë¦¬ìŠ¤í¬(Decay/ë³€ë™ì„± ë“œë˜ê·¸/ì‹œì¥ ë ˆì§ ë¶€ì í•© ë“±)ì™€ ê·¼ê±°ë¥¼ ìš”ì•½

## ğŸ’ ê°œë³„ ì¢…ëª© ë¶„ì„
- ë ˆë²„ë¦¬ì§€ ETF ìì²´ì˜ êµ¬ì¡°ì  ìœ„í—˜ + ê¸°ì´ˆìì‚°(Underlying) ì¶”ì„¸/ë³€ë™ì„± ê´€ì  ë¶„ì„ (ê¸°ì—… ì¬ë¬´/ë°¸ë¥˜ì—ì´ì…˜ ì–¸ê¸‰ ê¸ˆì§€)

## ğŸ‘€ Tenbagger Observation (ê´€ì°° ì „ìš©)
- í…ë²„ê±° ê´€ì ì´ ì•„ë‹ˆë¼ **ê´€ì°° ì¡°ê±´/ë¦¬ìŠ¤í¬ ê²½ê³„ì„ **ë§Œ ì œì‹œ

## ğŸ‘¥ í˜ë¥´ì†Œë‚˜ íšŒì˜ê¸°ë¡ (#### [The Debate])
#### [The Debate]
- ì•„ë˜ PERSONA DEFINITIONSì— ìˆëŠ” **ëª¨ë“  í˜ë¥´ì†Œë‚˜**ê°€ ë°˜ë“œì‹œ 1íšŒì”© ë°œì–¸í•´ì•¼ í•©ë‹ˆë‹¤.
- ê° í˜ë¥´ì†Œë‚˜ ë°œì–¸ì€ ì•„ë˜ 6ì¤„ ê³ ì • í˜•ì‹ë§Œ í—ˆìš©(ì¶”ê°€ ë¬¸ì¥/ì¶”ê°€ ì¤„ ê¸ˆì§€):
  1) PERSONA: (ì´ë¦„/ì—­í• )
  2) STANCE: BUY | HOLD | SELL | WAIT
  3) CONF: 0-100
  4) EVIDENCE: E#,E# (ìµœì†Œ 2ê°œ)
  5) RISK: (E# ê¸°ë°˜ í•œ ì¤„)
  6) UNKNOWN: (ì—†ìœ¼ë©´ NONE)
- ìˆ«ì/ì‚¬ì‹¤ì€ ë°˜ë“œì‹œ Exhibitsì˜ ê°’ì„ **ê·¸ëŒ€ë¡œ ì¸ìš©**í•˜ê³  (E#)ë¥¼ ë¶™ì¸ë‹¤. ìˆ«ì ì¬ê³„ì‚°/ì¬ì„œìˆ  ê¸ˆì§€.
- ë§ˆì§€ë§‰ì—ëŠ” ë°˜ë“œì‹œ CEO(Jamie Dimon)ê°€ **ì¬íŒì¥ íŒê²°ë¬¸**ì„ ì•„ë˜ í˜•ì‹ìœ¼ë¡œ ë§ˆë¬´ë¦¬(ì¶”ê°€ ë¬¸ì¥ ê¸ˆì§€):
  - CEO_VERDICT: (DECISIONê³¼ ë™ì¼)
  - CEO_KEY_EVIDENCE: E# 3~7ê°œ
  - CEO_REJECTED_CLAIMS: (ê¸°ê° ì‚¬ìœ  1~3ê°œ)

3. **Translation**: If any English content is included, translate it to Korean.
4. **Formatting**: Use clear bullet points and short paragraphs where appropriate.
        `;


      } else if (String(curAssetType || '').toUpperCase() === 'ETF') {
        // ETF template branch: use ETF_Data sheet (index/volatility/trend focused)
        let etfDataObj = null;
        try {
          const etfSheet = ss.getSheetByName('ETF_Data');
          if (etfSheet) {
            const etfValues = etfSheet.getDataRange().getValues();
            if (etfValues && etfValues.length > 1) {
              const etfHeaders = etfValues[0].map(h => String(h || '').trim());
              const tIdx = etfHeaders.indexOf('Ticker');
              const uIdx = etfHeaders.indexOf('Underlying');
              for (let r = 1; r < etfValues.length; r++) {
                const row = etfValues[r];
                const tVal = tIdx >= 0 ? String(row[tIdx] || '').trim().toUpperCase() : '';
                const uVal = uIdx >= 0 ? String(row[uIdx] || '').trim().toUpperCase() : '';
                if (tVal === ticker || uVal === ticker) {
                  const obj = {};
                  for (let c = 0; c < etfHeaders.length; c++) obj[etfHeaders[c]] = row[c];
                  etfDataObj = obj;
                  break;
                }
              }
            }
          }
        } catch (e) {
          etfDataObj = null;
        }

        prompt = `
ë‹¹ì‹ ì€ 'Financial Avengers' ì‹œìŠ¤í…œì˜ **ETF(ì§€ìˆ˜/íŒ©í„°/ì„¹í„°) ì „ìš© íˆ¬ì íŒë‹¨ ì—”ì§„**ì´ë‹¤.

ëŒ€ìƒ ì¢…ëª©ì€ **ETF**ì´ë©°, ì•„ë˜ ê·œì¹™ì„ ë°˜ë“œì‹œ ë”°ë¥¸ë‹¤:
1) ETFëŠ” ê°œë³„ ê¸°ì—…ì´ ì•„ë‹ˆë¯€ë¡œ, ê¸°ì—… ì¬ë¬´(P/E, ROE ë“±)ë¥¼ ê¸°ì—…ì²˜ëŸ¼ í•´ì„í•˜ì§€ ë§ ê²ƒ.
2) **ETF_Data**(ë¹„ìš©, ìì‚°ê·œëª¨, ë¶„ë°°ê¸ˆ/ìˆ˜ìµë¥ , ë² íƒ€, ë³´ìœ ì¢…ëª©ìˆ˜) + **ê¸°ìˆ ì§€í‘œ(ë³€ë™ì„±/ì¶”ì„¸/ë‚™í­/RSI/SMA)** ì¤‘ì‹¬ìœ¼ë¡œ íŒë‹¨.
3) í¬íŠ¸í´ë¦¬ì˜¤ ë§¥ë½(Safety Core/Cash/Market Regime)ì„ ìš°ì„  ì ìš©í•˜ë˜, ë°ì´í„°ê°€ ì—†ëŠ” í•­ëª©ì€ 'N/A'.

[HALLUCINATION ZERO-TOLERANCE RULES]:
- ì œê³µëœ ë°ì´í„°(ETF_Data/Scanner_Data)ë§Œ ì‚¬ìš©. ì¦ê±° ë°– ìˆ«ì/ì‚¬ì‹¤ ì°½ì‘ ê¸ˆì§€.
- ìˆ«ìë¥¼ ì–¸ê¸‰í•  ê²½ìš°, ë°˜ë“œì‹œ ì…ë ¥ ë°ì´í„°ì—ì„œ ê·¸ëŒ€ë¡œ ì¸ìš©í•  ê²ƒ(ì¬ê³„ì‚°/ì¬ì„œìˆ  ê¸ˆì§€).
- ë°ì´í„°ê°€ ì—†ìœ¼ë©´ UNKNOWN ë˜ëŠ” N/Aë¡œ í‘œê¸°.

[1] í¬íŠ¸í´ë¦¬ì˜¤ ë§¥ë½
- Cash Ratio: ${cashRatioStr}
- Safety Core Ratio: ${safetyCoreRatioStr}
- Market Regime: ${marketRegimeStr}

[2] ETF ë°ì´í„° (ETF_Data ìš°ì„ )
- Ticker: ${ticker}
- AssetType: ETF
- Underlying: ${curUnderlying || ticker}
- ETF_Data: ${JSON.stringify(etfDataObj)}
- Technicals(Scanner_Data ê¸°ë°˜): ${JSON.stringify(techData)}
- Risk/Drawdown: Sharpe=${data.sharpe || 'N/A'}, Volatility=${data.volatility || 'N/A'}, MDD=${data.mdd || 'N/A'}
- Trend: SMA20=${data.sma20 || 'N/A'}, SMA50=${data.sma50 || 'N/A'}, SMA200=${data.sma200 || 'N/A'}, RSI=${data.rsi || 'N/A'}

[3] ìš”ì²­ ì¶œë ¥ í˜•ì‹
- DECISION: BUY / HOLD / SELL ì¤‘ í•˜ë‚˜
- BIAS_GRADE: A~F
- BIAS_SCORE: BUY_xx_SELL_xx í˜•íƒœ (í•© 100)
- (ë³¸ë¬¸) ETF íŠ¹ì„±(ì§€ìˆ˜ ë…¸ì¶œ, ë¹„ìš©, ë¶„ë°°, ë² íƒ€, ë³€ë™ì„±/ì¶”ì„¸/ë‚™í­) ê¸°ë°˜ìœ¼ë¡œ ì„œìˆ 
- (Action Plan) ë§¤ìˆ˜/ì¶”ê°€ë§¤ìˆ˜/ì†ì ˆ/ë¦¬ë°¸ëŸ°ì‹± íŠ¸ë¦¬ê±°ë¥¼ ìˆ˜ì¹˜ ê¸°ë°˜ìœ¼ë¡œ ì œì‹œ
- (Self-Check) ê·¼ê±°ëŠ” ì œê³µëœ ë°ì´í„°ë§Œ ì‚¬ìš©(ì°½ì‘ ê¸ˆì§€), ëª¨ë¥´ëŠ” ê°’ì€ 'N/A'ë¡œ í‘œì‹œ
        `;
      } else {
      // --- ê°€ê²© ë ˆë²¨(ìë™ ê³„ì‚°) : ë¹„ì „ë¬¸ê°€ìš© ì§„ì…/ì¶”ê°€ë§¤ìˆ˜/ë¶„í• ë§¤ë„/ì†ì ˆ ë¼ì¸ ---
      const _priceNum_calc = safeNumber(data.currentPrice ?? data.price ?? data.Price);
      const _sma20_calc = safeNumber(data.sma20 ?? data.SMA20);
      const _sma50_calc = safeNumber(data.sma50 ?? data.SMA50);
      const _sma200_calc = safeNumber(data.sma200 ?? data.SMA200);
      const _volatility_calc = safeNumber(data.volatility ?? data.Volatility);

      const _mr_raw = String(marketRegimeStr || "").toUpperCase();
      const _mr_isUp = _mr_raw.indexOf("UPTREND") >= 0;
      const _mr_isDown = _mr_raw.indexOf("DOWNTREND") >= 0;
      const _mr_isVol = _mr_raw.indexOf("VOLATILE") >= 0;

      let _stopPct_base = 0.08; // ê¸°ë³¸ 8%
      if (_volatility_calc > 0) {
        if (_volatility_calc >= 80) _stopPct_base = 0.14;
        else if (_volatility_calc >= 50) _stopPct_base = 0.12;
        else if (_volatility_calc >= 30) _stopPct_base = 0.10;
        else _stopPct_base = 0.08;
      }

      // ì‹œì¥ ë ˆì§ì— ë”°ë¥¸ ë³´ìˆ˜/ê³µê²© ì¡°ì • (Bì•ˆ: ë ˆì§ ê¸°ë°˜)
      let _entryAdj = 1.00;
      let _stopAdj = 1.00;
      let _tpAdj = 1.00;

      if (_mr_isUp) {          // ìƒìŠ¹ì¥: ì§„ì…ì€ ì–•ê²Œ(í˜„ì¬ê°€/ë‹¨ê¸°ì„ ), ì†ì ˆì€ íƒ€ì´íŠ¸
        _entryAdj = 0.99;
        _stopAdj = 0.85;
        _tpAdj = 1.05;
      } else if (_mr_isDown) { // í•˜ë½ì¥: ì§„ì…ì€ ê¹Šê²Œ(ì¤‘ê¸°/ì¥ê¸°ì„ ), ì†ì ˆì€ ë„“ê²Œ
        _entryAdj = 0.95;
        _stopAdj = 1.20;
        _tpAdj = 0.90;
      } else if (_mr_isVol) {  // ë³€ë™ì¥: ì§„ì…ì€ ë¶„í• /ë³´ìˆ˜, ì†ì ˆ/ìµì ˆì€ ì¤‘ë¦½
        _entryAdj = 0.97;
        _stopAdj = 1.10;
        _tpAdj = 0.95;
      }

      const _stopPct_final = Math.min(0.25, Math.max(0.03, _stopPct_base * _stopAdj));

      // ê¸°ì¤€ ì§„ì…ê°€(1ì°¨): ë‹¨ê¸°ì„ /í˜„ì¬ê°€/ì¤‘ê¸°ì„  ì¤‘ 'ë ˆì§ì— ë§ëŠ”' ê¸°ì¤€ ì„ íƒ
      const _anchor_up = (_sma20_calc > 0) ? _sma20_calc : _priceNum_calc;
      const _anchor_down = (_sma50_calc > 0) ? _sma50_calc : ((_sma200_calc > 0) ? _sma200_calc : _priceNum_calc);
      const _anchor_vol = (_sma20_calc > 0 && _sma50_calc > 0) ? Math.min(_sma20_calc, _sma50_calc) : (_sma20_calc > 0 ? _sma20_calc : (_sma50_calc > 0 ? _sma50_calc : _priceNum_calc));

      let _anchor = _priceNum_calc;
      if (_mr_isUp) _anchor = _anchor_up;
      else if (_mr_isDown) _anchor = _anchor_down;
      else if (_mr_isVol) _anchor = _anchor_vol;

      const _entryPrice_calc = (_anchor > 0) ? (_anchor * _entryAdj) : 0;

      // ì¶”ê°€ë§¤ìˆ˜(2ì°¨/3ì°¨): 1ì°¨ ëŒ€ë¹„ -3% / -6% (í•˜ë½ì¥ì€ -4% / -8%)
      const _add1_pct = _mr_isDown ? 0.04 : 0.03;
      const _add2_pct = _mr_isDown ? 0.08 : 0.06;

      const _addBuy1_calc = (_entryPrice_calc > 0) ? (_entryPrice_calc * (1 - _add1_pct)) : 0;
      const _addBuy2_calc = (_entryPrice_calc > 0) ? (_entryPrice_calc * (1 - _add2_pct)) : 0;

      // ë¶„í• ë§¤ë„(ìµì ˆ): +8% / +15% (ìƒìŠ¹ì¥ì€ +10%/+18%, í•˜ë½ì¥ì€ +6%/+12%)
      let _tp1_pct = 0.08, _tp2_pct = 0.15;
      if (_mr_isUp) { _tp1_pct = 0.10; _tp2_pct = 0.18; }
      else if (_mr_isDown) { _tp1_pct = 0.06; _tp2_pct = 0.12; }

      _tp1_pct = _tp1_pct * _tpAdj;
      _tp2_pct = _tp2_pct * _tpAdj;

      const _tp1_calc = (_entryPrice_calc > 0) ? (_entryPrice_calc * (1 + _tp1_pct)) : 0;
      const _tp2_calc = (_entryPrice_calc > 0) ? (_entryPrice_calc * (1 + _tp2_pct)) : 0;

      // ì†ì ˆ ë¼ì¸: 1ì°¨ ì§„ì…ê°€ ê¸°ì¤€
      const _stopLoss_calc = (_entryPrice_calc > 0) ? (_entryPrice_calc * (1 - _stopPct_final)) : 0;

      const ENTRY_PRICE_TXT = (_entryPrice_calc > 0) ? `$${_entryPrice_calc.toFixed(2)}` : "N/A";
      const ADD_BUY1_TXT = (_addBuy1_calc > 0) ? `$${_addBuy1_calc.toFixed(2)}` : "N/A";
      const ADD_BUY2_TXT = (_addBuy2_calc > 0) ? `$${_addBuy2_calc.toFixed(2)}` : "N/A";
      const TP1_TXT = (_tp1_calc > 0) ? `$${_tp1_calc.toFixed(2)}` : "N/A";
      const TP2_TXT = (_tp2_calc > 0) ? `$${_tp2_calc.toFixed(2)}` : "N/A";
      const STOP_LOSS_TXT = (_stopLoss_calc > 0) ? `$${_stopLoss_calc.toFixed(2)}` : "N/A";

// âœ… STEP4: Final_Report(ê·¼ê±° ì´ì§‘í•©) ë¨¼ì € ìƒì„± â†’ ë³´ê³ ì„œ(Hì—´)ëŠ” ì´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‘ì„±
let finalReportText = "";
try {
  const _final = buildFinalReportForRow_(sheet.getName(), row);
  if (_final && _final.text) finalReportText = String(_final.text);
} catch (e) {
  Logger.log("Final_Report build failed (row " + row + "): " + e.toString());
}

      prompt = `
        ${getSystemPrompt(newsObj.legalRisk, allowedActions, brokerageAssetsUSD, data.currentPrice, totalQuantity, currentWeight, TARGET_ANNUAL_RETURN)} 

        [CRITICAL DATA OVERRIDE - DO NOT INVENT]:
[HALLUCINATION ZERO-TOLERANCE RULES]:
- ì¦ê±°(Exhibits) ë°–ì˜ ìˆ«ì/ì‚¬ì‹¤/ì§€í‘œ/ê³ ìœ ëª…ì‚¬ ìƒì„± ê¸ˆì§€.
- ìˆ«ì/ìˆ˜ì¹˜ëŠ” ë°˜ë“œì‹œ Exhibits ê°’ì„ ê·¸ëŒ€ë¡œ ì¸ìš©í•˜ê³  (E#)ë¥¼ ë¶™ì¼ ê²ƒ. ì¬ê³„ì‚°/ì¬ì„œìˆ  ê¸ˆì§€.
- Exhibitsì— ì—†ëŠ” í•­ëª©ì€ UNKNOWN ë˜ëŠ” N/Aë¡œë§Œ í‘œê¸°.
- E# ì¸ìš©ì´ ì—†ëŠ” ì£¼ì¥ì€ CEOê°€ REJECTED_CLAIMSë¡œ ê¸°ê°í•œë‹¤.

        - **Safety Core**: ${safetyCoreString} (Use this exact value)
        - **Risk Tier**: ${riskTier} (If Normal, do not say Critical)
        - **Current Price**: $${data.currentPrice}
        - **User's Portfolio Safety Ratio**: ${safetyRatio.toFixed(3)}
        - **RSI**: ${rsiVal} (Use this EXACT value. Do NOT calculate.)

        ${marketRegimeInfo} 

        [Date]: ${today}
        [Target]: ${ticker}
        
        [ğŸ’° MACRO]: ${marketContext} (QT: ${qtStatus})
        [ğŸ’¼ PORTFOLIO]: ${portfolioSummary}
        ${coreEngineBrief}
        [Position]: ${data.quantity > 0 ? "Holding" : "Watchlist (Zero Qty)"}

        ${scannerPromptSection}
        [Industry]: ${industryInfo}
        
        [Recommendation Data]:
        - **Alternative Candidate (Scanner Only):** ${scannerRecommendation}

        [Detailed Financial Data]:
        - Quant: Sharpe ${realMetrics.sharpe}, MDD ${realMetrics.mdd}, Vol ${realMetrics.vol} ([SRC: ${realMetrics.source}])
        - Earn Yield: ${finData.earningsYield}
        - RSI: ${techData.rsi}, Stoch: ${techData.stoch}
        - Valuation: P/E ${finData.per}, P/B ${finData.pbr}, ROE ${finData.roe}
        - Target: ${finData.target}
        
[EXHIBITS - USE ONLY THESE NUMBERS/FACTS]:
- E1 Safety Core: ${safetyCoreString}
- E2 Cash Ratio: ${cashRatioStr}
- E3 Risk Tier: ${riskTier}
- E4 Current Price: $${data.currentPrice}
- E5 RSI: ${rsiVal}
- E6 Sharpe: ${realMetrics.sharpe}
- E7 MDD: ${realMetrics.mdd}
- E8 Volatility: ${realMetrics.vol}
- E9 P/E: ${finData.per}
- E10 Earnings Yield: ${finData.earningsYield}
- E11 Market Regime: ${marketRegimeStr}
- E14 ê°€ê²© ë ˆë²¨(ìë™ ê³„ì‚°):
  - ì§„ì…ê°€(1ì°¨): ${ENTRY_PRICE_TXT}
  - ì¶”ê°€ë§¤ìˆ˜(2ì°¨): ${ADD_BUY1_TXT}
  - ì¶”ê°€ë§¤ìˆ˜(3ì°¨): ${ADD_BUY2_TXT}
  - ë¶„í• ë§¤ë„(1ì°¨ ìµì ˆ): ${TP1_TXT}
  - ë¶„í• ë§¤ë„(2ì°¨ ìµì ˆ): ${TP2_TXT}
  - ì†ì ˆ ë¼ì¸: ${STOP_LOSS_TXT}
  - ê³„ì‚° ê·¼ê±°: í˜„ì¬ê°€/ì´í‰ì„ (SMA20/50/200)/ë³€ë™ì„±/Market Regime
- E12 Allowed Actions: [${allowedActions.join(", ")}]


[FINAL_REPORT_RATIONALE - WHY THIS REPORT EXISTS]:
- ì•„ë˜ ë‚´ìš©ì€ 'ë³´ê³ ì„œë¥¼ ì‘ì„±í•œ ì´ìœ (ê°€ì„¤ ì„ íƒ + Python/Scanner + E14 ì…ë ¥)'ì˜ ì´ì§‘í•©ì´ë‹¤.
- ë„ˆëŠ” ì´ ê·¼ê±°ë¥¼ ë°”íƒ•ìœ¼ë¡œ AvengersReportë¥¼ ì‘ì„±í•˜ë˜, ê·¼ê±°ì— ì—†ëŠ” ì‚¬ì‹¤/ìˆ«ì ìƒì„± ê¸ˆì§€.
- Final_Report í…ìŠ¤íŠ¸:
${finalReportText}


        [Bias Score]: Grade ${biasResult.grade} (Buy ${biasResult.buyRatio}% / Sell ${biasResult.sellRatio}%)
        
        [MISSION]:
1. ì¶œë ¥ì€ ë°˜ë“œì‹œ MARKDOWN í˜•ì‹ì´ì–´ì•¼ í•˜ë©°, ì•„ë˜ ì„¹ì…˜ì„ **ëª¨ë‘** í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤. (ì„¹ì…˜ ì œëª©ì€ **í•œ ê¸€ìë„ ë³€ê²½ ê¸ˆì§€**)

## CEO ìµœì¢… ê²°ì •
- ë°˜ë“œì‹œ ì²« ì¤„ì—: DECISION= / BIAS_GRADE= / BIAS_SCORE= ë¥¼ í¬í•¨
- CEO(Jamie Dimon)ëŠ” **ì¬íŒì¥**ì´ë‹¤. ì•„ë˜ í˜•ì‹ì„ ì—„ìˆ˜í•œë‹¤(ì¶”ê°€ ë¬¸ì¥ ê¸ˆì§€):
  1) VERDICT: (DECISIONê³¼ ë™ì¼í•œ í•œ ë‹¨ì–´)
  2) KEY_EVIDENCE: E# 3~7ê°œ
  3) REJECTED_CLAIMS: (E# ì—†ëŠ” ì£¼ì¥/ìˆ«ì ì°½ì¡°/ê·¼ê±° ë¶ˆì¶©ë¶„ ì£¼ì¥ ê¸°ê°)
  4) WHAT WOULD CHANGE MY MIND: (ì œê³µ ë°ì´í„°ë¡œë§Œ ì¡°ê±´ 2~4ê°œ)
  5) ACTION PLAN:
- ê°€ê²© ë ˆë²¨ì€ E14ë¥¼ ê·¸ëŒ€ë¡œ ì¸ìš©(ìƒˆ ìˆ«ì ìƒì„± ê¸ˆì§€)
-  (2~5ì¤„, ì œê³µ ë°ì´í„° ìˆ˜ì¹˜ ê¸°ë°˜)

- í˜„ì¬ ë¹„ì¤‘/ëª©í‘œ ë¹„ì¤‘/ì¡°ê±´ë¶€ ì¬ì§„ì… ë˜ëŠ” ì¶”ê°€ë§¤ìˆ˜ ì¡°ê±´/ë¦¬ìŠ¤í¬ ì™„í™” ì²´í¬ë¦¬ìŠ¤íŠ¸

## ê²½ìŸì‚¬ ë° ëŒ€ì²´ íˆ¬ì
- Competitors / Alternativesë¥¼ ê°„ë‹¨íˆ ì œì‹œ

## ì‹œì¥ ë ˆì§ & í˜„ê¸ˆ ì „ëµ
- í˜„ì¬ ì‹œì¥ ë ˆì§ê³¼ í˜„ê¸ˆ(ë˜ëŠ” ì•ˆì „ìì‚°) ë¹„ì¤‘ ìš´ì˜ ì›ì¹™

## ìƒì„¸ ë°ì´í„° ê²€ì¦
- Sharpe/MDD/Vol/RSI ë“± ì œê³µ ë°ì´í„° ê¸°ë°˜ì˜ ê¸°ìˆ ì /ë¦¬ìŠ¤í¬ í•´ì„(ìˆ«ì ì°½ì¡° ê¸ˆì§€)

## í•µì‹¬ ë…¼ìŸ ìš”ì•½
- ì™œ ê·¸ë ‡ê²Œ ê²°ì •ë˜ëŠ”ì§€ í•µì‹¬ ë¦¬ìŠ¤í¬/ê·¼ê±°ë¥¼ ìš”ì•½

## ê°œë³„ ì¢…ëª© í€ë”ë©˜í„¸ ìš”ì•½
- P/E, P/B, ROE ë“± ì œê³µëœ í€ë”ë©˜í„¸ í•­ëª©ì˜ í•´ì„(ì—†ìœ¼ë©´ ì—†ë‹¤ê³  ëª…ì‹œ)


## Self-Check
- Evidence Audit í˜•ì‹(ì¶”ê°€ ë¬¸ì¥ ê¸ˆì§€):
  - NUMERIC_CHECK: ëª¨ë“  ìˆ«ìì— (E#) ì¸ìš©ì´ ë¶™ì–´ìˆëŠ”ê°€? YES/NO
  - OUT_OF_SCOPE: ì¦ê±°(Exhibits)ì— ì—†ëŠ” ìˆ«ì/ì‚¬ì‹¤ì„ ìƒì„±í–ˆëŠ”ê°€? YES/NO (YESë©´ í•´ë‹¹ ë¬¸ì¥ ì œê±° í›„ UNKNOWNìœ¼ë¡œ êµì²´)
  - CONFLICT_CHECK: ì„œë¡œ ì¶©ëŒí•˜ëŠ” ë°ì´í„°ê°€ ìˆëŠ”ê°€? YES/NO (YESë©´ ì±„íƒí•œ ê·¼ê±° E# ëª…ì‹œ)
  - DECISION_SUPPORT: VERDICTë¥¼ ì§€ì§€í•˜ëŠ” KEY_EVIDENCEê°€ 3ê°œ ì´ìƒì¸ê°€? YES/NO
  - UNKNOWN_USED: ëª¨ë¥´ëŠ” ê°’ì€ UNKNOWN/N/Aë¡œ ì²˜ë¦¬í–ˆëŠ”ê°€? YES/NO
 (#### [The Debate])
#### [The Debate]
- ì•„ë˜ PERSONA DEFINITIONSì— ìˆëŠ” **ëª¨ë“  í˜ë¥´ì†Œë‚˜**ê°€ ë°˜ë“œì‹œ 1íšŒì”© ë°œì–¸í•´ì•¼ í•©ë‹ˆë‹¤.
- ê° í˜ë¥´ì†Œë‚˜ ë°œì–¸ì€ ì•„ë˜ 6ì¤„ ê³ ì • í˜•ì‹ë§Œ í—ˆìš©(ì¶”ê°€ ë¬¸ì¥/ì¶”ê°€ ì¤„ ê¸ˆì§€):
  1) PERSONA: (ì´ë¦„/ì—­í• )
  2) STANCE: BUY | HOLD | SELL | WAIT
  3) CONF: 0-100
  4) EVIDENCE: E#,E# (ìµœì†Œ 2ê°œ)
  5) RISK: (E# ê¸°ë°˜ í•œ ì¤„)
  6) UNKNOWN: (ì—†ìœ¼ë©´ NONE)
- ìˆ«ì/ì‚¬ì‹¤ì€ ë°˜ë“œì‹œ Exhibitsì˜ ê°’ì„ **ê·¸ëŒ€ë¡œ ì¸ìš©**í•˜ê³  (E#)ë¥¼ ë¶™ì¸ë‹¤. ìˆ«ì ì¬ê³„ì‚°/ì¬ì„œìˆ  ê¸ˆì§€.
- ë§ˆì§€ë§‰ì—ëŠ” ë°˜ë“œì‹œ CEO(Jamie Dimon)ê°€ **ì¬íŒì¥ íŒê²°ë¬¸**ì„ ì•„ë˜ í˜•ì‹ìœ¼ë¡œ ë§ˆë¬´ë¦¬(ì¶”ê°€ ë¬¸ì¥ ê¸ˆì§€):
  - CEO_VERDICT: (DECISIONê³¼ ë™ì¼)
  - CEO_KEY_EVIDENCE: E# 3~7ê°œ
  - CEO_REJECTED_CLAIMS: (ê¸°ê° ì‚¬ìœ  1~3ê°œ)

2. **Translation**: If any English content is included, translate it to Korean.
3. **Formatting**: Use clear bullet points and short paragraphs where appropriate.
      `;
      }

      // STEP4_VERIFY: Tail Injection (callGemini ì§ì „, ì„ íƒí–‰ë¶„ì„ REFCTX_MODE=1ì¼ ë•Œë§Œ)
      try {
        const _refMode = PropertiesService.getScriptProperties().getProperty('REFCTX_MODE');
        if (_refMode === '1') {
          const _sp = PropertiesService.getScriptProperties();
          _sp.setProperty('REFCTX_TARGET', String(ticker || '').trim().toUpperCase());
          const _refCtx = getLatestReferenceContext5Lines_();
          _sp.deleteProperty('REFCTX_TARGET');
          if (_refCtx && String(_refCtx).trim() !== '') {
            prompt += '\n\n' + _refCtx;
            Logger.log('STEP4_VERIFY appended REFERENCE_CONTEXT tail (len=' + String(_refCtx).length + ')');
            Logger.log('STEP4_VERIFY finalPrompt tail(<=60 lines)\n' + prompt.split('\n').slice(-60).join('\n'));
          } else {
            Logger.log('STEP4_VERIFY REFERENCE_CONTEXT empty (no WATCH/SMALL_BET found or pick failed)');
          }
        }
      } catch (e) {
        Logger.log('STEP4_VERIFY Tail Injection ERROR: ' + e);
      }

      let advice = callGemini(prompt, config.MODEL_NAME); 
      
      // [PATCH] HTTP 429(Quota/Rate limit) ìµœì†Œ ëŒ€ì‘: ê¶Œì¥ retryDelay ê¸°ë°˜ ëŒ€ê¸° í›„ 1íšŒ ì¬ì‹œë„ (ì¸ë¼ì¸ ì²˜ë¦¬)
      let _adviceStr = (advice === null || advice === undefined) ? "" : String(advice);
      if (_adviceStr.includes("HTTP 429") || _adviceStr.includes('"code": 429') || _adviceStr.toLowerCase().includes("quota")) {
          // 1) API ì‘ë‹µì— í¬í•¨ëœ retryDelay (ì˜ˆ: "retryDelay":"17s") ìš°ì„  ì ìš©
          // 2) ì—†ìœ¼ë©´ "Please retry in 17.8s" íŒ¨í„´ ì ìš©
          // 3) ëª¨ë‘ ì—†ìœ¼ë©´ ê¸°ë³¸ 20ì´ˆ ëŒ€ê¸°
          let _sleepMs = 20000;
          const _m1 = _adviceStr.match(/"retryDelay"\s*:\s*"([0-9]+)s"/i);
          if (_m1 && _m1[1]) {
              _sleepMs = (parseInt(_m1[1], 10) + 3) * 1000; // buffer +3s
          } else {
              const _m2 = _adviceStr.match(/retry\s+in\s+([0-9.]+)s/i);
              if (_m2 && _m2[1]) {
                  _sleepMs = (Math.ceil(parseFloat(_m2[1])) + 3) * 1000; // buffer +3s
              }
          }
          const _refMode = (PropertiesService.getScriptProperties().getProperty("REFCTX_MODE") === "1");
          if (_refMode) {
              _sleepMs = Math.min(_sleepMs, 5000);
          }
          Utilities.sleep(_sleepMs);
          advice = callGemini(prompt, config.MODEL_NAME);
          _adviceStr = (advice === null || advice === undefined) ? "" : String(advice);
      }

      // [PATCH] Gemini ì‘ë‹µ êµ¬ì¡° ë¶ˆì•ˆì •(í›„ë³´ ì—†ìŒ) ëŒ€ì‘: ì§§ì€ ëŒ€ê¸° í›„ 1íšŒ ì¬ì‹œë„ (ì¸ë¼ì¸ ì²˜ë¦¬)
      if (_adviceStr.startsWith("âŒ Gemini Invalid Response Structure") || _adviceStr.startsWith("âŒ Gemini Empty Response")) {
          Utilities.sleep(3000);
          advice = callGemini(prompt, config.MODEL_NAME);
          _adviceStr = (advice === null || advice === undefined) ? "" : String(advice);
      }

      
      if (advice === null || advice === undefined || String(advice).trim() === "" || String(advice).startsWith("âŒ")) {
          signalCell.setValue("ğŸš« ì‘ë‹µ ì‹¤íŒ¨");
          const _failBody = (advice === null || advice === undefined || String(advice).trim() === "") ? "EMPTY" : String(advice);
          statusCell.setValue("âš ï¸ ì˜¤ë¥˜(ì‘ë‹µ ì‹¤íŒ¨): " + _failBody).setWrap(true);
          continue;
      }
      
      advice = sanitizeSafetyCoreText(advice, safetyRatio, SAFETY_CORE_MIN, riskTier);

      // [PATCH] Tenbagger Observation (ê´€ì°° ì „ìš©) ì„¹ì…˜ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ê´€ì°° ì„¹ì…˜ì„ ì¶”ê°€ (AvengersReport.html í…œí”Œë¦¿ í˜¸í™˜)
      const _tbHeaderRe = /^##\s*.*Tenbagger Observation/im;
      if (!_tbHeaderRe.test(String(advice))) {
        advice = String(advice).trimEnd() + "\n\n## ğŸ‘ Tenbagger Observation (ê´€ì°° ì „ìš©)\n" +
          "- **ëª©ì :** 'í…ë²„ê±° í›„ë³´'ë¥¼ ë‹¹ì¥ ë§¤ìˆ˜í•˜ë¼ëŠ” ëœ»ì´ ì•„ë‹ˆë¼, ì¶”ì í•´ì•¼ í•  ì¡°ê±´ê³¼ ë¦¬ìŠ¤í¬ë¥¼ ëª…í™•íˆ í•˜ê¸° ìœ„í•œ ê´€ì°° ì„¹ì…˜.\n" +
          "- **ê´€ì°° ì²´í¬ë¦¬ìŠ¤íŠ¸(ì˜ˆì‹œ):**\n" +
          "  1) **ì§€í‘œ ê°œì„ :** ROE/ë§ˆì§„/í˜„ê¸ˆíë¦„/ë§¤ì¶œ ì„±ì¥ë¥  ì¤‘ ìµœì†Œ 2ê°œê°€ **ì—°ì† ê°œì„ **ë˜ëŠ”ê°€\n" +
          "  2) **ê°€ê²©/ìˆ˜ê¸‰:** 52ì£¼ ê³ ì  íšŒë³µ, ê±°ë˜ëŸ‰ ì¦ê°€, ì¶”ì„¸ ì „í™˜(Downtrendâ†’Uptrend) ì‹ í˜¸ê°€ ìˆëŠ”ê°€\n" +
          "  3) **ë¦¬ìŠ¤í¬ í•œë„:** ë‹¨ì¼ ì¢…ëª© ì†ì‹¤ì´ Total Net Worthì˜ 1~2%ë¥¼ ë„˜ì§€ ì•Šë„ë¡ í¬ì§€ì…˜ í¬ê¸° ì œí•œ\n" +
          "  4) **í• ë£¨ì‹œë„¤ì´ì…˜ ë°©ì§€:** ì‹œíŠ¸ì— ì—†ëŠ” ìˆ«ì(ë°¸ë¥˜ì—ì´ì…˜, ëª©í‘œê°€, ì¬ë¬´ ìˆ˜ì¹˜)ë¥¼ ìƒˆë¡œ ë§Œë“¤ì§€ ì•ŠìŒ\n" +
          "- **ë‹¤ìŒ ì•¡ì…˜:** ìœ„ ì¡°ê±´ì´ ì¶©ì¡±ë˜ê¸° ì „ê¹Œì§€ëŠ” 'ê´€ë§' ë˜ëŠ” 'ì†Œì•¡ ê´€ì°°'ë¡œ ìœ ì§€.\n";
      }

      const headerSection = advice.substring(0, 1000); 
      const decisionKeyMatch = headerSection.match(/DECISION\s*=\s*([^\n]+)/i);
      let finalDecisionText = decisionKeyMatch ? decisionKeyMatch[1].trim().replace(/\s*(.*)/, '').trim() : "ê´€ë§";
      
      if (!/^DECISION\s*=/m.test(advice)) advice = `DECISION=${finalDecisionText}\n` + advice;

      let signal = "ğŸ¤” ê´€ë§";
      if (finalDecisionText.includes("ì „ëŸ‰ë§¤ë„") || finalDecisionText.includes("ì¶•ì†Œ")) signal = "â„ï¸ ë§¤ë„/ì¶•ì†Œ";
      else if (finalDecisionText.includes("ê°•ë ¥ë§¤ìˆ˜")) signal = "ğŸ”¥ ê°•ë ¥ë§¤ìˆ˜";
      else if (finalDecisionText.includes("ë¶„í• ë§¤ìˆ˜") || finalDecisionText.includes("ì§„ì…")) signal = "âœ… ë¶„í• ë§¤ìˆ˜/ì§„ì…";
      
      signalCell.setValue(signal);

      // âœ… Final_Report ì‹œíŠ¸ë¥¼ ë¨¼ì € ë§Œë“¤ê³ (ë‹¨ì¼ ì›ì²œ), ê·¸ ë‚´ìš©ì„ ê¸°ë°˜ìœ¼ë¡œ Hì—´ ë³´ê³ ì„œë¥¼ ì‘ì„±í•œë‹¤.
      // 1) AI ê²°ê³¼(advice)ëŠ” ê·¸ëŒ€ë¡œ ë³´ì¡´í•˜ë˜, "ì´ì§‘í•©ë³´ê³ ì„œ(Final_Report)"ë¥¼ ë§Œë“ ë‹¤.
      // 2) Hì—´ì€ Final_Reportì˜ ReportTextë¥¼ ê·¸ëŒ€ë¡œ ì¶œë ¥í•œë‹¤. (AvengersReport ì„¹ì…˜ íŒŒì„œ í˜¸í™˜)
      const finalReportText = [
        `# FINAL_REPORT: ${ticker}`,
        `- CreatedAt: ${new Date().toLocaleString()}`,
        `- AssetType: ${assetType || ""}`,
        `- Underlying: ${underlying || ""}`,
        `- MarketRegime(E11): ${marketRegimeStr || ""}`,
        "",
        "## ğŸ“¥ Python/Scanner Metrics",
        `- Flow_Score: ${(scanner && (scanner["Flow_Score"] !== undefined ? scanner["Flow_Score"] : (scanner["flow_score"] !== undefined ? scanner["flow_score"] : "")))}`,
        `- Failure_Cost: ${(scanner && (scanner["Failure_Cost"] !== undefined ? scanner["Failure_Cost"] : (scanner["failure_cost"] !== undefined ? scanner["failure_cost"] : "")))}`,
        `- Leveraged_Diagnostics: ${(scanner && (scanner["Leveraged_Diagnostics"] !== undefined ? scanner["Leveraged_Diagnostics"] : (scanner["leveraged_diagnostics"] !== undefined ? scanner["leveraged_diagnostics"] : "")))}`,
        `- Exit_Risk_Speed: ${(scanner && (scanner["Exit_Risk_Speed"] !== undefined ? scanner["Exit_Risk_Speed"] : (scanner["exit_risk_speed"] !== undefined ? scanner["exit_risk_speed"] : "")))}`,
        "",
        "## ğŸ¯ E14 Price Levels (Calculated)",
        `- ENTRY_1: ${ENTRY_PRICE_TXT}`,
        `- ADD_2: ${ADD_BUY1_TXT}`,
        `- ADD_3: ${ADD_BUY2_TXT}`,
        `- TP_1: ${TP1_TXT}`,
        `- TP_2: ${TP2_TXT}`,
        `- STOP_HARD: ${STOP_LOSS_TXT}`,
        "",
        "## ğŸ§  Avengers Analysis (AI Output)",
        String(advice || "")
      ].join("\n");


      const frSheet = ensureFinalReportSheet();
      const frRow = appendFinalReportRow_(sheet.getName(), row, ticker, assetType, underlying, marketRegimeStr, scanner, finalReportText);
      const frText = frSheet.getRange(frRow, 12).getValue();
      statusCell.setValue(frText).setWrap(true);
const parsedLocal = parseDecisionAndBias(advice); 
      
      const autoTargetPct = calcTargetWeight(
        finalDecisionText, 
        riskTier, 
        realMetrics.vol, 
        realMetrics.mdd, 
        parsedLocal.bias
      );

      const currentTgt = sheet.getRange(row, 6).getValue();
      if (!currentTgt || currentTgt === 0 || String(currentTgt).trim() === "") {
         sheet.getRange(row, 6).setValue(autoTargetPct);
      }

    } catch (e) {
      signalCell.setValue("ğŸš« ì‘ë‹µ ì‹¤íŒ¨");
      statusCell.setValue("âš ï¸ ì˜¤ë¥˜: " + e.toString()).setWrap(true);
    }
  }
  
  buildDailyPortfolioSummary();
  
  Browser.msgBox("âœ… ë¶„ì„ ì™„ë£Œ (Summary & Target Weight Updated)");
}



/* ===============================
   ğŸ”µ AssetType-aware analysis trigger (ADD-ONLY)
   =============================== */

function ensureAssetMetaForRow_(sheet, rowIndex, ticker) {
  if (!sheet || !rowIndex) return;

  // Backward-compatible: older call sites may omit ticker.
  // In that case, infer ticker from column A ("ì¢…ëª©").
  if (!ticker) {
    try {
      ticker = String(sheet.getRange(rowIndex, 1).getValue() || '').trim();
    } catch (e) {
      ticker = '';
    }
  }

  if (!ticker) return;

  const lastCol = sheet.getLastColumn();
  const headers = sheet.getRange(1, 1, 1, lastCol).getValues()[0];

  let assetTypeCol = -1;
  let underlyingCol = -1;
  for (let c = 0; c < headers.length; c++) {
    const h = String(headers[c] || '').trim();
    if (h === 'AssetType') assetTypeCol = c + 1;
    if (h === 'Underlying') underlyingCol = c + 1;
  }
  if (assetTypeCol < 0 || underlyingCol < 0) return;

  const curAssetType = String(sheet.getRange(rowIndex, assetTypeCol).getValue() || '').trim();
  const curUnderlying = String(sheet.getRange(rowIndex, underlyingCol).getValue() || '').trim();

  // If already filled, do nothing
  if (curAssetType && curUnderlying) return;

  const t = String(ticker).trim().toUpperCase();

  // Minimal inference rules (restore expected behavior without external dependencies)
  let inferredType = curAssetType;
  let inferredUnderlying = curUnderlying;

  const leveragedMap = {
    'SMCX': 'SMCI',
    'TQQQ': 'QQQ',
    'SQQQ': 'QQQ',
    'SOXL': 'SOXX',
    'SOXS': 'SOXX',
    'UPRO': 'SPY',
    'SPXU': 'SPY',
    'TECL': 'XLK',
    'TECS': 'XLK',
    'FNGU': 'FNGS',
    'FNGD': 'FNGS'
  };

  if (leveragedMap[t]) {
    inferredType = inferredType || 'LEVERAGED_ETF';
    inferredUnderlying = inferredUnderlying || leveragedMap[t];
  } else if (t in {'QQQ':1,'SPY':1,'DIA':1,'IWM':1,'TLT':1,'GLD':1,'SLV':1,'XLK':1,'XLF':1,'XLE':1,'SOXX':1}) {
    inferredType = inferredType || 'ETF';
    inferredUnderlying = inferredUnderlying || t;
  } else {
    inferredType = inferredType || 'STOCK';
    inferredUnderlying = inferredUnderlying || t;
  }

  if (!curAssetType) sheet.getRange(rowIndex, assetTypeCol).setValue(inferredType);
  if (!curUnderlying) sheet.getRange(rowIndex, underlyingCol).setValue(inferredUnderlying);
}

/**
 * STEP4_VERIFY helper: pick latest WATCH/SMALL_BET from HypothesisBacklog and return
 * a tail block to be appended to finalPrompt right before callGemini.
 * Returns "" if no eligible row exists or sheet/headers missing.
 */
function getLatestReferenceContext5Lines_() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sh = ss.getSheetByName('HypothesisBacklog');
    if (!sh) return '';

    const lastRow = sh.getLastRow();
    const lastCol = sh.getLastColumn();
    if (lastRow < 2 || lastCol < 1) return '';

    const values = sh.getRange(1, 1, lastRow, lastCol).getValues();
    const headers = values[0].map(h => String(h).trim());

    const idxStatus = headers.indexOf('Status');
    const idxHypothesis = headers.indexOf('Hypothesis');
    const idxExposure = headers.indexOf('Exposure_Types');
    const idxFalsifiers = headers.indexOf('Fast_Falsifiers');

    if (idxStatus === -1) return '';

    // scan from latest row backwards
    const idxApplies = headers.indexOf('AppliesTo');
    const _target = String(PropertiesService.getScriptProperties().getProperty('REFCTX_TARGET') || '').trim().toUpperCase();

    if (idxApplies !== -1 && !_target) return '';

    let picked = null;

    // (priority) AppliesTo ë§¤ì¹­ì´ ê°€ëŠ¥í•˜ë©´ ìš°ì„  ì„ íƒ
    if (idxApplies !== -1 && _target) {
      for (let r = values.length - 1; r >= 1; r--) {
        const status = String(values[r][idxStatus]).trim();
        if (!(status === 'WATCH' || status === 'SMALL_BET')) continue;

        const raw = String(values[r][idxApplies] || '').trim().toUpperCase();
        if (!raw) continue;

        if (raw === 'ALL' || raw === '*') {
          picked = { row: values[r] };
          break;
        }

        const tokens = raw.split(/[^A-Z0-9]+/).map(s => String(s || '').trim()).filter(Boolean);
        for (let i = 0; i < tokens.length; i++) {
          if (tokens[i] === _target) {
            picked = { row: values[r] };
            break;
          }
        }
        if (picked) break;
      }
    }

        if (idxApplies !== -1 && !picked) return '';

// (fallback) AppliesTo ì»¬ëŸ¼ì´ ì—†ì„ ë•Œë§Œ: WATCH/SMALL_BET ì¤‘ ìµœì‹  1ê±´
    if (idxApplies === -1 && !picked) {
      for (let r = values.length - 1; r >= 1; r--) {
        const status = String(values[r][idxStatus]).trim();
        if (status === 'WATCH' || status === 'SMALL_BET') {
          picked = { row: values[r] };
          break;
        }
      }
    }

    if (!picked) return '';

    const hypo = (idxHypothesis !== -1) ? String(picked.row[idxHypothesis]).trim() : '';
    const exposure = (idxExposure !== -1) ? String(picked.row[idxExposure]).trim() : '';
    const falsRaw = (idxFalsifiers !== -1) ? String(picked.row[idxFalsifiers]).trim() : '';

    // Normalize falsifiers into up to 3 lines
    const falsParts = falsRaw
      ? falsRaw.split(/\r?\n|,|;|â€¢|Â·/).map(s => String(s).trim()).filter(Boolean)
      : [];
    const f1 = falsParts[0] || '';
    const f2 = falsParts[1] || '';
    const f3 = falsParts[2] || '';

    // NOTE: Block format is fixed by spec. Keep as tail-only context.
    return (
      "\n\n[REFERENCE_CONTEXT]\n" +
      "- Hypothesis: " + hypo + "\n" +
      "- Exposure: " + exposure + "\n" +
      "- Falsifier: " + f1 + "\n" +
      "- Falsifier: " + f2 + "\n" +
      "- Falsifier: " + f3 + "\n"
    );
  } catch (e) {
    // Do not throw: tail injection is optional. Return empty to preserve existing flow.
    return '';
  }
}

// ==========================================
// ğŸ“Œ [STEP 6] ê°€ì„¤ ë…¸ì¶œ êµ¬ì¡°(A/B/C) HTML ë·°
// ==========================================

function openHypothesisExposureView() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getActiveSheet();
  const sheetName = sheet.getName();

  if (sheetName !== 'HypothesisBacklog') {
    SpreadsheetApp.getUi().alert('HypothesisBacklog ì‹œíŠ¸ì—ì„œ ê°€ì„¤ í–‰ì„ ì„ íƒí•œ ë’¤ ì‹¤í–‰í•˜ì„¸ìš”.');
    return;
  }

  const row = sheet.getActiveCell().getRow();
  if (row < 2) {
    SpreadsheetApp.getUi().alert('í—¤ë”(1í–‰)ê°€ ì•„ë‹ˆë¼ ê°€ì„¤ ë°ì´í„° í–‰ì„ ì„ íƒí•˜ì„¸ìš”.');
    return;
  }

  const header = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const createdAtCol = header.indexOf('CreatedAt') + 1;
  const hypothesisCol = header.indexOf('Hypothesis') + 1;
  const appliesToCol = header.indexOf('AppliesTo') + 1;
  const statusCol = header.indexOf('Status') + 1;

  const exposureTypesCol = (header.indexOf('Exposure_Types') >= 0)
    ? (header.indexOf('Exposure_Types') + 1)
    : (header.indexOf('ExposureTypes') + 1);

  if (createdAtCol <= 0 || hypothesisCol <= 0) {
    SpreadsheetApp.getUi().alert('HypothesisBacklogì— CreatedAt ë˜ëŠ” Hypothesis í—¤ë”ê°€ ì—†ìŠµë‹ˆë‹¤.');
    return;
  }

  const createdAtVal = sheet.getRange(row, createdAtCol).getValue();
  const hypothesisVal = sheet.getRange(row, hypothesisCol).getValue();
  const appliesToVal = (appliesToCol > 0) ? sheet.getRange(row, appliesToCol).getValue() : '';
  const statusVal = (statusCol > 0) ? sheet.getRange(row, statusCol).getValue() : '';

  const hypothesisId = normalizeHypothesisId_(createdAtVal);

  // ------------------------------------------
  // STEP 6-A (í•„ìˆ˜): íŒì—… ì—´ ë•Œ Exposure_Map ìë™ ì‹œë”©
  // - í•´ë‹¹ ê°€ì„¤(HypothesisID)ì— ëŒ€í•´ A/B/C ê¸°ë³¸ í–‰ì´ ì—†ìœ¼ë©´ ìƒì„±
  // - ì½”ì–´ í”Œë¡œìš°ë¥¼ ê¹¨ì§€ ì•Šê¸° ìœ„í•´ ì‹¤íŒ¨ ì‹œ throw í•˜ì§€ ì•ŠìŒ
  // ------------------------------------------
  try {
    let mapSheet = ss.getSheetByName('Exposure_Map');
    if (!mapSheet) {
      mapSheet = ss.insertSheet('Exposure_Map');
    }

    // Ensure header exists
    const desiredHeader = [
      'HypothesisID',
      'Exposure_Type',
      'Role',
      'Structural_Reason',
      'ETF',
      'Stock',
      'AppliesTo',
      'Status',
      'Refute_Trigger',
      'Note'
    ];

    const mapLastRow = mapSheet.getLastRow();
    const mapLastCol = Math.max(mapSheet.getLastColumn(), desiredHeader.length);

    if (mapLastRow < 1) {
      mapSheet.getRange(1, 1, 1, desiredHeader.length).setValues([desiredHeader]);
    } else {
      const headerRow = mapSheet.getRange(1, 1, 1, mapLastCol).getValues()[0];
      const hasHypothesisID = headerRow.indexOf('HypothesisID') >= 0;
      const hasExposureType = headerRow.indexOf('Exposure_Type') >= 0;
      if (!hasHypothesisID || !hasExposureType) {
        // If sheet exists but header is unexpected, do not force-rewrite.
        // Exit silently to avoid breaking other flows.
      } else {
        // Seed missing A/B/C rows for this hypothesis
        const idxHypothesisID = headerRow.indexOf('HypothesisID');
        const idxExposureType = headerRow.indexOf('Exposure_Type');

        const values = (mapLastRow >= 2)
          ? mapSheet.getRange(2, 1, mapLastRow - 1, mapLastCol).getValues()
          : [];

        const existing = { A: false, B: false, C: false };
        for (let i = 0; i < values.length; i++) {
          const r = values[i];
          const rowId = normalizeHypothesisId_(r[idxHypothesisID]);
          if (rowId !== hypothesisId) continue;
          const t = (r[idxExposureType] || '').toString().trim().toUpperCase();
          if (t === 'A' || t === 'B' || t === 'C') existing[t] = true;
        }

        const applies = (appliesToVal || '').toString().trim() || 'ALL';

        const typesWanted = ['A', 'B', 'C']; // íŒì—…ì—ì„œ í•­ìƒ ë¶„ë¦¬ë·° ì œê³µ
        const headerLen = headerRow.length;
        const toAppend = [];

        for (let i = 0; i < typesWanted.length; i++) {
          const t = typesWanted[i];
          if (existing[t]) continue;

          const row = new Array(headerLen).fill('');
          row[idxHypothesisID] = hypothesisId;
          row[idxExposureType] = t;

          // Optional columns (if present)
          const idxRole = headerRow.indexOf('Role');
          const idxAppliesTo = headerRow.indexOf('AppliesTo');
          const idxStatus = headerRow.indexOf('Status');

          if (idxRole >= 0) {
            row[idxRole] = (t === 'A') ? 'Core' : (t === 'B') ? 'Time' : 'Option';
          }
          if (idxAppliesTo >= 0) row[idxAppliesTo] = applies;
          if (idxStatus >= 0) row[idxStatus] = 'DRAFT';

          toAppend.push(row);
        }

        if (toAppend.length > 0) {
          mapSheet.getRange(mapLastRow + 1, 1, toAppend.length, headerLen).setValues(toAppend);
        }
      }
    }
  } catch (e) {
    // Do not throw: exposure view must not break core flows.
  }

  const exposureTypesVal = (exposureTypesCol > 0) ? sheet.getRange(row, exposureTypesCol).getValue() : '';

  // STEP6: ensure Exposure_Map has seeded rows for this hypothesis (scaffold only)
  ensureExposureMapSeedRows_(hypothesisId, appliesToVal, exposureTypesVal);

  const exposureData = loadExposureMapByHypothesisId_(hypothesisId);

  const viewModel = {
    hypothesisId: hypothesisId,
    hypothesisSummary: (hypothesisVal || '').toString(),
    appliesTo: (appliesToVal || '').toString(),
    hypothesisStatus: (statusVal || '').toString(),
    exposures: exposureData // { A:[], B:[], C:[] }
  };

  const t = HtmlService.createTemplateFromFile('ExposureView');
  t.vm = viewModel;

  const html = t.evaluate()
    // NOTE: Google Sheets enforces a max modal size; we request a near-fullscreen
    // size to get as large as the platform allows.
    .setWidth(1480)
    .setHeight(920);

  SpreadsheetApp.getUi().showModalDialog(html, 'STEP 6 â€” Exposure View (A/B/C)');
}



// â° STEP6-3: ì¼ê°„ ë°˜ì¦ ì ê²€ íŠ¸ë¦¬ê±° ì„¤ì¹˜(ë©”ë‰´)
// - íŠ¸ë¦¬ê±°ëŠ” step6ScheduledRefuteCheckAllActive ë¥¼ ì¼ 1íšŒ ì‹¤í–‰
function installStep6RefuteDailyTrigger() {
  try {
    const handler = 'step6ScheduledRefuteCheckAllActive';
    const all = ScriptApp.getProjectTriggers();
    for (let i = 0; i < all.length; i++) {
      if (all[i].getHandlerFunction && all[i].getHandlerFunction() === handler) {
        ScriptApp.deleteTrigger(all[i]);
      }
    }

    // ê¸°ë³¸: ë§¤ì¼ ì˜¤ì „ 9ì‹œ(ìŠ¤í¬ë¦½íŠ¸ íƒ€ì„ì¡´ ê¸°ì¤€)
    ScriptApp.newTrigger(handler)
      .timeBased()
      .everyDays(1)
      .atHour(9)
      .create();

    SpreadsheetApp.getActiveSpreadsheet().toast('âœ… STEP6 ë°˜ì¦ ì ê²€ íŠ¸ë¦¬ê±° ì„¤ì¹˜ ì™„ë£Œ(ì¼ 1íšŒ)', 'STEP6', 4);
  } catch (e) {
    SpreadsheetApp.getActiveSpreadsheet().toast('âš ï¸ íŠ¸ë¦¬ê±° ì„¤ì¹˜ ì‹¤íŒ¨(ê¶Œí•œ/ë¡œê·¸ í™•ì¸)', 'STEP6', 4);
  }
}

// ğŸ§¾ STEP6-5: Refute_Events ì‹œíŠ¸ ì—´ê¸°/ìƒì„± (ì™¸ë¶€ ì´ë²¤íŠ¸ ì…ë ¥/ìˆ˜ì •ìš©)
function openStep6RefuteEventsSheet() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sh = ensureStep6RefuteEventsSheet_();
    if (sh) {
      ss.setActiveSheet(sh);
      SpreadsheetApp.getActiveSpreadsheet().toast('âœ… Refute_Events ì‹œíŠ¸ ì¤€ë¹„ ì™„ë£Œ', 'STEP6', 3);
    }
  } catch (e) {
    SpreadsheetApp.getActiveSpreadsheet().toast('âš ï¸ Refute_Events ì—´ê¸° ì‹¤íŒ¨(ë¡œê·¸ í™•ì¸)', 'STEP6', 3);
  }
}

function ensureStep6RefuteEventsSheet_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sh = ss.getSheetByName('Refute_Events');
  if (!sh) {
    sh = ss.insertSheet('Refute_Events');
    const headerRow = [
      'EventID',
      'OccurredAt',
      'HypothesisID',
      'Exposure_Type',
      'AppliesTo',
      'Event_Key',
      'Severity',
      'SourceTier',
      'Source',
      'Evidence_URL_1',
      'Evidence_URL_2',
      'Evidence_Title',
      'Evidence_PublishedAt',
      'Verified',
      'Note',
      'AI_Summary',
      'AI_Direction',
      'Direction'
    ];
    sh.getRange(1, 1, 1, headerRow.length).setValues([headerRow]);
  } else {

    // í—¤ë” ë³´ì •(append-only)
    const lastCol = sh.getLastColumn();
    const header = sh.getRange(1, 1, 1, Math.max(20, lastCol)).getValues()[0].map(v => String(v || '').trim());
    const required = ['EventID', 'OccurredAt', 'HypothesisID', 'Exposure_Type', 'AppliesTo', 'Event_Key', 'Severity', 'SourceTier', 'Source', 'Evidence_URL_1', 'Evidence_URL_2', 'Evidence_Title', 'Evidence_PublishedAt', 'Verified', 'Note',
'AI_Summary',
'AI_Direction',
'Direction'];
    for (let i = 0; i < required.length; i++) {
      if (header.indexOf(required[i]) === -1) {
        sh.getRange(1, header.length + 1).setValue(required[i]);
        header.push(required[i]);
      }
    }
  }
  return sh;
}


// ğŸ§­ STEP6-5 í™•ì¥: ì„ íƒ ê°€ì„¤ ê¸°ë°˜ ì—°ê´€ ì´ë²¤íŠ¸ í›„ë³´ ìë™ ìƒì„±(Verified=PENDING ê³ ì •)
// - HypothesisBacklogì—ì„œ ì„ íƒí•œ ê°€ì„¤ì˜ í…ìŠ¤íŠ¸(ê°€ì„¤/ê·¼ê±°/ë°˜ì¦ ë“±)ì—ì„œ í‚¤ì›Œë“œë¥¼ ê¸°ê³„ì ìœ¼ë¡œ ì¶”ì¶œ
// - Google News RSS ê²€ìƒ‰ ê²°ê³¼ì—ì„œ ì„œë¡œ ë‹¤ë¥¸ ì¶œì²˜ URL 2ê°œë¥¼ í™•ë³´í•´ì•¼ë§Œ í›„ë³´ë¥¼ ìƒì„±(êµì°¨ ì¡°ê±´)
// - ìë™ ìƒì„±ëœ í›„ë³´ëŠ” ìƒíƒœ ì „ì´(WATCH/EXIT_PENDING)ì— ì ˆëŒ€ ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŒ (Verified=TRUEë§Œ ë°˜ì˜)
function generateRefuteEventCandidatesForSelectedHypothesis() {
  try {
    Logger.log('STEP6_CANDIDATES_DIAGv3 start');
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getActiveSheet();

    if (sheet.getName() !== 'HypothesisBacklog') {
      SpreadsheetApp.getUi().alert('HypothesisBacklog ì‹œíŠ¸ì—ì„œ ê°€ì„¤ í–‰ì„ ì„ íƒí•œ ë’¤ ì‹¤í–‰í•˜ì„¸ìš”.');
      return;
    }

    const row = sheet.getActiveCell().getRow();
    if (row < 2) {
      SpreadsheetApp.getUi().alert('í—¤ë”(1í–‰)ê°€ ì•„ë‹ˆë¼ ê°€ì„¤ ë°ì´í„° í–‰ì„ ì„ íƒí•˜ì„¸ìš”.');
      return;
    }

    const header = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const rowVals = sheet.getRange(row, 1, 1, sheet.getLastColumn()).getValues()[0];

    // Pull fields (best-effort; fall back to blanks)
    const getByName = (name) => {
      const idx = header.indexOf(name);
      return idx >= 0 ? String(rowVals[idx] || '') : '';
    };

    const idxCreatedAt = header.indexOf('CreatedAt');
    const createdAtVal = idxCreatedAt >= 0 ? rowVals[idxCreatedAt] : '';
    const createdAt = idxCreatedAt >= 0 ? String(rowVals[idxCreatedAt] || '') : '';
    const triggerNote = getByName('TriggerNote');
    const domain = getByName('Domain');
    const signal = getByName('Signal');
    const hypothesis = getByName('Hypothesis');
    const fastFalsifiers = getByName('Fast_Falsifiers');

    const isTestMode = (String(domain || '').trim().toUpperCase() === 'TEST') || (String(triggerNote || '').indexOf('[TEST]') >= 0);

    const hypothesisId = normalizeHypothesisId_(createdAtVal) || normalizeHypothesisId_(createdAt) || Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm:ss');

    // Build search queries (keep short; avoid quotes-heavy strings)
    const baseParts = []
      .concat(domain ? [domain] : [])
      .concat(signal ? [signal] : [])
      .concat(hypothesis ? [hypothesis] : [])
      .concat(fastFalsifiers ? [fastFalsifiers] : []);

    const baseText = baseParts.join(' ');
    const cleaned = baseText
      .replace(/https?:\/\/\S+/g, ' ')
      .replace(/["'â€œâ€â€˜â€™]/g, ' ')
      .replace(/[(){}\[\]]/g, ' ')
      .replace(/[^\w\s\-\/]/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();

    // Tokenize and choose top keywords
    const tokens = cleaned
      .split(/\s+/)
      .map(t => t.trim())
      .filter(Boolean)
      .filter(t => t.length >= 3)
      .slice(0, 24);

    if (tokens.length === 0) {
      SpreadsheetApp.getUi().alert('ê²€ìƒ‰ í‚¤ì›Œë“œë¥¼ ë§Œë“¤ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. Domain/Signal/Hypothesis/Fast_Falsifiers ì¤‘ ìµœì†Œ 1ê°œì— í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
      return;
    }

        // Query strategy:
    // - ê¸°ê´€ ê´€ì : 180d ì •ë„ì˜ ì¤‘ê¸° ì°½(ë‹¨, ë³¸ ê¸°ëŠ¥ì€ "í›„ë³´ ìˆ˜ì§‘" ëª©ì ì´ë¯€ë¡œ ì‹œì  í•„í„°ëŠ” ì†ŒìŠ¤ë³„ë¡œ ë‹¤ë¥´ê²Œ ì ìš©ë¨)
    const rawContext = [domain, signal, hypothesis, fastFalsifiers].map(v => String(v || '')).join(' ');
    let stablecoinMode = /ìŠ¤í…Œì´ë¸”\s*ì½”ì¸|stable\s*coin|digital\s*asset|crypto|ì•”í˜¸í™”í|í† í°í™”|ê²°ì œ\s*ì‹œìŠ¤í…œ|ê²°ì œ\s*ì¸í”„ë¼/i.test(rawContext);

    // (A) ì¿¼ë¦¬ ìƒì„±ë¶€ ë³´ê°•: "ê°€ì„¤ ê¸°ë°˜ í‚¤ì›Œë“œ + ë„ë©”ì¸ ë³´ê°•"
    // - íŠ¹ì • ë„ë©”ì¸(ê·œì œ/ê²°ì œ/ë””ì§€í„¸ìì‚°)ì—ì„œ 'regulation' ê°™ì€ ì¼ë°˜ ë‹¨ì–´ê°€ ì¿¼ë¦¬ë¥¼ ì§€ë°°í•˜ëŠ” ê²½ìš°ë¥¼ ë°©ì§€
    if (stablecoinMode) {
      // í•µì‹¬ í‚¤ì›Œë“œ ê°•ì œ ë³´ê°• (ìµœì†Œ 1ê°œëŠ” ë°˜ë“œì‹œ ë“¤ì–´ê°€ë„ë¡)
      const must = ['ìŠ¤í…Œì´ë¸”ì½”ì¸', 'stablecoin', 'digital asset', 'crypto', 'payment', 'settlement'];
      for (let i = 0; i < must.length; i++) {
        if (tokens.indexOf(must[i]) === -1) tokens.push(must[i]);
      }
    }

    // (B) ê¸ˆì¹™ì–´/ì˜¤íƒ ì–µì œ: transportation/e-bike ë“± ëª…ë°±íˆ ë‹¤ë¥¸ ì‚°ì—… í‚¤ì›Œë“œ ì œê±°
    let query = tokens.join(' ');
    if (stablecoinMode) {
      const negatives = ['e-bike', 'ebike', 'bicycle', 'cycling', 'bike', 'transportation', 'Illinois'];
      for (let i = 0; i < negatives.length; i++) {
        query += ' -"' + negatives[i] + '"';
      }
    }

    Logger.log('STEP6_CANDIDATES_DIAGv3 query=' + query);

    // Collect candidates from multiple public sources (no API key)
    let candidates = [];
    const seenUrl = {};

    const pushCandidate = (title, url, source) => {
      const u = String(url || '').trim();
      if (!u) return;
      if (seenUrl[u]) return;
      seenUrl[u] = true;

      // ì˜¤íƒ ì–µì œ(íŠ¹ì • ë„ë©”ì¸/ê°€ì„¤ì—ì„œ ëª…ë°±íˆ ë¬´ê´€í•œ í‚¤ì›Œë“œ ì°¨ë‹¨)
      if (stablecoinMode) {
        const t = (String(title || '') + ' ' + String(u || '')).toLowerCase();
        const banned = ['e-bike', 'ebike', 'bicycle', 'cycling', 'bike', 'transportation', 'illinois'];
        for (let bi = 0; bi < banned.length; bi++) {
          if (t.indexOf(banned[bi]) !== -1) return;
        }
      }
      candidates.push({
        title: String(title || '').trim(),
        url: u,
        source: String(source || '').trim(),
        domain: (function () {
          try {
            const m = u.match(/^https?:\/\/([^\/?#]+)/i);
            return m ? m[1].toLowerCase() : '';
          } catch (e) {
            return '';
          }
        })()
      });
    };

    // 1) Google News RSS (best-effort; may be blocked in some environments)
    try {
      const rssUrl =
        'https://news.google.com/rss/search?q=' +
        encodeURIComponent(query) +
        '&hl=en-US&gl=US&ceid=US:en';

      Logger.log('STEP6_CANDIDATES_DIAGv3 fetch googleNewsRss=' + rssUrl);

      const res = UrlFetchApp.fetch(rssUrl, {
        muteHttpExceptions: true,
        followRedirects: true,
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          'Accept': 'application/rss+xml,application/xml,text/xml,*/*;q=0.8'
        }
      });

      const code = res.getResponseCode();
      const body = res.getContentText() || '';
      Logger.log('STEP6_CANDIDATES_DIAGv3 googleNewsRss code=' + code + ' len=' + body.length);
      Logger.log('STEP6_CANDIDATES_DIAGv3 googleNewsRss head=' + body.slice(0, 200));

      if (code >= 200 && code < 300 && body) {
        const doc = XmlService.parse(body);
        const root = doc.getRootElement();
        const channel = root.getChild('channel');
        if (channel) {
          const items = channel.getChildren('item') || [];
          Logger.log('STEP6_CANDIDATES_DIAGv3 googleNewsRss items=' + items.length);

          items.slice(0, 25).forEach(it => {
            const t = it.getChildText('title');
            const l = it.getChildText('link');
            pushCandidate(t, l, 'GoogleNewsRSS');
          });
        } else {
          Logger.log('STEP6_CANDIDATES_DIAGv3 googleNewsRss channel missing');
        }
      }
    } catch (eRss) {
      Logger.log('STEP6_CANDIDATES_DIAGv3 googleNewsRss error=' + eRss);
    }

    // 2) GDELT 2.1 DOC API (ArtList) - JSON response with article URLs (no key)
    try {
      // NOTE: GDELT has its own freshness controls; we request maxrecords and let user verify.
      const gdeltUrl =
        'https://api.gdeltproject.org/api/v2/doc/doc?query=' +
        encodeURIComponent(query) +
        '&mode=artlist&format=json&maxrecords=25&sort=HybridRel';

      Logger.log('STEP6_CANDIDATES_DIAGv3 fetch gdelt=' + gdeltUrl);

      const res2 = UrlFetchApp.fetch(gdeltUrl, {
        muteHttpExceptions: true,
        followRedirects: true,
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          'Accept': 'application/json,*/*;q=0.8'
        }
      });

      const code2 = res2.getResponseCode();
      const body2 = res2.getContentText() || '';
      Logger.log('STEP6_CANDIDATES_DIAGv3 gdelt code=' + code2 + ' len=' + body2.length);
      Logger.log('STEP6_CANDIDATES_DIAGv3 gdelt head=' + body2.slice(0, 200));

      if (code2 >= 200 && code2 < 300 && body2) {
        const json = JSON.parse(body2);

        let arr = [];
        if (json && Array.isArray(json.articles)) arr = json.articles;
        else if (json && Array.isArray(json.results)) arr = json.results;
        else if (json && Array.isArray(json.data)) arr = json.data;
        else if (json && json.response && Array.isArray(json.response.articles)) arr = json.response.articles;

        Logger.log('STEP6_CANDIDATES_DIAGv3 gdelt items=' + (arr ? arr.length : 0));

        (arr || []).slice(0, 50).forEach(a => {
          const t = a && (a.title || a.seendate || a.domain || '');
          const u = a && (a.url || a.urlref || a.link || '');
          pushCandidate(t, u, 'GDELT');
        });
      }
    } catch (eG) {
      Logger.log('STEP6_CANDIDATES_DIAGv3 gdelt error=' + eG);
    }

    Logger.log('STEP6_CANDIDATES_DIAGv3 candidatesTotal=' + candidates.length);

    // Need at least 2 URLs with distinct domains
    // --- Relevance gate (title-level) ---
    // If a candidate title does not contain any "anchor" tokens, drop it to avoid unrelated generic 'infrastructure' noise.
    const genericTokens = [
    'report','news','latest','update','market','company','companies','industry',
    'policy','government','regulation','study','research','analysis','year','2025','2026',
    'project','initiative','program',
    'uk','us','eu','china','korea','japan',
    'physics','science','earth','planetary','infrastructure'
  ];

  // Normalize tokens: split on non-alnum (keeps Korean), lowercase, de-dup
  const normTokens = Array.from(new Set(tokens
    .flatMap(t => String(t || '').toLowerCase().split(/[^a-z0-9ê°€-í£]+/).filter(Boolean))
  ));

  // Anchor tokens: prefer longer / more specific tokens
  // - Korean: length >= 2 (many í•µì‹¬ì–´ê°€ 2~5ì)
  // - Non-Korean: length >= 6
    const hypothesisText = String(hypothesis || '');

  const anchorTokens = normTokens
    .filter(t => /[ê°€-í£]/.test(t) ? t.length >= 2 : t.length >= 6)
    .filter(t => !genericTokens.includes(t))
    .slice(0, 10);
  // [PATCH] Collection-stage "keyword clue score" (replace strict meaning-gate)
  // - Do NOT drop all candidates via LLM semantic gate.
  // - Score by (í•µì‹¬ í‚¤ì›Œë“œ + ë°˜ì¦ í‚¤ì›Œë“œ) ë‹¨ì„œ ì ìˆ˜ë¡œ ìš°ì„ ìˆœìœ„ë§Œ ì¡°ì •.
  if (candidates.length > 0) {
    var __t0 = new Date().getTime();

    // fallback: if anchorTokens not available, derive from hypothesisText quickly
    var __anchorTokens = (anchorTokens && anchorTokens.length) ? anchorTokens : [];
    if (!__anchorTokens.length && hypothesisText) {
      __anchorTokens = String(hypothesisText)
        .toLowerCase()
        .replace(/[^a-z0-9ê°€-í£\s]/g, " ")
        .split(/\s+/)
        .filter(function (w) { return w && w.length >= 3; })
        .slice(0, 10);
    }

    // falsifier tokens already prepared above; keep as-is
    var __falsTokens = (__falsifiers && __falsifiers.length) ? String(__falsifiers).split(/[\n,;]+/).map(function(s){return String(s).trim();}).filter(function(s){return s;}) : [];

    // preferred/credible sources boost (may be paywalled; boost only, do not force)
    var __preferredDomains = [
      "reuters.com",
      "wsj.com",
      "bloomberg.com",
      "ft.com",
      "economist.com",
      "cnbc.com",
      "theinformation.com",
      "nikkei.com",
      "forbes.com",
      "technologyreview.com",
      "datacenterdynamics.com"
    ];

    for (var __i = 0; __i < candidates.length; __i++) {
      var __c = candidates[__i] || {};
      var __hay = (String(__c.title || "") + " " + String(__c.snippet || "") + " " + String(__c.description || "")).toLowerCase();

      var __coreHit = 0;
      for (var __a = 0; __a < __anchorTokens.length; __a++) {
        var __tok = __anchorTokens[__a];
        if (__tok && __hay.indexOf(__tok) !== -1) __coreHit++;
      }

      var __falsHit = 0;
      for (var __f = 0; __f < __falsTokens.length; __f++) {
        var __ft = __falsTokens[__f];
        if (__ft && __hay.indexOf(__ft) !== -1) __falsHit++;
      }

      var __score = (__coreHit * 3) + (__falsHit * 2);

      // domain boost (soft)
      try {
        var __u = String(__c.url || __c.link || "");
        var __host = "";
        if (__u) {
          __host = (__u.match(/^https?:\/\/([^\/]+)/i) || [null, ""])[1].toLowerCase();
          if (__host.indexOf("www.") === 0) __host = __host.substring(4);
        }
        if (__host) {
          for (var __d = 0; __d < __preferredDomains.length; __d++) {
            if (__host.indexOf(__preferredDomains[__d]) !== -1) { __score += 2; break; }
          }
        }
      } catch (e) {}

      // small bonus if any keyword hit exists
      if (__coreHit > 0) __score += 1;
      if (__falsHit > 0) __score += 1;

      // attach for later debug/sort
      __c.__clueScore = __score;
      __c.__coreHit = __coreHit;
      __c.__falsHit = __falsHit;
      candidates[__i] = __c;
    }

    // sort by clue score desc, then by publishedAt desc (if present)
    candidates.sort(function (a, b) {
      var as = (a && typeof a.__clueScore === "number") ? a.__clueScore : 0;
      var bs = (b && typeof b.__clueScore === "number") ? b.__clueScore : 0;
      if (bs !== as) return bs - as;
      var ad = (a && a.publishedAt) ? new Date(a.publishedAt).getTime() : 0;
      var bd = (b && b.publishedAt) ? new Date(b.publishedAt).getTime() : 0;
      return bd - ad;
    });

    // optional trim (keep top 25 for stability)
    if (candidates.length > 25) candidates.splice(25);

    if (enableDiagnostics) {
      Logger.log("[STEP6][ClueScore] candidates=%s topScore=%s elapsedMs=%s anchorTokens=%s falsTokens=%s",
        candidates.length,
        (candidates[0] ? candidates[0].__clueScore : "N/A"),
        (new Date().getTime() - __t0),
        __anchorTokens.join(","),
        __falsTokens.join(",")
      );
    }
  }



    const picked = [];
    // Domain diversity check bypassed: pick by URL count only.
    for (let i = 0; i < candidates.length; i++) {
      const c = candidates[i];
      if (!c || !c.url) continue;
      picked.push(c);
      if (picked.length >= 2) break;
    }

    const needCount = isTestMode ? 1 : 2;
    // ìµœì†Œ 1ê°œë¼ë„ ìˆìœ¼ë©´ ì§„í–‰(2ê°œ ë¯¸ë§Œì´ë©´ 2ë²ˆì§¸ URLì€ ê³µë€ìœ¼ë¡œ íŒ¨ë”©)
    if (picked.length === 0) {
      Logger.log('STEP6_CANDIDATES_DIAGv3 picked=0');
      SpreadsheetApp.getActiveSpreadsheet().toast('STEP6: í›„ë³´ 0ê±´(ì—°ê´€ì„± í•„í„°ë¡œ ëª¨ë‘ ì œì™¸ë¨)', 'STEP6', 4);
      return;
    }
    if (picked.length < 2) {
      Logger.log('STEP6_CANDIDATES_DIAGv3 picked<2, pad empty url2');
      SpreadsheetApp.getActiveSpreadsheet().toast('STEP6: URL 1ê°œë§Œ í™•ë³´(2ë²ˆì§¸ëŠ” ê³µë€)', 'STEP6', 4);
    }
    while (picked.length < 2) {
      picked.push({ title: '', url: '', source: '', domain: '' });
    }

    // Write to Refute_Events (append)
    const refuteSheet = ss.getSheetByName('Refute_Events');
    if (!refuteSheet) {
      SpreadsheetApp.getUi().alert('Refute_Events ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € STEP6: Refute_Events ì‹œíŠ¸ ì—´ê¸°ë¥¼ ì‹¤í–‰í•˜ì„¸ìš”.');
      return;
    }

    // Ensure headers exist (minimal; do not overwrite if already there)
    const existingHeader = refuteSheet.getRange(1, 1, 1, Math.max(1, refuteSheet.getLastColumn())).getValues()[0];
    if (!existingHeader || existingHeader.length === 0 || String(existingHeader[0] || '').trim() === '') {
      // If sheet is empty, initialize minimal header.
      refuteSheet.getRange(1, 1, 1, 12).setValues([[
        'CreatedAt', 'HypothesisID', 'Severity', 'Status', 'EventTitle',
        'EventSummary', 'SourceName', 'SourceURL', 'SourceURL2', 'Verified', 'Note', 'UpdatedAt'
      ]]);
    }

    const now = new Date();

    // --- Auto A/B/C classification (NO manual input)
    // C: title contains any fast falsifier token
    // B: title matches multiple hypothesis tokens
    // A: otherwise (weak warning)
    const title0 = String((picked[0] && picked[0].title) ? picked[0].title : '').trim();
    const titleLower = title0.toLowerCase();

    const falsTokens = String(fastFalsifiers || '')
      .replace(/https?:\/\/\S+/g, ' ')
      .replace(/["'â€œâ€â€˜â€™]/g, ' ')
      .replace(/[(){}\[\]]/g, ' ')
      .replace(/[^\w\s\-\/]/g, ' ')
      .replace(/\s+/g, ' ')
      .trim()
      .split(/\s+/)
      .map(t => t.trim())
      .filter(Boolean)
      .filter(t => t.length >= 3)
      .slice(0, 24);

    let autoABC = 'A';
    for (let i = 0; i < falsTokens.length; i++) {
      const ft = falsTokens[i].toLowerCase();
      if (ft && titleLower.indexOf(ft) !== -1) {
        autoABC = 'C';
        break;
      }
    }
    if (autoABC !== 'C') {
      let hit = 0;
      const seenTok = {};
      for (let i = 0; i < tokens.length; i++) {
        const tk = String(tokens[i] || '').toLowerCase();
        if (!tk || seenTok[tk]) continue;
        seenTok[tk] = true;
        if (titleLower.indexOf(tk) !== -1) hit++;
        if (hit >= 4) break;
      }
      autoABC = (hit >= 4) ? 'B' : 'A';
    }

    const rowOut = [
      Utilities.getUuid(),                                                          // EventID
      Utilities.formatDate(now, Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm:ss'),// OccurredAt
      hypothesisId,                                                                 // HypothesisID (normalized)
      autoABC,                                                                      // Exposure_Type (A/B/C)
      'ALL',                                                                        // AppliesTo
      title0 || '',                                                                 // Event_Key
      autoABC,                                                                      // Severity (A/B/C)
      'GoogleNewsRSS',                                                              // SourceTier
      (picked[0] && picked[0].source) ? String(picked[0].source || '') : '',        // Source
      (picked[0] && picked[0].url) ? String(picked[0].url || '') : '',              // Evidence_URL_1
      (picked[1] && picked[1].url) ? String(picked[1].url || '') : '',              // Evidence_URL_2
      title0 || '',                                                                 // Evidence_Title
      Utilities.formatDate(now, Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm:ss'),// Evidence_PublishedAt
      'PENDING',                                                                    // Verified
      '[AUTO_CANDIDATES] ' + (triggerNote ? ('TriggerNote: ' + triggerNote) : '')   // Note
    ];

    refuteSheet.appendRow(rowOut);

    SpreadsheetApp.getActiveSpreadsheet().toast('í›„ë³´ 2ê°œ ìƒì„± ì™„ë£Œ: Refute_Eventsì— ì¶”ê°€ë¨', 'STEP6', 5);
    Logger.log('STEP6_CANDIDATES_DIAGv3 done');
  } catch (e) {
    const msg = (e && e.message) ? e.message : String(e);
    const stack = (e && e.stack) ? e.stack : '';
    Logger.log('STEP6_CANDIDATES_DIAGv3 fatal=' + msg + (stack ? ('\n' + stack) : ''));
    SpreadsheetApp.getActiveSpreadsheet().toast('DIAGv3 ì˜¤ë¥˜: ' + msg, 'STEP6', 8);
  }
}

// ğŸ“Š STEP6: ì ìˆ˜/ì œì•ˆ ê°±ì‹ (ì„ íƒ ê°€ì„¤) â€” ë°˜ìë™(ì œì•ˆë§Œ)
// - Refute_Eventsì—ì„œ ì„ íƒ HypothesisIDì˜ í–‰ì„ ì§‘ê³„í•˜ì—¬ Score_A/B/C/Total ë° Status_Suggestionì„ HypothesisBacklogì— ê¸°ë¡
// - K(Status) ìë™ ë³€ê²½ ì—†ìŒ

// ğŸ¤– STEP6: AI ìš”ì•½/ì„ì‹œë¶„ë¥˜ ì±„ìš°ê¸°(ì„ íƒ ê°€ì„¤)
// - HypothesisBacklog ì„ íƒ í–‰ì˜ HypothesisID(=CreatedAt ì •ê·œí™”)ë¥¼ ê¸°ì¤€ìœ¼ë¡œ
// - Refute_Eventsì—ì„œ ë™ì¼ HypothesisID í–‰ ì¤‘ AI_Summary/AI_Directionì´ ë¹„ì–´ìˆëŠ” í–‰ë§Œ ì±„ìš´ë‹¤.
// - callGemini()ëŠ” ë³€ê²½í•˜ì§€ ì•Šìœ¼ë©°, ì‘ë‹µ íŒŒì‹±ì€ "SUMMARY:" / "DIRECTION:" ë¼ì¸ ê¸°ë°˜ìœ¼ë¡œ ìµœì†Œ ì²˜ë¦¬í•œë‹¤.
function fillAISummaryDirectionForSelectedHypothesis() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getActiveSheet();

    if (sheet.getName() !== 'HypothesisBacklog') {
      SpreadsheetApp.getUi().alert('HypothesisBacklog ì‹œíŠ¸ì—ì„œ ê°€ì„¤ í–‰ì„ ì„ íƒí•œ ë’¤ ì‹¤í–‰í•˜ì„¸ìš”.');
      return;
    }

    const row = sheet.getActiveCell().getRow();
    if (row < 2) {
      SpreadsheetApp.getUi().alert('í—¤ë”(1í–‰)ê°€ ì•„ë‹ˆë¼ ê°€ì„¤ ë°ì´í„° í–‰ì„ ì„ íƒí•˜ì„¸ìš”.');
      return;
    }

    const header = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(v => String(v || '').trim());
    const createdAtCol = header.indexOf('CreatedAt') + 1;
    if (createdAtCol <= 0) {
      SpreadsheetApp.getUi().alert('HypothesisBacklogì— CreatedAt í—¤ë”ê°€ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }

    const createdAtVal = sheet.getRange(row, createdAtCol).getValue();
    const hypothesisId = normalizeHypothesisId_(createdAtVal);
    if (!hypothesisId) {
      SpreadsheetApp.getUi().alert('HypothesisIDë¥¼ ë§Œë“¤ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (CreatedAt ê°’ í™•ì¸ í•„ìš”)');
      return;
    }

    const refuteSheet = ss.getSheetByName('Refute_Events');
    if (!refuteSheet) {
      SpreadsheetApp.getUi().alert('Refute_Events ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € "Refute_Events ì‹œíŠ¸ ì—´ê¸°"ë¥¼ ì‹¤í–‰í•˜ì„¸ìš”.');
      return;
    }

    const lastRow = refuteSheet.getLastRow();
    if (lastRow < 2) {
      SpreadsheetApp.getActiveSpreadsheet().toast('Refute_Eventsì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'STEP6', 3);
      return;
    }

    const refHeader = refuteSheet.getRange(1, 1, 1, refuteSheet.getLastColumn()).getValues()[0].map(v => String(v || '').trim());
    const hypCol = refHeader.indexOf('HypothesisID') + 1;
    const titleCol = refHeader.indexOf('Evidence_Title') + 1;
    const url1Col = refHeader.indexOf('Evidence_URL_1') + 1;
    const url2Col = refHeader.indexOf('Evidence_URL_2') + 1;
    const noteCol = refHeader.indexOf('Note') + 1;
    const eventKeyCol = refHeader.indexOf('Event_Key') + 1;

    const aiSummaryCol = refHeader.indexOf('AI_Summary') + 1;
    const aiDirectionCol = refHeader.indexOf('AI_Direction') + 1;

    if (hypCol <= 0 || titleCol <= 0 || aiSummaryCol <= 0 || aiDirectionCol <= 0) {
      SpreadsheetApp.getUi().alert('Refute_Events í—¤ë”ê°€ ì˜ˆìƒê³¼ ë‹¤ë¦…ë‹ˆë‹¤. (HypothesisID/Evidence_Title/AI_Summary/AI_Direction í™•ì¸)');
      return;
    }

    // ì „ì²´ ë°ì´í„°(í•œ ë²ˆë§Œ) ì½ê³ , í•„ìš”í•œ í–‰ë§Œ ì„ íƒì ìœ¼ë¡œ ì“°ê¸°
    const data = refuteSheet.getRange(2, 1, lastRow - 1, refuteSheet.getLastColumn()).getValues();

    let filledCount = 0;

    for (let i = 0; i < data.length; i++) {
      const r = data[i];
      const rowHypRaw = r[hypCol - 1];
      const rowHyp = normalizeHypothesisId_(rowHypRaw) || String(rowHypRaw || '').trim();
      if (rowHyp !== String(hypothesisId)) continue;

      const curSummary = String(r[aiSummaryCol - 1] || '').trim();
      const curDir = String(r[aiDirectionCol - 1] || '').trim();
      if (curSummary && curDir) continue; // ì´ë¯¸ ì±„ì›Œì§

      const title = String(r[titleCol - 1] || '').trim();
      const url1 = url1Col > 0 ? String(r[url1Col - 1] || '').trim() : '';
      const url2 = url2Col > 0 ? String(r[url2Col - 1] || '').trim() : '';
      const note = noteCol > 0 ? String(r[noteCol - 1] || '').trim() : '';
      const eventKey = eventKeyCol > 0 ? String(r[eventKeyCol - 1] || '').trim() : '';

      if (!title) continue;

      const prompt =
        "ë‹¹ì‹ ì€ íˆ¬ì íŒë‹¨ì„ í•˜ì§€ ì•ŠëŠ”ë‹¤. ì•„ë˜ ë‰´ìŠ¤ ì œëª©/ë©”ëª¨ë¥¼ í•œê¸€ë¡œ ë§¤ìš° ì§§ê²Œ ìš”ì•½í•˜ê³ , ê°€ì„¤ ê´€ì ì—ì„œ ë°©í–¥ì„ ì„ì‹œ ë¶„ë¥˜í•˜ë¼.\n" +
        "ì¶œë ¥ì€ ë°˜ë“œì‹œ ì•„ë˜ 3ì¤„ë§Œ:\n" +
        "RELEVANCE: RELATED | UNRELATED\n" +
        "SUMMARY: (í•œê¸€ 1~2ë¬¸ì¥)\n" +
        "DIRECTION: SUPPORT | NEUTRAL | REFUTE\n\n" +
        "ê·œì¹™: RELEVANCEê°€ UNRELATEDì´ë©´ DIRECTIONì€ ë°˜ë“œì‹œ NEUTRAL\n\n" +
        "[ê°€ì„¤ ID]\n" + hypothesisId + "\n\n" +
        "[ë‰´ìŠ¤ ì œëª©]\n" + title + "\n\n" +
        (eventKey ? "[Event_Key]\n" + eventKey + "\n\n" : "") +
        (note ? "[Note]\n" + note + "\n\n" : "") +
        (url1 ? "[URL1]\n" + url1 + "\n" : "") +
        (url2 ? "[URL2]\n" + url2 + "\n" : "");

      let resp = "";
      try {
        try {
          resp = callGemini(prompt);
        } catch (e2) {
          resp = callGemini(prompt, '');
        }
      } catch (e) {
        // callGemini ë‚´ë¶€ ë¬¸ì œë©´ í•´ë‹¹ í–‰ì€ ìŠ¤í‚µ
        continue;
      }

      resp = String(resp || '').trim();

      let summary = "";
      let dir = "";

      // SUMMARY íŒŒì‹±(ëª¨ë¸ ì¶œë ¥ í¬ë§·ì´ í”ë“¤ë ¤ë„ ìµœëŒ€í•œ íšŒë³µ)
      const sm = resp.match(/SUMMARY\s*:\s*([\s\S]*?)(?:\nDIRECTION\s*:|\nRELEVANCE\s*:|\n$)/i);
      if (sm && sm[1]) summary = String(sm[1]).trim();

      // í•œêµ­ì–´ 'ìš”ì•½:' fallback
      if (!summary) {
        const smKo = resp.match(/(?:ìš”ì•½|ìš”ì•½ë¬¸)\s*:\s*([\s\S]*?)(?:\n(?:DIRECTION|RELEVANCE)\s*:|\n$)/i);
        if (smKo && smKo[1]) summary = String(smKo[1]).trim();
      }

      const dm = resp.match(/DIRECTION\s*:\s*(SUPPORT|NEUTRAL|REFUTE)/i);
      const rm = resp.match(/RELEVANCE\s*:\s*(RELATED|UNRELATED)/i);
      const relevance = rm ? String(rm[1] || '').toUpperCase().trim() : '';

      // DIRECTIONì€ ë¨¼ì € íŒŒì‹±í•˜ë˜, UNRELATEDë©´ ë°˜ë“œì‹œ NEUTRALë¡œ ê°•ì œí•œë‹¤.
      if (dm && dm[1]) dir = String(dm[1]).toUpperCase().trim();
      if (relevance === 'UNRELATED') {
        dir = 'NEUTRAL';
      }

      // SUMMARYê°€ ëë‚´ ì—†ìœ¼ë©´, ì‘ë‹µì—ì„œ ë¼ë²¨ ë¼ì¸ì„ ì œê±°í•˜ê³  ì•ë¶€ë¶„ì„ ìš”ì•½ì¹¸ì— ê¸°ë¡(ì¶”í›„ ë””ë²„ê¹… ê°€ëŠ¥)
      if (!summary) {
        const cleaned = resp
          .replace(/RELEVANCE\s*:[^\n]*\n?/ig, '')
          .replace(/DIRECTION\s*:[^\n]*\n?/ig, '')
          .replace(/SUMMARY\s*:[^\n]*\n?/ig, '')
          .trim();
        if (cleaned) summary = cleaned.slice(0, 400);
      }

      if (!summary) summary = "ìš”ì•½ ìƒì„± ì‹¤íŒ¨";
      if (!dir) dir = "NEUTRAL";


      // ì‹¤ì œ ì‹œíŠ¸ì— ì“°ê¸°(2í–‰ë¶€í„° ì‹œì‘ì´ë¯€ë¡œ +2)
      const targetRow = i + 2;
      refuteSheet.getRange(targetRow, aiSummaryCol).setValue(summary);
      refuteSheet.getRange(targetRow, aiDirectionCol).setValue(dir);

      filledCount++;
    }

    SpreadsheetApp.getActiveSpreadsheet().toast('AI_Summary/AI_Direction ì±„ì›€: ' + filledCount + 'ê±´', 'STEP6', 4);
  } catch (e) {
    SpreadsheetApp.getActiveSpreadsheet().toast('DIAGv3: ì˜¤ë¥˜ ë°œìƒ(ë¡œê·¸ í™•ì¸)', 'STEP6', 4);
  }
}

function updateStep6ScoreSuggestionForSelectedHypothesis() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getActiveSheet();

    if (sheet.getName() !== 'HypothesisBacklog') {
      SpreadsheetApp.getUi().alert('HypothesisBacklog ì‹œíŠ¸ì—ì„œ ê°€ì„¤ í–‰ì„ ì„ íƒí•œ ë’¤ ì‹¤í–‰í•˜ì„¸ìš”.');
      return;
    }

    const row = sheet.getActiveCell().getRow();
    if (row < 2) {
      SpreadsheetApp.getUi().alert('í—¤ë”(1í–‰)ê°€ ì•„ë‹ˆë¼ ê°€ì„¤ ë°ì´í„° í–‰ì„ ì„ íƒí•˜ì„¸ìš”.');
      return;
    }

    const header = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(v => String(v || '').trim());
    const createdAtCol = header.indexOf('CreatedAt') + 1;
    if (createdAtCol <= 0) {
      SpreadsheetApp.getUi().alert('HypothesisBacklogì— CreatedAt í—¤ë”ê°€ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }

    const createdAtVal = sheet.getRange(row, createdAtCol).getValue();
    const hypothesisId = normalizeHypothesisId_(createdAtVal);
    if (!hypothesisId) {
      SpreadsheetApp.getUi().alert('HypothesisIDë¥¼ ë§Œë“¤ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (CreatedAt ê°’ í™•ì¸ í•„ìš”)');
      return;
    }

    // STEP6-Score: ë¨¼ì € AI ìš”ì•½/ì„ì‹œ ë¶„ë¥˜ë¥¼ ì±„ì›Œë‘”ë‹¤(ë¹„ì–´ìˆëŠ” í–‰ë§Œ)
    try {
      fillAISummaryDirectionForSelectedHypothesis();
    } catch (e) {
      // ì ìˆ˜/ì œì•ˆ ê°±ì‹ ì€ ê³„ì† ì§„í–‰(ì‚¬ìš©ì Direction ê¸°ë°˜)
    }

    const refSheet = ss.getSheetByName('Refute_Events');
    if (!refSheet) {
      SpreadsheetApp.getUi().alert('Refute_Events ì‹œíŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }

    const refLastRow = refSheet.getLastRow();
    const refLastCol = refSheet.getLastColumn();
    if (refLastRow < 2 || refLastCol < 1) {
      SpreadsheetApp.getActiveSpreadsheet().toast('Refute_Eventsì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'STEP6', 4);
      return;
    }

    const refHeader = refSheet.getRange(1, 1, 1, refLastCol).getValues()[0].map(v => String(v || '').trim());
    const refHypoCol = refHeader.indexOf('HypothesisID') + 1;
    const refTypeCol = refHeader.indexOf('Exposure_Type') + 1;

    // ì‚¬ìš©ìê°€ ìµœì¢… í™•ì •í•œ ê°’ì€ Direction ì»¬ëŸ¼(ë¹ˆ ê°’ì€ ìŠ¤í‚µ). ì—†ìœ¼ë©´ AI_Directionì„ ë³´ì¡°ë¡œ ì‚¬ìš©.
    let refDirCol = refHeader.indexOf('Direction') + 1;
    if (refDirCol <= 0) refDirCol = refHeader.indexOf('AI_Direction') + 1;

    if (refHypoCol <= 0 || refTypeCol <= 0 || refDirCol <= 0) {
      SpreadsheetApp.getUi().alert('Refute_Eventsì— í•„ìˆ˜ í—¤ë”(HypothesisID/Exposure_Type/Direction)ê°€ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }

    const refValues = refSheet.getRange(2, 1, refLastRow - 1, refLastCol).getValues();

    let scoreA = 0;
    let scoreB = 0;
    let scoreC = 0;

    // ì ìˆ˜ ê·œì¹™
    // - ë‹¨ê±´: SUPPORT +1 / NEUTRAL 0 / REFUTE -1
    // - ê°€ì¤‘ì¹˜: AÃ—2.0, BÃ—1.0, CÃ—0.5
    const weightMap = { 'A': 2.0, 'B': 1.0, 'C': 0.5 };

    for (let i = 0; i < refValues.length; i++) {
      const r = refValues[i];

      const refHypoRaw = r[refHypoCol - 1];
      const refHypoNorm = normalizeHypothesisId_(refHypoRaw);
      if (refHypoNorm !== hypothesisId) continue;

      const t = String(r[refTypeCol - 1] || '').trim().toUpperCase();
      if (t !== 'A' && t !== 'B' && t !== 'C') continue;

      const dir = String(r[refDirCol - 1] || '').trim().toUpperCase();
      if (!dir) continue;

      let base = 0;
      if (dir === 'SUPPORT') base = 1;
      else if (dir === 'REFUTE') base = -1;
      else if (dir === 'NEUTRAL') base = 0;
      else continue;

      const w = weightMap[t] || 1.0;
      const weighted = base * w;

      if (t === 'A') scoreA += weighted;
      else if (t === 'B') scoreB += weighted;
      else if (t === 'C') scoreC += weighted;
    }

    const total = scoreA + scoreB + scoreC;

    // ì„ê³„ì¹˜: +3 / -3
    // ì•ˆì „ì¥ì¹˜:
    // - Score_A <= -2 -> CONSIDER_EXIT_PENDING ê°•ì œ
    // - Score_A < 0   -> CONSIDER_SMALL_BET ê¸ˆì§€
    let suggestion = 'NO_CHANGE';
    if (scoreA <= -2 || total <= -3) {
      suggestion = 'CONSIDER_EXIT_PENDING';
    } else if (total >= 3 && scoreA >= 0) {
      suggestion = 'CONSIDER_SMALL_BET';
    }

    // HypothesisBacklogì— ì¶œë ¥ ì»¬ëŸ¼ ì¤€ë¹„(ì—†ìœ¼ë©´ ìš°ì¸¡ì— ì¶”ê°€)
    const needed = ['Score_A', 'Score_B', 'Score_C', 'Score_Total', 'Status_Suggestion'];
    let lastCol = sheet.getLastColumn();
    let headerRow = sheet.getRange(1, 1, 1, lastCol).getValues()[0].map(v => String(v || '').trim());

    for (let k = 0; k < needed.length; k++) {
      if (headerRow.indexOf(needed[k]) === -1) {
        lastCol += 1;
        sheet.getRange(1, lastCol).setValue(needed[k]);
        headerRow.push(needed[k]);
      }
    }

    const colA = headerRow.indexOf('Score_A') + 1;
    const colB = headerRow.indexOf('Score_B') + 1;
    const colC = headerRow.indexOf('Score_C') + 1;
    const colT = headerRow.indexOf('Score_Total') + 1;
    const colS = headerRow.indexOf('Status_Suggestion') + 1;

    sheet.getRange(row, colA).setValue(scoreA);
    sheet.getRange(row, colB).setValue(scoreB);
    sheet.getRange(row, colC).setValue(scoreC);
    sheet.getRange(row, colT).setValue(total);
    sheet.getRange(row, colS).setValue(suggestion);

    SpreadsheetApp.getActiveSpreadsheet().toast(`ì ìˆ˜/ì œì•ˆ ê°±ì‹  ì™„ë£Œ: A=${scoreA}, B=${scoreB}, C=${scoreC}, Total=${total}, Suggestion=${suggestion}`, 'STEP6', 5);
  } catch (e) {
    SpreadsheetApp.getActiveSpreadsheet().toast('âš ï¸ ì ìˆ˜/ì œì•ˆ ê°±ì‹  ì‹¤íŒ¨(ë¡œê·¸ í™•ì¸)', 'STEP6', 5);
    console.error(e);
  }
}



function step6ScheduledRefuteCheckAllActive(e) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const mapSheet = ss.getSheetByName('Exposure_Map');
    if (!mapSheet) return;

    const lastRow = mapSheet.getLastRow();
    const lastCol = mapSheet.getLastColumn();
    if (lastRow < 2 || lastCol < 2) return;

    const values = mapSheet.getRange(1, 1, lastRow, lastCol).getValues();
    const h = values[0].map(v => String(v || '').trim());

    const idxHid = h.indexOf('HypothesisID');
    const idxType = h.indexOf('Exposure_Type');
    const idxAppliesTo = h.indexOf('AppliesTo');
    const idxStatus = h.indexOf('Status');
    const idxETF = h.indexOf('ETF');
    const idxStock = h.indexOf('Stock');
    const idxRefute = h.indexOf('Refute_Trigger');
    const idxNote = h.indexOf('Note');

    if (idxHid < 0 || idxType < 0 || idxStatus < 0) return;

    const now = new Date();
    const nowStr = Utilities.formatDate(now, Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm:ss');

    // ì™¸ë¶€ ì´ë²¤íŠ¸ ì‹œíŠ¸(ì—†ìœ¼ë©´ ìŠ¤í‚µ)
    const evSheet = ss.getSheetByName('Refute_Events');
    let evRows = [];
    let evHeader = [];
    if (evSheet && evSheet.getLastRow() >= 2) {
      const evLastCol = evSheet.getLastColumn();
      const evValues = evSheet.getRange(1, 1, evSheet.getLastRow(), evLastCol).getValues();
      evHeader = evValues[0].map(v => String(v || '').trim());
      evRows = evValues.slice(1);
    }

    const A_THRESHOLD = 3; // A ëˆ„ì  ê¸°ì¤€(í•˜ë“œì½”ë”©)
    let touched = 0;

    for (let r = 1; r < values.length; r++) {
      const st0 = String(values[r][idxStatus] || '').trim().toUpperCase();
      if (st0 !== 'ACTIVE' && st0 !== 'WATCH') continue;

      const hypothesisId = normalizeHypothesisId_(values[r][idxHid]);
      if (!hypothesisId) continue;

      const type = String(values[r][idxType] || '').trim().toUpperCase();
      if (type !== 'A' && type !== 'B' && type !== 'C') continue;

      const appliesTo = (idxAppliesTo >= 0 ? String(values[r][idxAppliesTo] || '').trim() : '');

      // 1) ì™¸ë¶€ ì´ë²¤íŠ¸ ê¸°ë°˜ íŒì • (Câ†’Bâ†’A)
      const evImpact = evaluateExternalEventsImpactForExposure_(evHeader, evRows, hypothesisId, type, appliesTo, idxRefute >= 0 ? values[r][idxRefute] : '', A_THRESHOLD);
      if (evImpact && evImpact.changed) {
        // Refute_Trigger ê°±ì‹ 
        if (idxRefute >= 0 && evImpact.newRefute != null) {
          values[r][idxRefute] = evImpact.newRefute;
        }

        // Status ì „ì´
        if (evImpact.newStatus) {
          values[r][idxStatus] = evImpact.newStatus;
        }

        // Note ê¸°ë¡
        if (idxNote >= 0) {
          const cur = String(values[r][idxNote] || '').trim();
          const mark = evImpact.noteMark || ('AUTO_EVENT_AT=' + nowStr);
          if (!cur) values[r][idxNote] = mark;
          else values[r][idxNote] = cur + ' | ' + mark;
        }

        touched++;
      }

      // 2) Scanner_Data ë³´ì¡° íŒì • (ACTIVE â†’ WATCHë§Œ)
      const st1 = String(values[r][idxStatus] || '').trim().toUpperCase();
      if (st1 !== 'ACTIVE') continue; // EXIT_PENDING/WATCHëŠ” ê±´ë“œë¦¬ì§€ ì•ŠìŒ(ì •ì±…)

      const etfTickers = splitTickers_(idxETF >= 0 ? values[r][idxETF] : '');
      const stockTickers = splitTickers_(idxStock >= 0 ? values[r][idxStock] : '');
      const tickers = etfTickers.concat(stockTickers);

      const verdict = evaluateRefuteVerdict_(tickers);
      if (!verdict.triggered) continue;

      values[r][idxStatus] = 'WATCH';
      if (idxNote >= 0) {
        const cur = String(values[r][idxNote] || '').trim();
        const mark = 'AUTO_WATCH_AT=' + nowStr + ' | ' + verdict.reason;
        if (!cur) values[r][idxNote] = mark;
        else values[r][idxNote] = cur + ' | ' + mark;
      }
      touched++;
    }

    if (touched > 0) {
            // ìµœì†Œ writeback: ë³€ê²½ ì»¬ëŸ¼ë§Œ ë°˜ì˜ (ë°ì´í„°ê²€ì¦ ë³´í˜¸)
      if (typeof idxStatus === 'number' && idxStatus >= 0) {
        const col = idxStatus + 1;
        const colVals = values.map(r => [r[idxStatus]]);
        mapSheet.getRange(1, col, colVals.length, 1).setValues(colVals);
      }
      if (typeof idxRefute === 'number' && idxRefute >= 0) {
        const col = idxRefute + 1;
        const colVals = values.map(r => [r[idxRefute]]);
        mapSheet.getRange(1, col, colVals.length, 1).setValues(colVals);
      }
      if (typeof idxNote === 'number' && idxNote >= 0) {
        const col = idxNote + 1;
        const colVals = values.map(r => [r[idxNote]]);
        mapSheet.getRange(1, col, colVals.length, 1).setValues(colVals);
      }
    }

    // ë©”ë‰´ì—ì„œ ì§ì ‘ í˜¸ì¶œ ì‹œ ì•ˆë‚´
    if (!e) {
      SpreadsheetApp.getActiveSpreadsheet().toast('âœ… STEP6 ì ê²€ ì™„ë£Œ(ì¼ê´„)', 'STEP6', 3);
    }
  } catch (e2) {
    // íŠ¸ë¦¬ê±°ëŠ” ì¡°ìš©íˆ ì‹¤íŒ¨(ê¸°ì¡´ íë¦„ ì˜í–¥ ìµœì†Œ)
  }
}

// --- ë‚´ë¶€ í—¬í¼(ë…¸ì¶œ ë°˜ì¦ ì ê²€) ---


function checkRefuteAndDowngradeActiveToWatch_(hypothesisId) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const mapSheet = ss.getSheetByName('Exposure_Map');
  if (!mapSheet) return 'Exposure_Map ì‹œíŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';

  const lastRow = mapSheet.getLastRow();
  const lastCol = mapSheet.getLastColumn();
  if (lastRow < 2 || lastCol < 2) return 'Exposure_Mapì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.';

  const values = mapSheet.getRange(1, 1, lastRow, lastCol).getValues();
  const h = values[0].map(v => String(v || '').trim());

  const idxHid = h.indexOf('HypothesisID');
  const idxType = h.indexOf('Exposure_Type');
  const idxAppliesTo = h.indexOf('AppliesTo');
  const idxStatus = h.indexOf('Status');
  const idxETF = h.indexOf('ETF');
  const idxStock = h.indexOf('Stock');
  const idxRefute = h.indexOf('Refute_Trigger');
  const idxNote = h.indexOf('Note');

  if (idxHid < 0 || idxType < 0 || idxStatus < 0) {
    return 'Exposure_Map í—¤ë”ê°€ ì˜ˆìƒê³¼ ë‹¤ë¦…ë‹ˆë‹¤. (HypothesisID/Exposure_Type/Status í•„ìš”)';
  }

  // ì™¸ë¶€ ì´ë²¤íŠ¸ ì‹œíŠ¸(ì—†ìœ¼ë©´ ìŠ¤í‚µ)
  const evSheet = ss.getSheetByName('Refute_Events');
  let evRows = [];
  let evHeader = [];
  if (evSheet && evSheet.getLastRow() >= 2) {
    const evLastCol = evSheet.getLastColumn();
    const evValues = evSheet.getRange(1, 1, evSheet.getLastRow(), evLastCol).getValues();
    evHeader = evValues[0].map(v => String(v || '').trim());
    evRows = evValues.slice(1);
  }

  const nowStr = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm:ss');
  const A_THRESHOLD = 3;
  const hypothesisIdNorm = normalizeHypothesisId_(hypothesisId);

  // STEP6-6: EXIT_PENDING ì¡°ê±´ (Refute_Events Exposure_Type ê¸°ë°˜)
  const hbSheet = ss.getSheetByName('HypothesisBacklog');
  let hbRowIndex = -1;
  let hbStatus = '';
  let idxHBid = -1, idxHBstatus = -1, idxHBnote = -1;

  if (hbSheet && hbSheet.getLastRow() >= 2) {
    const hbLastCol = hbSheet.getLastColumn();
    const hbVals = hbSheet.getRange(1, 1, hbSheet.getLastRow(), hbLastCol).getValues();
    const hbHeader = hbVals[0].map(v => String(v || '').trim());
    idxHBid = hbHeader.indexOf('HypothesisID');
    if (idxHBid < 0) {
      // HypothesisBacklogì—ëŠ” HypothesisID ì»¬ëŸ¼ì´ ì—†ê³  CreatedAtì´ ì‹ë³„ì ì—­í• ì„ í•˜ëŠ” ê²½ìš°ê°€ ìˆìŒ
      idxHBid = hbHeader.indexOf('CreatedAt');
    }
    idxHBstatus = hbHeader.indexOf('Status');
    idxHBnote = hbHeader.indexOf('Note');

    if (idxHBid >= 0 && idxHBstatus >= 0) {
      for (let i = 1; i < hbVals.length; i++) {
        if (normalizeHypothesisId_(hbVals[i][idxHBid]) === hypothesisIdNorm) {
          hbRowIndex = i + 1;
          hbStatus = String(hbVals[i][idxHBstatus] || '').trim().toUpperCase();
          break;
        }
      }
    }
  }

  let forceExitPending = false;
  if (hbStatus === 'WATCH') {
    const idxEvHid2 = evHeader.indexOf('HypothesisID');
    const idxEvType2 = evHeader.indexOf('Exposure_Type');

    if (idxEvHid2 >= 0 && idxEvType2 >= 0) {
      let hasC = false;
      let countA = 0;
      const typesSet = {};

      for (let i = 0; i < evRows.length; i++) {
        const hid2n = normalizeHypothesisId_(evRows[i][idxEvHid2]);
        if (hid2n !== hypothesisIdNorm) continue;

        const t2 = String(evRows[i][idxEvType2] || '').trim().toUpperCase();
        if (!t2) continue;

        typesSet[t2] = true;
        if (t2 === 'C') hasC = true;
        if (t2 === 'A') countA++;
      }

      const distinctTypes = Object.keys(typesSet).length;

      // ìš°ì„ ìˆœìœ„: C(1íšŒ) -> B(2ì¢… ì´ìƒ) -> A(NíšŒ ëˆ„ì )
      if (hasC) forceExitPending = true;
      else if (distinctTypes >= 2) forceExitPending = true;
      else if (countA >= A_THRESHOLD) forceExitPending = true;
    }
  }

  let checked = 0;
  let movedWatch = 0;
  let movedExit = 0;

  // ì§„ë‹¨ìš© ì¹´ìš´í„°(ë¡œì§ ì˜í–¥ ì—†ìŒ)
  let dbgMatchedHypothesis = 0;
  let dbgMatchedTypeABC = 0;
  let dbgMatchedStatusActiveWatch = 0;

  for (let r = 1; r < values.length; r++) {
    const hid = normalizeHypothesisId_(values[r][idxHid]);
    if (hid !== hypothesisIdNorm) continue;

    dbgMatchedHypothesis++;

    const type = String(values[r][idxType] || '').trim().toUpperCase();
    if (type !== 'A' && type !== 'B' && type !== 'C') continue;

    dbgMatchedTypeABC++;

    const st0 = String(values[r][idxStatus] || '').trim().toUpperCase();
    if (!forceExitPending && st0 !== 'ACTIVE' && st0 !== 'WATCH') continue; // ê´€ì¸¡ ëŒ€ìƒ(ì •ì±…)

    dbgMatchedStatusActiveWatch++;

    if (forceExitPending) {
      checked++;
      const stNew = 'EXIT_PENDING';
      if (st0 !== stNew) {
        values[r][idxStatus] = stNew;
        movedExit++;
      }
      if (idxRefute >= 0) {
        const prev = String(values[r][idxRefute] || '').trim();
        values[r][idxRefute] = (prev ? (prev + ' | ') : '') + '[AUTO_EXIT_PENDING]';
      }
      continue;
    }

    const appliesTo = (idxAppliesTo >= 0 ? String(values[r][idxAppliesTo] || '').trim() : '');
    const curRefute = (idxRefute >= 0 ? String(values[r][idxRefute] || '') : '');

    // 1) ì™¸ë¶€ ì´ë²¤íŠ¸ ê¸°ë°˜ íŒì • (Câ†’Bâ†’A)
    const evImpact = evaluateExternalEventsImpactForExposure_(evHeader, evRows, hid, type, appliesTo, curRefute, A_THRESHOLD);
    if (evImpact && evImpact.changed) {
      if (idxRefute >= 0 && evImpact.newRefute != null) {
        values[r][idxRefute] = evImpact.newRefute;
      }
      if (evImpact.newStatus) {
        const newSt = String(evImpact.newStatus || '').trim().toUpperCase();
        if (newSt === 'EXIT_PENDING' && st0 !== 'EXIT_PENDING') movedExit++;
        if (newSt === 'WATCH' && st0 === 'ACTIVE') movedWatch++;
        values[r][idxStatus] = evImpact.newStatus;
      }
      if (idxNote >= 0) {
        const cur = String(values[r][idxNote] || '').trim();
        const mark = evImpact.noteMark || ('AUTO_EVENT_AT=' + nowStr);
        if (!cur) values[r][idxNote] = mark;
        else values[r][idxNote] = cur + ' | ' + mark;
      }
    }

    // 2) Scanner_Data ë³´ì¡° íŒì • (ACTIVE â†’ WATCHë§Œ)
    const st1 = String(values[r][idxStatus] || '').trim().toUpperCase();
    if (st1 !== 'ACTIVE') { checked++; continue; } // EXIT_PENDING/WATCHëŠ” ìŠ¤í‚µ

    const etfTickers = splitTickers_(idxETF >= 0 ? values[r][idxETF] : '');
    const stockTickers = splitTickers_(idxStock >= 0 ? values[r][idxStock] : '');
    const tickers = etfTickers.concat(stockTickers);

    const verdict = evaluateRefuteVerdict_(tickers);
    checked++;

    if (!verdict.triggered) continue;

    values[r][idxStatus] = 'WATCH';
    if (idxNote >= 0) {
      const cur = String(values[r][idxNote] || '').trim();
      const mark = 'AUTO_WATCH_AT=' + nowStr + ' | ' + verdict.reason;
      if (!cur) values[r][idxNote] = mark;
      else values[r][idxNote] = cur + ' | ' + mark;
    }
    movedWatch++;
  }

  if (dbgMatchedStatusActiveWatch === 0) {
    return 'ACTIVE/WATCH ìƒíƒœì˜ A/B/C ë…¸ì¶œì´ ì—†ìŠµë‹ˆë‹¤.'
      + ' | dbgMatchedHypothesis=' + dbgMatchedHypothesis
      + ', dbgMatchedTypeABC=' + dbgMatchedTypeABC
      + ', dbgMatchedStatusActiveWatch=' + dbgMatchedStatusActiveWatch
      + ', forceExitPending=' + (forceExitPending ? 'Y' : 'N')
      + ', hbStatus=' + (hbStatus || '(empty)')
      + ', hypothesisIdNorm=' + hypothesisIdNorm;
  }


  // STEP6-6: HypothesisBacklog ìƒíƒœ ì—…ë°ì´íŠ¸
  if (forceExitPending && hbRowIndex > 0 && hbSheet && idxHBstatus >= 0) {
    hbSheet.getRange(hbRowIndex, idxHBstatus + 1).setValue('EXIT_PENDING');
    if (idxHBnote >= 0) {
      const noteCell = hbSheet.getRange(hbRowIndex, idxHBnote + 1);
      const prevNote = String(noteCell.getValue() || '').trim();
      const stamp = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm:ss');
      const add = '[AUTO_EXIT_PENDING] ' + stamp;
      noteCell.setValue(prevNote ? (prevNote + ' | ' + add) : add);
    }
  }

  if (movedWatch > 0 || movedExit > 0) {
          // ìµœì†Œ writeback: ë³€ê²½ ì»¬ëŸ¼ë§Œ ë°˜ì˜ (ë°ì´í„°ê²€ì¦ ë³´í˜¸)
      if (typeof idxStatus === 'number' && idxStatus >= 0) {
        const col = idxStatus + 1;
        const colVals = values.map(r => [r[idxStatus]]);
        mapSheet.getRange(1, col, colVals.length, 1).setValues(colVals);
      }
      if (typeof idxRefute === 'number' && idxRefute >= 0) {
        const col = idxRefute + 1;
        const colVals = values.map(r => [r[idxRefute]]);
        mapSheet.getRange(1, col, colVals.length, 1).setValues(colVals);
      }
      if (typeof idxNote === 'number' && idxNote >= 0) {
        const col = idxNote + 1;
        const colVals = values.map(r => [r[idxNote]]);
        mapSheet.getRange(1, col, colVals.length, 1).setValues(colVals);
      }
    if (movedExit > 0) return 'âœ… ê´€ì¸¡ ì ê²€: EXIT_PENDING ' + movedExit + 'ê±´, WATCH ' + movedWatch + 'ê±´';
    return 'âœ… ê´€ì¸¡ ì ê²€: WATCH ' + movedWatch + 'ê±´';
  }

  return 'âœ… ê´€ì¸¡ ì ê²€: ì „ì´ ì—†ìŒ(ì¡°ê±´ ë¯¸ì¶©ì¡±)';
}

function closeExposureToClosedManual_(hypothesisId) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const mapSheet = ss.getSheetByName('Exposure_Map');
  if (!mapSheet) return 'Exposure_Map ì‹œíŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';

  const lastRow = mapSheet.getLastRow();
  const lastCol = mapSheet.getLastColumn();
  if (lastRow < 2 || lastCol < 2) return 'Exposure_Mapì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.';

  const values = mapSheet.getRange(1, 1, lastRow, lastCol).getValues();
  const h = values[0].map(v => String(v || '').trim());

  const idxHid = h.indexOf('HypothesisID');
  const idxType = h.indexOf('Exposure_Type');
  const idxStatus = h.indexOf('Status');
  const idxNote = h.indexOf('Note');

  if (idxHid < 0 || idxType < 0 || idxStatus < 0) {
    return 'Exposure_Map í—¤ë”ê°€ ì˜ˆìƒê³¼ ë‹¤ë¦…ë‹ˆë‹¤. (HypothesisID/Exposure_Type/Status í•„ìš”)';
  }

  const nowStr = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm:ss');
  let closed = 0;

  for (let r = 1; r < values.length; r++) {
    const hid = normalizeHypothesisId_(values[r][idxHid]);
    if (hid !== hypothesisIdNorm) continue;

    const type = String(values[r][idxType] || '').trim().toUpperCase();
    if (type !== 'A' && type !== 'B' && type !== 'C') continue;

    const st = String(values[r][idxStatus] || '').trim().toUpperCase();
    if (st === 'CLOSED') continue;

    values[r][idxStatus] = 'CLOSED';
    if (idxNote >= 0) {
      const cur = String(values[r][idxNote] || '').trim();
      const mark = 'CLOSED_AT=' + nowStr;
      if (!cur) values[r][idxNote] = mark;
      else values[r][idxNote] = cur + ' | ' + mark;
    }
    closed++;
  }

  if (closed > 0) {
          // ìµœì†Œ writeback: ë³€ê²½ ì»¬ëŸ¼ë§Œ ë°˜ì˜ (ë°ì´í„°ê²€ì¦ ë³´í˜¸)
      if (typeof idxStatus === 'number' && idxStatus >= 0) {
        const col = idxStatus + 1;
        const colVals = values.map(r => [r[idxStatus]]);
        mapSheet.getRange(1, col, colVals.length, 1).setValues(colVals);
      }
      if (typeof idxRefute === 'number' && idxRefute >= 0) {
        const col = idxRefute + 1;
        const colVals = values.map(r => [r[idxRefute]]);
        mapSheet.getRange(1, col, colVals.length, 1).setValues(colVals);
      }
      if (typeof idxNote === 'number' && idxNote >= 0) {
        const col = idxNote + 1;
        const colVals = values.map(r => [r[idxNote]]);
        mapSheet.getRange(1, col, colVals.length, 1).setValues(colVals);
      }
    return 'âœ… CLOSED ì²˜ë¦¬ ì™„ë£Œ: ' + closed + 'ê±´';
  }
  return 'CLOSED ì²˜ë¦¬í•  A/B/C ë…¸ì¶œì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.';
}

function evaluateExternalEventsImpactForExposure_(evHeader, evRows, hypothesisId, exposureType, appliesTo, curRefute, aThreshold) {
  // STEP6-6: Refute_Events ê¸°ë°˜ EXIT_PENDING íŒì • (ìš°ì„ ìˆœìœ„: C â†’ B â†’ A)
  // - C: ë‹¨ì¼ ê°•ë ¥ ë°˜ì¦ 1íšŒ â†’ ì¦‰ì‹œ EXIT_PENDING
  // - B: ì„œë¡œ ë‹¤ë¥¸ ë°˜ì¦ ìœ í˜•(Event_Key) 2ì¢… ì´ìƒ â†’ EXIT_PENDING
  // - A: ë™ì¼ ë°˜ì¦(Event_Key) 3íšŒ ëˆ„ì  â†’ EXIT_PENDING
  // - Verified=PENDING(í›„ë³´)ì€ íŒì • ì œì™¸

  if (!evHeader || evHeader.length === 0 || !evRows || evRows.length === 0) {
    return { changed: false };
  }

  const idxHid = evHeader.indexOf('HypothesisID');
  const idxType = evHeader.indexOf('Exposure_Type');
  const idxApplies = evHeader.indexOf('AppliesTo');
  const idxEventKey = evHeader.indexOf('Event_Key');
  const idxSeverity = evHeader.indexOf('Severity');
  const idxVerified = evHeader.indexOf('Verified');
  const idxSource = evHeader.indexOf('Source');

  const hypothesisIdNorm = normalizeHypothesisId_(hypothesisId);
  const exposureTypeNorm = String(exposureType || '').trim().toUpperCase();
  const appliesToNorm = String(appliesTo || '').trim().toUpperCase();

  let newRefute = (curRefute || '');

  let hasC = false;
  const bKeys = {};
  const aKeyCounts = {};

  for (let i = 0; i < evRows.length; i++) {
    const r = evRows[i];
    if (!r || r.length === 0) continue;

    const hidRaw = idxHid >= 0 ? (r[idxHid] || '') : '';
    const hidNorm = normalizeHypothesisId_(hidRaw);
    if (hidNorm !== hypothesisIdNorm) continue;

    const apRaw = idxApplies >= 0 ? (r[idxApplies] || '') : '';
    const apNorm = String(apRaw || '').trim().toUpperCase();

    // AppliesTo í•„í„°: í•¨ìˆ˜ ì¸ìë¡œ íŠ¹ì • AppliesToê°€ ë“¤ì–´ì˜¤ë©´, ALL ë˜ëŠ” ë™ì¼í•œ ê°’ë§Œ í—ˆìš©
    if (appliesToNorm && appliesToNorm !== 'ALL') {
      if (apNorm !== 'ALL' && apNorm !== appliesToNorm) continue;
    }

    // í›„ë³´(PENDING)ëŠ” íŒì •ì—ì„œ ì œì™¸
    const verRaw = idxVerified >= 0 ? (r[idxVerified] || '') : '';
    const verNorm = String(verRaw || '').trim().toUpperCase();
    if (verNorm === 'PENDING') continue;

    const typeRaw = idxType >= 0 ? (r[idxType] || '') : '';
    const typeNorm = String(typeRaw || '').trim().toUpperCase();

    // Exposure_Type ë§¤ì¹­: AppliesTo=ALLì´ë©´ íƒ€ì… ë¶ˆì¼ì¹˜ë„ í—ˆìš©(ê°€ì„¤ ì „ì²´ì— ì ìš©)
    if (apNorm !== 'ALL') {
      if (typeNorm !== exposureTypeNorm) continue;
    }

    // Severity ìš°ì„ , ì—†ìœ¼ë©´ Exposure_Typeë¡œ ëŒ€ì²´ (A/B/Cë§Œ ì¸ì •)
    let sev = String((idxSeverity >= 0 ? (r[idxSeverity] || '') : '') || typeNorm || '').trim().toUpperCase();
    if (sev !== 'A' && sev !== 'B' && sev !== 'C') continue;

    const ekRaw = idxEventKey >= 0 ? (r[idxEventKey] || '') : '';
    const ek = String(ekRaw || '').trim();

    if (sev === 'C') {
      hasC = true;
    } else if (sev === 'B') {
      const k = (ek || '__NO_KEY__').toUpperCase();
      bKeys[k] = true;
    } else if (sev === 'A') {
      const k = (ek || '__NO_KEY__').toUpperCase();
      aKeyCounts[k] = (aKeyCounts[k] || 0) + 1;
    }

    // newRefute ëˆ„ì  ê¸°ë¡(ê°„ë‹¨íˆ)
    if (ek) {
      const src = idxSource >= 0 ? String(r[idxSource] || '').trim() : '';
      const line = '[' + sev + '] ' + ek + (src ? (' (' + src + ')') : '');
      if (newRefute.indexOf(line) === -1) {
        newRefute = (newRefute ? (newRefute + '\n') : '') + line;
      }
    }
  }

  // íŒì • (ìš°ì„ ìˆœìœ„ C â†’ B â†’ A)
  if (hasC) {
    return { changed: true, newStatus: 'EXIT_PENDING', newRefute: newRefute, reason: 'C' };
  }

  const bDistinct = Object.keys(bKeys).length;
  if (bDistinct >= 2) {
    return { changed: true, newStatus: 'EXIT_PENDING', newRefute: newRefute, reason: 'B' };
  }

  let hasA3 = false;
  const aKeys = Object.keys(aKeyCounts);
  for (let i = 0; i < aKeys.length; i++) {
    if ((aKeyCounts[aKeys[i]] || 0) >= 3) {
      hasA3 = true;
      break;
    }
  }
  const thr = (typeof aThreshold === 'number' && !isNaN(aThreshold)) ? aThreshold : 3;
  if (hasA3 || (thr <= 3 && aKeys.length > 0 && false)) {
    // ë™ì¼ ë°˜ì¦ 3íšŒ ëˆ„ì 
    return { changed: true, newStatus: 'EXIT_PENDING', newRefute: newRefute, reason: 'A' };
  }

  return { changed: false, newRefute: newRefute };
}


function splitTickers_(v) {
  if (v == null) return [];
  const s = String(v).trim();
  if (!s) return [];
  return s.split(',').map(x => String(x || '').trim()).filter(x => x);
}

function evaluateRefuteVerdict_(tickers) {
  // (4-A) Refute_TriggerëŠ” ì„¤ëª…ìš©. íŒì •ì€ í•˜ë“œì½”ë”© ë£°/ì„ê³„ê°’.
  // ë£°(ìµœì†Œ):
  // - Rule1: Price < SMA200 * 0.97 AND RSI < 40
  // - Rule2: MDD >= 50
  // ìœ„ ë£°ì€ Scanner_Data ê°’ì—ë§Œ ì˜ì¡´(ì¶”ì¸¡/ìƒì„± ê¸ˆì§€)
  if (!tickers || tickers.length === 0) {
    return { triggered: false, reason: 'NO_TICKERS' };
  }

  for (let i = 0; i < tickers.length; i++) {
    const t = String(tickers[i] || '').trim();
    if (!t) continue;

    const s = getScannerData(t); // Logic.gs
    if (!s) continue;

    const price = safeNumber(s.Price);
    const sma200 = safeNumber(s.SMA200);
    const rsi = safeNumber(s.RSI);
    const mdd = safeNumber(s.MDD);

    if (price > 0 && sma200 > 0 && rsi > 0) {
      if (price < (sma200 * 0.97) && rsi < 40) {
        return { triggered: true, reason: 'RULE1:PRICE_LT_SMA200*0.97_AND_RSI_LT40(' + t + ')' };
      }
    }
    if (mdd >= 50) {
      return { triggered: true, reason: 'RULE2:MDD_GE_50(' + t + ')' };
    }
  }

  return { triggered: false, reason: 'NO_RULE_TRIGGERED' };
}



function normalizeHypothesisId_(v) {
  if (v instanceof Date) {
    return Utilities.formatDate(v, Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm:ss');
  }
  return (v == null) ? '' : v.toString().trim();
}



function loadExposureMapByHypothesisId_(hypothesisId) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const mapSheet = ss.getSheetByName('Exposure_Map');

  const empty = { A: [], B: [], C: [] };

  if (!mapSheet) return empty;
  if (!hypothesisId) return empty;

  const lastRow = mapSheet.getLastRow();
  const lastCol = mapSheet.getLastColumn();
  if (lastRow < 2) return empty;

  const header = mapSheet.getRange(1, 1, 1, lastCol).getValues()[0];

  const idxHypothesisID = header.indexOf('HypothesisID');
  const idxExposureType = header.indexOf('Exposure_Type');
  const idxRole = header.indexOf('Role');
  const idxReason = header.indexOf('Structural_Reason');
  const idxETF = header.indexOf('ETF');
  const idxStock = header.indexOf('Stock');
  const idxAppliesTo = header.indexOf('AppliesTo');
  const idxStatus = header.indexOf('Status');
  const idxRefute = header.indexOf('Refute_Trigger');

  if (idxHypothesisID < 0 || idxExposureType < 0) return empty;

  const values = mapSheet.getRange(2, 1, lastRow - 1, lastCol).getValues();

  for (let i = 0; i < values.length; i++) {
    const row = values[i];

    const rawId = row[idxHypothesisID];
    const rowId = normalizeHypothesisId_(rawId);
    if (rowId !== hypothesisId) continue;

    const type = (row[idxExposureType] || '').toString().trim().toUpperCase();
    if (type !== 'A' && type !== 'B' && type !== 'C') continue;

    const item = {
      role: (idxRole >= 0 ? (row[idxRole] || '') : '').toString(),
      reason: (idxReason >= 0 ? (row[idxReason] || '') : '').toString(),
      etf: (idxETF >= 0 ? (row[idxETF] || '') : '').toString(),
      stock: (idxStock >= 0 ? (row[idxStock] || '') : '').toString(),
      appliesTo: (idxAppliesTo >= 0 ? (row[idxAppliesTo] || '') : '').toString(),
      status: (idxStatus >= 0 ? (row[idxStatus] || '') : '').toString(),
      refute: (idxRefute >= 0 ? (row[idxRefute] || '') : '').toString()
    };

    empty[type].push(item);
  }

  return empty;
}
// STEP6: Seed Exposure_Map rows for a given hypothesisId (no AI generation, just scaffolding)
function ensureExposureMapSeedRows_(hypothesisId, appliesToVal, exposureTypesVal) {
  try {
    if (!hypothesisId) return;

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let mapSheet = ss.getSheetByName('Exposure_Map');
    if (!mapSheet) {
      mapSheet = ss.insertSheet('Exposure_Map');
      mapSheet.getRange(1, 1, 1, 9).setValues([[
        'HypothesisID',
        'Exposure_Type',
        'Role',
        'Structural_Reason',
        'ETF',
        'Stock',
        'AppliesTo',
        'Status',
        'Refute_Trigger'
      ]]);
    }

    const lastCol = mapSheet.getLastColumn();
    const header = mapSheet.getRange(1, 1, 1, lastCol).getValues()[0].map(v => String(v || '').trim());

    // Ensure required headers exist (append-only)
    const required = [
      'HypothesisID',
      'Exposure_Type',
      'Role',
      'Structural_Reason',
      'ETF',
      'Stock',
      'AppliesTo',
      'Status',
      'Refute_Trigger'
    ];
    for (let i = 0; i < required.length; i++) {
      if (header.indexOf(required[i]) === -1) {
        mapSheet.getRange(1, header.length + 1).setValue(required[i]);
        header.push(required[i]);
      }
    }

    const idxHypothesisID = header.indexOf('HypothesisID') + 1;
    const idxExposureType = header.indexOf('Exposure_Type') + 1;
    const idxRole = header.indexOf('Role') + 1;
    const idxReason = header.indexOf('Structural_Reason') + 1;
    const idxETF = header.indexOf('ETF') + 1;
    const idxStock = header.indexOf('Stock') + 1;
    const idxAppliesTo = header.indexOf('AppliesTo') + 1;
    const idxStatus = header.indexOf('Status') + 1;
    const idxRefute = header.indexOf('Refute_Trigger') + 1;

    // Determine which types should exist for this hypothesis
    const typesWanted = parseExposureTypesWanted_(exposureTypesVal);

    // Scan existing rows for this hypothesisId
    const lastRow = mapSheet.getLastRow();
    const existing = { A: false, B: false, C: false };
    if (lastRow >= 2) {
      const values = mapSheet.getRange(2, 1, lastRow - 1, header.length).getValues();
      for (let r = 0; r < values.length; r++) {
        const rowId = normalizeHypothesisId_(values[r][idxHypothesisID - 1]);
        if (rowId !== hypothesisId) continue;
        const t = String(values[r][idxExposureType - 1] || '').trim().toUpperCase();
        if (t === 'A' || t === 'B' || t === 'C') existing[t] = true;
      }
    }

    const applies = String(appliesToVal || '').trim() || 'ALL';

    // Append missing scaffold rows
    const rowsToAppend = [];
    for (let i = 0; i < typesWanted.length; i++) {
      const t = typesWanted[i];
      if (existing[t]) continue;

      const row = new Array(header.length).fill('');
      row[idxHypothesisID - 1] = hypothesisId;
      row[idxExposureType - 1] = t;
      row[idxRole - 1] = (t === 'A') ? 'Core' : (t === 'B') ? 'Time' : 'Option';
      row[idxReason - 1] = '';
      row[idxETF - 1] = '';
      row[idxStock - 1] = '';
      row[idxAppliesTo - 1] = applies;
      row[idxStatus - 1] = 'DRAFT';
      row[idxRefute - 1] = '';
      rowsToAppend.push(row);
    }

    if (rowsToAppend.length > 0) {
      mapSheet.getRange(lastRow + 1, 1, rowsToAppend.length, header.length).setValues(rowsToAppend);
    }

    // STEP6_AUTO: If ETF/Stock candidates are empty, auto-suggest once via Gemini and fill Exposure_Map.
    try {
      const needAuto = (function() {
  // Only run when at least one target Exposure_Type row (A/B/C) is still empty.
  const data = mapSheet.getDataRange().getValues();
  const h = data[0].map(String);

  const idxHid = h.indexOf('HypothesisID');
  const idxType = h.indexOf('Exposure_Type');
  const idxReason = h.indexOf('Structural_Reason');
  const idxETF = h.indexOf('ETF');
  const idxStock = h.indexOf('Stock');

  let hasTarget = false;
  let hasEmpty = false;

  for (let r = 1; r < data.length; r++) {
    const hid = normalizeHypothesisId_(data[r][idxHid]);
    if (hid !== hypothesisId) continue;

    const t = String(data[r][idxType] || '').trim().toUpperCase();
    if (!typesWanted.includes(t)) continue;

    hasTarget = true;

    const reason = String(data[r][idxReason] || '').trim();
    const etf = String(data[r][idxETF] || '').trim();
    const stock = String(data[r][idxStock] || '').trim();

    if (!reason && !etf && !stock) {
      hasEmpty = true;
      // keep scanning (no early return)
    }
  }

  if (!hasTarget) return true;
  return hasEmpty;
})();;

      if (needAuto) {
        const hb = ss.getSheetByName('HypothesisBacklog');
        let hbCtx = {};
        if (hb) {
          const hbVals = hb.getDataRange().getValues();
          if (hbVals.length > 1) {
            const hh = hbVals[0].map(x => String(x || '').trim());
            const iCreatedAt = hh.indexOf('CreatedAt');
            const iDomain = hh.indexOf('Domain');
            const iTrigger = hh.indexOf('TriggerNote');
            const iSignal = hh.indexOf('Signal');
            const iHyp = hh.indexOf('Hypothesis');
            const iFast = hh.indexOf('Fast_Falsifiers');
            const iExposure = hh.indexOf('Exposure_Types');
            const iApplies = hh.indexOf('AppliesTo');

            for (let r = 1; r < hbVals.length; r++) {
              const createdNorm = normalizeHypothesisId_(hbVals[r][iCreatedAt]);
              if (createdNorm !== hypothesisId) continue;
              hbCtx = {
                CreatedAt: String(hbVals[r][iCreatedAt] || ''),
                Domain: (iDomain >= 0) ? String(hbVals[r][iDomain] || '') : '',
                TriggerNote: (iTrigger >= 0) ? String(hbVals[r][iTrigger] || '') : '',
                Signal: (iSignal >= 0) ? String(hbVals[r][iSignal] || '') : '',
                Hypothesis: (iHyp >= 0) ? String(hbVals[r][iHyp] || '') : '',
                Fast_Falsifiers: (iFast >= 0) ? String(hbVals[r][iFast] || '') : '',
                Exposure_Types: (iExposure >= 0) ? String(hbVals[r][iExposure] || '') : '',
                AppliesTo: (iApplies >= 0) ? String(hbVals[r][iApplies] || '') : ''
              };
              break;
            }
          }
        }

        const typesWanted = parseExposureTypesWanted_(exposureTypesVal);
        const applies = String(appliesToVal || hbCtx.AppliesTo || 'ALL').trim();

        const config = getConfig();
        const prompt = [
          "You are an investment exposure-mapping assistant for the user's Financial Avengers system.",
          "Task: Recommend ETF/Stock candidate tickers for each Exposure Type requested, based ONLY on the hypothesis context.",
          "Constraints:",
          "- Output MUST be STRICT JSON only. No markdown, no commentary.",
          "- For each type (A/B/C), provide: structural_reason (short Korean), etf (comma-separated ETF tickers or 'NONE'), stock (comma-separated stock tickers or 'NONE'), refute_trigger (short Korean; 1 line).",
          "- Prefer liquid, widely-traded tickers. If unsure, use NONE.",
          "- AppliesTo indicates which portfolio tickers this hypothesis applies to. If 'ALL', treat as macro-wide.",
          "",
          "Exposure Types Definitions:",
          "A=Core: í•„ìˆ˜ ì¸í”„ë¼/ëŒ€ì²´ ë¶ˆê°€/ë¦¬ë“œíƒ€ì„ì´ ì „ì²´ë¥¼ ì§€ì—°ì‹œí‚¤ëŠ” êµ¬ê°„",
          "B=Time: ìš´ì˜(OPEX)/ìœ ì§€ë³´ìˆ˜/ì§€ì—°ë ìˆ˜ë¡ ìœ ë¦¬í•œ ë°˜ë³µ ìˆ˜ìµ êµ¬ê°„",
          "C=Option: ë³‘ëª© í”„ë¦¬ë¯¸ì—„/ê°€ê²© ì „ê°€/ë³€ë™ì„± í° ì˜µì…˜ ì„±ê²© êµ¬ê°„",
          "",
          "Requested Exposure Types: " + typesWanted.join(","),
          "AppliesTo: " + applies,
          "",
          "Hypothesis Context (verbatim):",
          "Domain: " + (hbCtx.Domain || ""),
          "TriggerNote: " + (hbCtx.TriggerNote || ""),
          "Signal: " + (hbCtx.Signal || ""),
          "Hypothesis: " + (hbCtx.Hypothesis || ""),
          "Fast_Falsifiers: " + (hbCtx.Fast_Falsifiers || ""),
          "",
          "JSON schema example:",
          '{"A":{"structural_reason":"...","etf":"IGF,IFRA","stock":"ETN,GEV","refute_trigger":"..."},"B":{"structural_reason":"...","etf":"...","stock":"...","refute_trigger":"..."},"C":{"structural_reason":"...","etf":"...","stock":"...","refute_trigger":"..."}}'
        ].join("\n");

        const reply = callGemini(prompt, config.MODEL_NAME);
        let parsed = null;
        try { parsed = JSON.parse(String(reply || '').trim()); } catch (e) { parsed = null; }

        if (parsed) {
          const allRows = mapSheet.getDataRange().getValues();
          const h = allRows[0].map(x => String(x || '').trim());
          const idxHid = h.indexOf('HypothesisID');
          const idxType = h.indexOf('Exposure_Type');
          const idxReason = h.indexOf('Structural_Reason');
          const idxETF = h.indexOf('ETF');
          const idxStock = h.indexOf('Stock');
          const idxRefute = h.indexOf('Refute_Trigger');

          const out = allRows.slice(1);
          let changed = false;

          for (let r = 0; r < out.length; r++) {
            const hid = normalizeHypothesisId_(out[r][idxHid]);
            if (hid !== hypothesisId) continue;
            const t = String(out[r][idxType] || '').trim().toUpperCase();
            if (typesWanted.indexOf(t) < 0) continue;
            let obj = parsed[t];
            if (!obj) {
              parsed[t] = { structural_reason: 'NONE', etf: 'NONE', stock: 'NONE', refute_trigger: 'NONE' };
              obj = parsed[t];
            }

            if (idxReason >= 0 && !String(out[r][idxReason] || '').trim() && obj.structural_reason) {
              out[r][idxReason] = String(obj.structural_reason || '').trim();
              changed = true;
            }
            if (idxETF >= 0 && !String(out[r][idxETF] || '').trim() && obj.etf) {
              out[r][idxETF] = String(obj.etf || '').trim();
              changed = true;
            }
            if (idxStock >= 0 && !String(out[r][idxStock] || '').trim() && obj.stock) {
              out[r][idxStock] = String(obj.stock || '').trim();
              changed = true;
            }
            if (idxRefute >= 0 && !String(out[r][idxRefute] || '').trim() && obj.refute_trigger) {
              out[r][idxRefute] = String(obj.refute_trigger || '').trim();
              changed = true;
            }
          }

          if (changed) {
            mapSheet.getRange(2, 1, out.length, h.length).setValues(out);
          }
        }
      }
    } catch (eAuto) {
      // swallow: exposure auto-fill must not break core flows
    }
  } catch (e) {
    // Do not throw: exposure view must not break core flows.
    return;
  }
}

function parseExposureTypesWanted_(raw) {
  // Default: A/B/C (A is mandatory, but blank means show all)
  const s = String(raw || '').trim().toUpperCase();

  if (!s) return ['A','B','C'];

  // Accept: "A,B,C" / "A B C" / "ABC" / "ALL" etc.
  const tokens = s.split(/[^A-Z]+/).map(x => String(x || '').trim()).filter(Boolean);
  // If no A/B/C tokens found (e.g., descriptive text), treat as ALL.
  if (tokens.length === 0) return ['A', 'B', 'C'];


  const set = { A: false, B: false, C: false };
  for (let i = 0; i < tokens.length; i++) {
    const t = tokens[i];
    if (t === 'A' || t === 'B' || t === 'C') set[t] = true;
    if (t === 'ALL') { set.A = true; set.B = true; set.C = true; }
    if (t === 'ABC') { set.A = true; set.B = true; set.C = true; }
    if (t === 'AB') { set.A = true; set.B = true; }
    if (t === 'AC') { set.A = true; set.C = true; }
    if (t === 'BC') { set.B = true; set.C = true; }
  }

  // Ensure A is always included
  if (!set.A) set.A = true;

  const out = [];
  if (set.A) out.push('A');
  if (set.B) out.push('B');
  if (set.C) out.push('C');
  return out;
}

function buildFinalReportForSelectedRow() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getActiveSheet();
  const row = sheet.getActiveCell().getRow();
  if (row < 2) {
    Browser.msgBox("ì¢…ëª©ì´ ìˆëŠ” í–‰(2í–‰ ì´ìƒ)ì„ ì„ íƒí•´ì£¼ì„¸ìš”.");
    return;
  }
  const ticker = sheet.getRange(row, 1).getValue();
  if (!ticker) {
    Browser.msgBox("ì„ íƒëœ í–‰ì˜ Aì—´ì— ì¢…ëª©(Ticker)ì´ ì—†ìŠµë‹ˆë‹¤.");
    return;
  }
  try {
    // Final_ReportëŠ” ğŸ” ì„ íƒ í–‰ ë¶„ì„ ì´ì „ì— ìƒì„±ë˜ëŠ” êµ¬ì¡°ë‹¤.
    // ë”°ë¼ì„œ ì„ íƒ í–‰ ë¶„ì„ ë‚´ë¶€ ì§€ì—­ë³€ìˆ˜(ENTRY_PRICE_TXT ë“±)ë¥¼ ì°¸ì¡°í•˜ë©´ ì•ˆ ëœë‹¤.
    const res = buildFinalReportForRow_(sheet.getName(), row);
    Browser.msgBox("âœ… Final_Report ìƒì„± ì™„ë£Œ\n- Ticker: " + ticker + "\n- Final_Report Row: " + (res && res.finalRow ? res.finalRow : "N/A"));
  } catch (e) {
    Browser.msgBox("âš ï¸ Final_Report ìƒì„± ì‹¤íŒ¨: " + e);
  }
}

function buildFinalReportForRow_(sourceSheetName, sourceRow, e14, regimeOverride, scannerOverride) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(sourceSheetName) || ss.getActiveSheet();

  // --- [A] Source row values (í—¤ë” ê¸°ë°˜: ì‹œíŠ¸1 êµ¬ì¡° ë³€ê²½ì— ì•ˆì „) ---
  const header = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(String);
  let colTicker = 0, colHoldQty = 0, colMyPrice = 0, colCurPrice = 0, colAssetType = 0, colUnderlying = 0;

  for (let i = 0; i < header.length; i++) {
    const h = String(header[i] || "").trim();
    if (!colTicker && (h === "ì¢…ëª©" || h === "Ticker")) colTicker = i + 1;
    if (!colHoldQty && (h === "ë³´ìœ  ìˆ˜ëŸ‰" || h === "HoldQty" || h === "Holdings")) colHoldQty = i + 1;
    if (!colMyPrice && (h === "í‰ë‹¨ê°€" || h === "AvgPrice" || h === "MyPrice")) colMyPrice = i + 1;
    if (!colCurPrice && (h === "í˜„ì¬ê°€" || h === "CurrentPrice" || h === "Price")) colCurPrice = i + 1;
    if (!colAssetType && h === "AssetType") colAssetType = i + 1;
    if (!colUnderlying && h === "Underlying") colUnderlying = i + 1;
  }

  // ìµœì†Œ ì•ˆì „ì¥ì¹˜: ëª» ì°¾ìœ¼ë©´ ê¸°ì¡´ ê°€ì •(1=A, 3=C, 4=D, 9=I, 10=J)ìœ¼ë¡œ fallback
  if (!colTicker) colTicker = 1;
  if (!colHoldQty) colHoldQty = 2;
  if (!colMyPrice) colMyPrice = 3;
  if (!colCurPrice) colCurPrice = 4;
  if (!colAssetType) colAssetType = 9;
  if (!colUnderlying) colUnderlying = 10;

  const ticker = String(sheet.getRange(sourceRow, colTicker).getValue() || "").trim().toUpperCase();
  if (!ticker) return { id: "", text: "", finalRow: "" };

  const holdQtyRaw = sheet.getRange(sourceRow, colHoldQty).getValue();
  const holdQty = (holdQtyRaw === '' || holdQtyRaw === null || holdQtyRaw === undefined) ? 0 : Number(holdQtyRaw);
  const isNewEntry = !(holdQty > 0);

  const assetType = String(sheet.getRange(sourceRow, colAssetType).getValue() || "").trim();
  const underlying = String(sheet.getRange(sourceRow, colUnderlying).getValue() || "").trim();
  const myPrice = sheet.getRange(sourceRow, colMyPrice).getValue();
  const curPrice = sheet.getRange(sourceRow, colCurPrice).getValue();

  // --- [B] Python sheets: Failure_Cost / Flow_Score / Leveraged_Diagnostics / Exit_Risk_Speed ---
  // NOTE: ê° ì‹œíŠ¸ì˜ í—¤ë”ëª…ì„ ê¸°ì¤€ìœ¼ë¡œ ìµœì†Œ í•„ë“œë§Œ ì¶”ì¶œí•œë‹¤.
  let pyFlow = "N/A";
  let pyFailure = "N/A";
  let pyLevDiag = "N/A";
  let pyExitSpeed = "N/A";
  let pyAssetType = "";
  let pyUnderlying = "";

  // helper ì—†ì´(ì‹ ê·œ í•¨ìˆ˜ ê¸ˆì§€) ë°˜ë³µ ë¡œì§ì„ ê·¸ëŒ€ë¡œ ì‘ì„±
  try {
    const s = ss.getSheetByName("Flow_Score");
    if (s) {
      const h = s.getRange(1, 1, 1, s.getLastColumn()).getValues()[0].map(String);
      let cTicker = 0, cScore = 0;
      for (let i = 0; i < h.length; i++) {
        const hh = String(h[i] || "").trim();
        if (!cTicker && hh === "Ticker") cTicker = i + 1;
        if (!cScore && hh.indexOf("CrowdScore") === 0) cScore = i + 1; // CrowdScore(0-1)
      }
      if (cTicker && cScore) {
        const vals = s.getRange(2, 1, s.getLastRow() - 1, s.getLastColumn()).getValues();
        for (let r = 0; r < vals.length; r++) {
          const t = String(vals[r][cTicker - 1] || "").trim().toUpperCase();
          if (t === ticker) { pyFlow = vals[r][cScore - 1]; break; }
        }
      }
    }
  } catch (e) {}

  try {
    const s = ss.getSheetByName("Failure_Cost");
    if (s) {
      const h = s.getRange(1, 1, 1, s.getLastColumn()).getValues()[0].map(String);
      let cTicker = 0, cScore = 0, cAT = 0, cUL = 0;
      for (let i = 0; i < h.length; i++) {
        const hhRaw = String(h[i] || "");
        const hh = hhRaw.trim();
        const hhKey = hh.replace(/\s+/g, "");
        if (!cTicker && hhKey === "Ticker") cTicker = i + 1;
        if (!cScore && (hhKey === "FailureCostScore" || hhKey === "FailureCostScor" || hhKey.toLowerCase().indexOf("failurecost")>=0 && hhKey.toLowerCase().indexOf("scor")>=0)) cScore = i + 1;
        if (!cAT && hhKey === "AssetType") cAT = i + 1;
        if (!cUL && hhKey === "Underlying") cUL = i + 1;
      }
      if (cTicker && cScore) {
        const vals = s.getRange(2, 1, s.getLastRow() - 1, s.getLastColumn()).getValues();
        for (let r = 0; r < vals.length; r++) {
          const t = String(vals[r][cTicker - 1] || "").trim().toUpperCase();
          if (t === ticker) { pyFailure = vals[r][cScore - 1]; if (cAT) pyAssetType = vals[r][cAT - 1]; if (cUL) pyUnderlying = vals[r][cUL - 1]; break; }
        }

      // fallback: if still N/A, try fuzzy column match and direct scan
      if (pyFailure === "N/A") {
        let scoreIdx = 0;
        for (let i = 0; i < h.length; i++) {
          const kk = String(h[i] || "").replace(/\s+/g, "").toLowerCase();
          if (!scoreIdx && kk.indexOf("failurecost") >= 0 && kk.indexOf("scor") >= 0) scoreIdx = i + 1;
        }
        if (cTicker && scoreIdx) {
          const vals2 = s.getRange(2, 1, s.getLastRow() - 1, s.getLastColumn()).getValues();
          for (let r = 0; r < vals2.length; r++) {
            const t = String(vals2[r][cTicker - 1] || "").trim().toUpperCase();
            if (t === ticker) { pyFailure = vals2[r][scoreIdx - 1]; break; }
          }
        }
      }
      }
    }
  } catch (e) {}

  try {
    const s = ss.getSheetByName("Leveraged_Diagnostics");
    if (s) {
      const h = s.getRange(1, 1, 1, s.getLastColumn()).getValues()[0].map(String);
      let cTicker = 0, cDecay = 0;
      for (let i = 0; i < h.length; i++) {
        const hh = String(h[i] || "").trim();
        if (!cTicker && hh === "Ticker") cTicker = i + 1;
        if (!cDecay && hh === "DecayProxy") cDecay = i + 1;
      }
      if (cTicker && cDecay) {
        const vals = s.getRange(2, 1, s.getLastRow() - 1, s.getLastColumn()).getValues();
        for (let r = 0; r < vals.length; r++) {
          const t = String(vals[r][cTicker - 1] || "").trim().toUpperCase();
          if (t === ticker) { pyLevDiag = vals[r][cDecay - 1]; break; }
        }
      }
    }
  } catch (e) {}

  try {
    const s = ss.getSheetByName("Exit_Risk_Speed");
    if (s) {
      const h = s.getRange(1, 1, 1, s.getLastColumn()).getValues()[0].map(String);
      let cTicker = 0, cScore = 0;
      for (let i = 0; i < h.length; i++) {
        const hh = String(h[i] || "").trim();
        if (!cTicker && hh === "Ticker") cTicker = i + 1;
        if (!cScore && hh === "ExitSpeedScore(0-100)") cScore = i + 1;
      }
      if (cTicker && cScore) {
        const vals = s.getRange(2, 1, s.getLastRow() - 1, s.getLastColumn()).getValues();
        for (let r = 0; r < vals.length; r++) {
          const t = String(vals[r][cTicker - 1] || "").trim().toUpperCase();
          if (t === ticker) { pyExitSpeed = vals[r][cScore - 1]; break; }
        }
      }
    }
  } catch (e) {}

  // Scanner base (SMA/Volatility ë“±): ê¸°ì¡´ í•¨ìˆ˜ê°€ ìˆìœ¼ë©´ ì¬ì‚¬ìš©
  const scannerBase = scannerOverride && typeof scannerOverride === 'object'
    ? scannerOverride
    : ((typeof getScannerDataForTicker_ === "function") ? getScannerDataForTicker_(ticker)
      : ((typeof getScannerData === "function") ? getScannerData(ticker) : {}));

  const marketRegimeStr = regimeOverride ? String(regimeOverride) : computeRegimeFromPythonData_(ticker);

  // Final_Reportì— ê¸°ë¡í•  4ê°œ ì§€í‘œëŠ” Python ì‹œíŠ¸ì—ì„œ í™•ì •ê°’ì„ ìš°ì„ í•œë‹¤.
  const scanner = Object.assign({}, (scannerBase || {}));
  scanner.Flow_Score = (pyFlow !== "N/A" ? pyFlow : (scanner.Flow_Score !== undefined ? scanner.Flow_Score : (scanner.flow_score !== undefined ? scanner.flow_score : "N/A")));
  scanner.Failure_Cost = (pyFailure !== "N/A" ? pyFailure : (scanner.Failure_Cost !== undefined ? scanner.Failure_Cost : (scanner.failure_cost !== undefined ? scanner.failure_cost : "N/A")));
  scanner.Leveraged_Diagnostics = (pyLevDiag !== "N/A" ? pyLevDiag : (scanner.Leveraged_Diagnostics !== undefined ? scanner.Leveraged_Diagnostics : (scanner.leveraged_diagnostics !== undefined ? scanner.leveraged_diagnostics : "N/A")));
  scanner.Exit_Risk_Speed = (pyExitSpeed !== "N/A" ? pyExitSpeed : (scanner.Exit_Risk_Speed !== undefined ? scanner.Exit_Risk_Speed : (scanner.exit_risk_speed !== undefined ? scanner.exit_risk_speed : "N/A")));

  const hypos = collectApplicableHypothesesForTicker_(ticker);

  // --- [C] E14 levels: Final_Report ë‹¨ê³„ì—ì„œ ë…ë¦½ ê³„ì‚° (ğŸ” ì„ íƒ í–‰ ë¶„ì„ ì´ì „ ì‹¤í–‰ ì „ì œ) ---
  let ENTRY_PRICE_TXT = "N/A", ADD_BUY1_TXT = "N/A", ADD_BUY2_TXT = "N/A", TP1_TXT = "N/A", TP2_TXT = "N/A", STOP_LOSS_TXT = "N/A";
  if (e14 && typeof e14 === 'object') {
    ENTRY_PRICE_TXT = e14.ENTRY || "N/A";
    ADD_BUY1_TXT = e14.ADD2 || "N/A";
    ADD_BUY2_TXT = e14.ADD3 || "N/A";
    TP1_TXT = e14.TP1 || "N/A";
    TP2_TXT = e14.TP2 || "N/A";
    STOP_LOSS_TXT = e14.STOP || "N/A";
  } else {
    // runAvengersAnalysisì˜ ê³„ì‚° ë¸”ë¡ì„ Final_Reportì— ë§ê²Œ ì¬ì‚¬ìš©
    try {
      const data = Object.assign({}, (scannerBase || {}));
      // currentPriceê°€ ì—†ìœ¼ë©´ ì‹œíŠ¸ì˜ í˜„ì¬ê°€(D)ë¥¼ ì‚¬ìš©
      if (data.currentPrice === undefined && data.price === undefined && data.Price === undefined) {
        data.currentPrice = safeNumber(curPrice);
      }
      const _priceNum_calc = safeNumber(data.currentPrice ?? data.price ?? data.Price);
      const _sma20_calc = safeNumber(data.sma20 ?? data.SMA20);
      const _sma50_calc = safeNumber(data.sma50 ?? data.SMA50);
      const _sma200_calc = safeNumber(data.sma200 ?? data.SMA200);
      const _volatility_calc = safeNumber(data.volatility ?? data.Volatility);

      const _mr_raw = String(marketRegimeStr || "").toUpperCase();
      const _mr_isUp = _mr_raw.indexOf("UPTREND") >= 0;
      const _mr_isDown = _mr_raw.indexOf("DOWNTREND") >= 0;
      const _mr_isVol = _mr_raw.indexOf("VOLATILE") >= 0;

      let _stopPct_base = 0.08; // ê¸°ë³¸ 8%
      if (_volatility_calc > 0) {
        if (_volatility_calc >= 80) _stopPct_base = 0.14;
        else if (_volatility_calc >= 50) _stopPct_base = 0.12;
        else if (_volatility_calc >= 30) _stopPct_base = 0.10;
        else _stopPct_base = 0.08;
      }

      let _entryAdj = 1.00;
      let _stopAdj = 1.00;
      let _tpAdj = 1.00;

      if (_mr_isUp) {
        _entryAdj = 0.99;
        _stopAdj = 0.85;
        _tpAdj = 1.05;
      } else if (_mr_isDown) {
        _entryAdj = 0.95;
        _stopAdj = 1.20;
        _tpAdj = 0.90;
      } else if (_mr_isVol) {
        _entryAdj = 0.97;
        _stopAdj = 1.10;
        _tpAdj = 0.95;
      }

      const _stopPct_final = Math.min(0.25, Math.max(0.03, _stopPct_base * _stopAdj));

      const _anchor_up = (_sma20_calc > 0) ? _sma20_calc : _priceNum_calc;
      const _anchor_down = (_sma50_calc > 0) ? _sma50_calc : ((_sma200_calc > 0) ? _sma200_calc : _priceNum_calc);
      const _anchor_vol = (_sma20_calc > 0 && _sma50_calc > 0) ? Math.min(_sma20_calc, _sma50_calc) : (_sma20_calc > 0 ? _sma20_calc : (_sma50_calc > 0 ? _sma50_calc : _priceNum_calc));

      let _anchor = _priceNum_calc;
      if (_mr_isUp) _anchor = _anchor_up;
      else if (_mr_isDown) _anchor = _anchor_down;
      else if (_mr_isVol) _anchor = _anchor_vol;

      const _entryPrice_calc = (_anchor > 0) ? (_anchor * _entryAdj) : 0;

      const _add1_pct = _mr_isDown ? 0.04 : 0.03;
      const _add2_pct = _mr_isDown ? 0.08 : 0.06;

      const _addBuy1_calc = (_entryPrice_calc > 0) ? (_entryPrice_calc * (1 - _add1_pct)) : 0;
      const _addBuy2_calc = (_entryPrice_calc > 0) ? (_entryPrice_calc * (1 - _add2_pct)) : 0;

      let _tp1_pct = 0.08, _tp2_pct = 0.15;
      if (_mr_isUp) { _tp1_pct = 0.10; _tp2_pct = 0.18; }
      else if (_mr_isDown) { _tp1_pct = 0.06; _tp2_pct = 0.12; }

      _tp1_pct = _tp1_pct * _tpAdj;
      _tp2_pct = _tp2_pct * _tpAdj;

      const _tp1_calc = (_entryPrice_calc > 0) ? (_entryPrice_calc * (1 + _tp1_pct)) : 0;
      const _tp2_calc = (_entryPrice_calc > 0) ? (_entryPrice_calc * (1 + _tp2_pct)) : 0;

      const _stopLoss_calc = (_entryPrice_calc > 0) ? (_entryPrice_calc * (1 - _stopPct_final)) : 0;

      ENTRY_PRICE_TXT = (_entryPrice_calc > 0) ? `$${_entryPrice_calc.toFixed(2)}` : "N/A";
      ADD_BUY1_TXT = (_addBuy1_calc > 0) ? `$${_addBuy1_calc.toFixed(2)}` : "N/A";
      ADD_BUY2_TXT = (_addBuy2_calc > 0) ? `$${_addBuy2_calc.toFixed(2)}` : "N/A";
      TP1_TXT = (_tp1_calc > 0) ? `$${_tp1_calc.toFixed(2)}` : "N/A";
      TP2_TXT = (_tp2_calc > 0) ? `$${_tp2_calc.toFixed(2)}` : "N/A";
      STOP_LOSS_TXT = (_stopLoss_calc > 0) ? `$${_stopLoss_calc.toFixed(2)}` : "N/A";
    } catch (e) {}
  }

  // --- [D] Final_Report text ---
  const lines = [];
  lines.push("# FINAL_REPORT: " + ticker);
  lines.push("## 1) Hypothesis Selection (AppliesTo)");
  if (hypos.length === 0) {
    lines.push("- ì ìš© ê°€ëŠ¥í•œ Hypothesis ì—†ìŒ (Status=WATCH/SMALL_BET/ACTIVE + AppliesTo ë§¤ì¹­ ì‹¤íŒ¨)");
  } else {
    for (let i = 0; i < hypos.length; i++) {
      const h = hypos[i];
      lines.push(`- HypothesisID: ${h.hypothesisId || "N/A"} | Status: ${h.status || "N/A"} | AppliesTo: ${h.appliesTo || "N/A"}`);
      if (h.hypothesis) lines.push(`  - Hypothesis: ${h.hypothesis}`);
      if (h.exposureTypes) lines.push(`  - Exposure_Types: ${h.exposureTypes}`);
      if (h.fastFalsifiers) lines.push(`  - Fast_Falsifiers: ${h.fastFalsifiers}`);
    }
  }

  lines.push("## 2) Python/Scanner Data");
  lines.push("- Flow_Score: " + (scanner.Flow_Score !== undefined ? scanner.Flow_Score : "N/A"));
  lines.push("- Failure_Cost: " + (scanner.Failure_Cost !== undefined ? scanner.Failure_Cost : "N/A"));
  lines.push("- Leveraged_Diagnostics: " + (scanner.Leveraged_Diagnostics !== undefined ? scanner.Leveraged_Diagnostics : "N/A"));
  lines.push("- Exit_Risk_Speed: " + (scanner.Exit_Risk_Speed !== undefined ? scanner.Exit_Risk_Speed : "N/A"));

  lines.push("## 3) Plan (E14: Entry/Stop Bands)");
  lines.push("- HoldQty(B): " + holdQty);
  const myPriceDisplay = isNewEntry ? "NEW_ENTRY" : ((myPrice !== "" && myPrice !== null && myPrice !== undefined) ? myPrice : "N/A");
  let currentPriceDisplay = ((curPrice !== "" && curPrice !== null && curPrice !== undefined) ? curPrice : "");
  if (currentPriceDisplay === "") {
    const p1 = (scannerBase && (scannerBase.Price !== undefined ? scannerBase.Price : (scannerBase.price !== undefined ? scannerBase.price : (scannerBase.CurrentPrice !== undefined ? scannerBase.CurrentPrice : (scannerBase.currentPrice !== undefined ? scannerBase.currentPrice : "")))));
    currentPriceDisplay = (p1 !== "" && p1 !== null && p1 !== undefined) ? p1 : "N/A";
  }
  lines.push("- MyPrice(C): " + myPriceDisplay + (isNewEntry ? " (ì‹ ê·œì§„ì…)" : ""));
  lines.push("- CurrentPrice(D): " + (currentPriceDisplay !== "" ? currentPriceDisplay : "N/A"));
  lines.push("- Entry_1: " + ENTRY_PRICE_TXT);
  lines.push("- Add_2: " + ADD_BUY1_TXT);
  lines.push("- Add_3: " + ADD_BUY2_TXT);
  lines.push("- TP_1: " + TP1_TXT);
  lines.push("- TP_2: " + TP2_TXT);
  lines.push("- Stop_Hard: " + STOP_LOSS_TXT);
  lines.push("- E14 Source: Final_Report calculated");

  lines.push("## 4) Notes");
  if (isNewEntry) {
    lines.push("- PositionMode: NEW_ENTRY (ë³´ìœ ìˆ˜ëŸ‰=0) â†’ í‰ë‹¨ê°€/í˜„ì¬ê°€ ì—†ì´ë„ ì‹ ê·œì§„ì… ë¶„ì„ìœ¼ë¡œ ì²˜ë¦¬í•œë‹¤.");
  }
  lines.push("- Final_ReportëŠ” 'ë³´ê³ ì„œë¥¼ ì‘ì„±í•œ ì´ìœ (ê·¼ê±° ì´ì§‘í•©)'ì´ë©°, Hì—´ ë³´ê³ ì„œ(AvengersReport)ëŠ” ì´ ë‚´ìš©ì„ ê¸°ë°˜ìœ¼ë¡œ ì‘ì„±ëœë‹¤.");

  const reportText = lines.join("\n");

  const resolvedAssetType = assetType || (pyAssetType ? String(pyAssetType).trim() : "");
  const resolvedUnderlying = underlying || (pyUnderlying ? String(pyUnderlying).trim() : "");

  const scannerMerged = Object.assign({}, (scanner || {}), {
    Flow_Score: pyFlow,
    Failure_Cost: pyFailure,
    Leveraged_Diagnostics: pyLevDiag,
    Exit_Risk_Speed: pyExitSpeed
  });

  const finalRow = appendFinalReportRow_(sourceSheetName, sourceRow, ticker, resolvedAssetType, resolvedUnderlying, marketRegimeStr, scannerMerged, reportText);
  const id = Utilities.getUuid ? Utilities.getUuid() : (new Date().getTime() + "_" + ticker);

  return { id: id, text: reportText, finalRow: finalRow };
}


// ==========================================
// âœ… [PATCH] Final_Report í–‰ ì¶”ê°€ í—¬í¼ (ë°©ì–´ ì½”ë“œ)
// - ê¸°ì¡´ ë¡œì§ ìˆ˜ì • ì—†ì´, ëˆ„ë½ëœ í•¨ìˆ˜ë§Œ ë³´ê°•
// - ì‹œíŠ¸ í—¤ë”ê°€ ì¡´ì¬í•˜ëŠ” ì»¬ëŸ¼ë§Œ ì±„ìš°ê³ , ë‚˜ë¨¸ì§€ëŠ” ë¹ˆê°’ ìœ ì§€
// ==========================================
function appendFinalReportRow_(sourceSheetName, sourceRow, ticker, assetType, underlying, regime, scanner, reportText) {
  const rSheet = ensureFinalReportSheet();
  const ts = new Date();
  const flow = scanner && scanner['Flow_Score'] !== undefined ? scanner['Flow_Score'] : (scanner && scanner['flow_score'] !== undefined ? scanner['flow_score'] : "");
  const failure = scanner && scanner['Failure_Cost'] !== undefined ? scanner['Failure_Cost'] : (scanner && scanner['failure_cost'] !== undefined ? scanner['failure_cost'] : "");
  const levdiag = scanner && scanner['Leveraged_Diagnostics'] !== undefined ? scanner['Leveraged_Diagnostics'] : (scanner && scanner['leveraged_diagnostics'] !== undefined ? scanner['leveraged_diagnostics'] : "");
  const exitSpeed = scanner && scanner['Exit_Risk_Speed'] !== undefined ? scanner['Exit_Risk_Speed'] : (scanner && scanner['exit_risk_speed'] !== undefined ? scanner['exit_risk_speed'] : "");

  const row = [
    ts,
    sourceSheetName || "",
    sourceRow || "",
    ticker || "",
    assetType || "",
    underlying || "",
    regime || "",
    flow,
    failure,
    levdiag,
    exitSpeed,
    reportText || ""
  ];
  rSheet.appendRow(row);
  return rSheet.getLastRow();
}

function ensureFinalReportSheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let rSheet = ss.getSheetByName("Final_Report");
  if (!rSheet) {
    rSheet = ss.insertSheet("Final_Report");
    rSheet.getRange(1, 1, 1, 12).setValues([[
      "CreatedAt",
      "SourceSheet",
      "SourceRow",
      "Ticker",
      "AssetType",
      "Underlying",
      "Regime",
      "Flow_Score",
      "Failure_Cost",
      "Leveraged_Diagnostics",
      "Exit_Risk_Speed",
      "ReportText"
    ]]);
    rSheet.setFrozenRows(1);
    rSheet.setColumnWidth(1, 140);
    rSheet.setColumnWidth(2, 140);
    rSheet.setColumnWidth(3, 90);
    rSheet.setColumnWidth(4, 90);
    rSheet.setColumnWidth(5, 120);
    rSheet.setColumnWidth(6, 120);
    rSheet.setColumnWidth(7, 120);
    rSheet.setColumnWidth(12, 900);
  }
  return rSheet;
}

function collectApplicableHypothesesForTicker_(ticker) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName("HypothesisBacklog");
  if (!sh) return [];

  const lastRow = sh.getLastRow();
  const lastCol = sh.getLastColumn();
  if (lastRow < 2) return [];

  const headers = sh.getRange(1, 1, 1, lastCol).getValues()[0].map(h => String(h || "").trim());
  const values = sh.getRange(2, 1, lastRow - 1, lastCol).getValues();

  const idxStatus = headers.indexOf("Status");
  const idxApplies = headers.indexOf("AppliesTo");
  const idxHypoId = headers.indexOf("HypothesisID");
  const idxCreatedAt = headers.indexOf("CreatedAt");
  const idxHypo = headers.indexOf("Hypothesis");
  const idxTag = headers.indexOf("BottleneckTag");
  const idxThesis = headers.indexOf("Thesis");
  const idxFals = headers.indexOf("Falsifier");
  const idxExposure = headers.indexOf("Exposure_Types");
  const idxFastFals = headers.indexOf("Fast_Falsifiers");

  const target = String(ticker || "").trim().toUpperCase();
  if (!target) return [];

  const allowedStatuses = {"WATCH": true, "SMALL_BET": true, "ACTIVE": true};

  let allRows = [];
  let matchedRows = [];

  for (let r = 0; r < values.length; r++) {
    const row = values[r];
    const status = idxStatus !== -1 ? String(row[idxStatus] || "").trim().toUpperCase() : "";
    if (idxStatus !== -1 && !allowedStatuses[status]) continue;

    const appliesRaw = idxApplies !== -1 ? String(row[idxApplies] || "").trim().toUpperCase() : "";
    if (idxApplies === -1) continue;

    const item = {
      hypothesisId: idxHypoId !== -1 ? String(row[idxHypoId] || "").trim() : (idxCreatedAt !== -1 ? String(row[idxCreatedAt] || "").trim() : ""),
      hypothesis: idxHypo !== -1 ? String(row[idxHypo] || "").trim() : "",
      bottleneckTag: idxTag !== -1 ? String(row[idxTag] || "").trim() : "",
      thesis: idxThesis !== -1 ? String(row[idxThesis] || "").trim() : "",
      falsifier: idxFals !== -1 ? String(row[idxFals] || "").trim() : "",
      exposureTypes: idxExposure !== -1 ? String(row[idxExposure] || "").trim() : "",
      fastFalsifiers: idxFastFals !== -1 ? String(row[idxFastFals] || "").trim() : "",
      status: status,
      appliesTo: appliesRaw
    };

    if (appliesRaw === "ALL" || appliesRaw === "*" ) {
      allRows.push(item);
      continue;
    }

    const tokens = appliesRaw.split(/[^A-Z0-9]+/).map(s => String(s || "").trim()).filter(Boolean);
    for (let i = 0; i < tokens.length; i++) {
      if (tokens[i] === target) {
        matchedRows.push(item);
        break;
      }
    }
  }

  // ê·œì¹™: ALLì´ ìˆìœ¼ë©´ ALL ì „ë¶€ + ë§¤ì¹­ ì „ë¶€ë¥¼ í•¨ê»˜ ë°˜í™˜ (ì¤‘ë³µ ì œê±°)
  const uniq = {};
  const out = [];
  const pushUniq = (it) => {
    const key = (it.hypothesisId || "") + "|" + (it.hypothesis || "") + "|" + (it.appliesTo || "");
    if (uniq[key]) return;
    uniq[key] = true;
    out.push(it);
  };

  for (let i = 0; i < allRows.length; i++) pushUniq(allRows[i]);
  for (let i = 0; i < matchedRows.length; i++) pushUniq(matchedRows[i]);

  return out;
}

function getLatestFinalReportTextForTicker_(ticker) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const rSheet = ss.getSheetByName("Final_Report");
  if (!rSheet) return "";
  const lastRow = rSheet.getLastRow();
  if (lastRow < 2) return "";
  const data = rSheet.getRange(2, 4, lastRow - 1, 9).getValues(); // D~L (ticker..reportText)
  // scan bottom-up to find latest ticker
  for (let i = data.length - 1; i >= 0; i--) {
    const t = String(data[i][0] || "").trim().toUpperCase();
    if (t && t === String(ticker || "").trim().toUpperCase()) {
      return String(data[i][8] || "");
    }
  }
  return "";
}
